[ { "title": "Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라", "url": "/posts/item-22-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EC%9A%A9%EB%8F%84%EB%A1%9C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Interface", "date": "2022-07-09 14:49:00 +0900", "snippet": "Effective Java의 스물두 번째 아이템 “인터페이스는 타입을 정의하는 용도로만 사용하라”를 읽고 정리한 내용을 포스팅합니다.1. 인터페이스의 용도인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 달리 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있을지를 클라이언트에게 얘기해주는 것이다. 인터페이스는 오직 이 용도로만 사용해야 한다.2. 상수 인터페이스위의 지침에 맞지 않는 예로 상수 인터페이스라는 것이 있다. 상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다. 그리고 이 상수들을 사용하려는 클래스에서는 정규화된 이름을 쓰는 걸 피하고자 그 인터페이스를 구현하곤 한다.public interface PhysicalConstants { // 아보가드로 수 (1/몰) static final double AVOGADROS_NUMBER = 6.022_140_857e23; // 볼츠만 상수 (J/K) static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23; // 전자 질량 (kg) static final double ELECTRON_MASS = 9.109_383_56e-31;}상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다. 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다. 따라서 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위다.클래스가 어떤 상수 인터페이스를 사용하든 사용자에게는 아무런 의미가 없다. 오히려 사용자에게 혼란을 주기도 하며, 더 심하게는 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속되게 한다. 그래서 다음 릴리스에서 이 상수들을 더는 쓰지 않게 되더라도 바이너리 호환성을 위해 여전히 상수 인터페이스를 구현하고 있어야 한다. final이 아닌 클래스가 상수 인터페이스를 구현한다면 모든 하위 클래스의 이름공간이 그 인터페이스가 정의한 상수들로 오염되어 버린다.상수를 공개할 목적이라면 더 합당한 선택지가 몇 가지 있다. 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다. 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개하면 된다. 그것도 아니라면, 인스턴스화할 수 없는 유틸리티 클래스에 담아 공개하자.3. 핵심 정리 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.4. Related Posts 열거 타입 (Item 34) 유틸리티 클래스 (Item 4)" }, { "title": "Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라", "url": "/posts/item-21-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Interface", "date": "2022-07-09 13:41:00 +0900", "snippet": "Effective Java의 스물한 번째 아이템 “인터페이스는 구현하는 쪽을 생각해 설계하라”를 읽고 정리한 내용을 포스팅합니다.1. 인터페이스 설계에서 주의할 점Java 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다. Java 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만, 위험이 완전히 사라진 것은 아니다.디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 이처럼 Java에도 기존 인터페이스에 메서드를 추가하는 길이 열렸지만, 모든 기존 구현체들과 매끄럽게 연동되리라는 보장은 없다.Java 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다. 주로 람다를 활용하기 위해서다. 자바 라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 상황에서 잘 작동한다. 하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 한다. 추가하려는 디폴트 메서드가 기존 구현테들과 충돌하지는 않을지 심사숙고해야 함도 당연하다.반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다.디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심해야 한다. 이런 형태로 인터페이스를 변경하면 반드시 기존 클라이언트를 망가뜨리게 된다.2. 핵심 정리 디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다. 새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 한다.3. Related Posts 인터페이스 (Item 20)" }, { "title": "Item 20. 추상 클래스보다는 인터페이스를 우선하라", "url": "/posts/item-20-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java", "date": "2022-07-03 18:24:00 +0900", "snippet": "Effective Java의 스무 번째 아이템 “추상 클래스보다는 인터페이스를 우선하라”를 읽고 정리한 내용을 포스팅합니다.1. 추상 클래스와 인터페이스Java가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두 가지다. Java 8부터 인터페이스도 디폴트 메서드를 제공할 수 있게 되어, 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.한편, 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. Java는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 되는 셈이다. 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.2. 인터페이스의 장점1) 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.인터페이스가 요구하는 메서드를 추가하고, 클래스 선언에 implements 구문만 추가으면 끝이다.반면 기존 클래스 위에 새로운 추상 클래스를 끼워넣기는 어려운 게 일반적이다. 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다. 이 방식은 클래스 계층구조에 커다란 혼란을 일으킨다. 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 되는 것이다.2) 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래 ‘주된 타입’외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.추상 클래스로는 믹스인을 정의할 수 없다. 이유는 앞서와 같이, 기존 클래스에 덧씌울 수 없기 때문이다. 클래스는 두 부모를 섬길 수 없고, 클래스 계층구조에는 믹스인을 삽입하기에 합리적인 위치가 없기 때문이다.3) 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에는 계층을 엄격히 구분하기 어려운 개념도 있다.4) 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다. 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.3. 디폴트 메서드인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 프로그래머들의 일감을 덜어줄 수 있다. 디폴트 메서드를 제공할 때는 상속하려는 사람을 위한 설명을 @implSpec 자바독 태그를 붙여 문서화해야 한다.디폴트 메서드에도 제약은 있다. 많은 인터페이스가 equals와 hashCode 같은 Object 메서드를 정의하고 있지만, 이들은 디폴트 메서드로 제공해서는 안 된다. 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없다.(단, private 정적 메서드는 예외다). 여러분이 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없다.4. 골격 구현인터페이스와 추상 골격 구현 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.인터페이스로는 타입을 정의하고, 필요하면 디폴트 메서드 몇 개도 함께 제공한다. 그리고 골격 구현 클래스는 나머지 메서드들까지 구현한다. 이렇게 해두면 단순히 골격 구현을 확장하는 것만으로 이 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다. 바로 템플릿 메서드 패턴이다.관례상 인터페이스 이름이 Interface라면 그 골격 구현 클래스의 이름은 AbstractInterface로 짓는다. ex) AbstractCollection, AbstractSet, AbstractList, AbstractMap제대로 설계했다면 골격 구현은 그 인터페이스로 나음의 구현을 만들려는 프로그래머의 일을 상당히 덜어준다. 예를 들어, 다음 코드는 완벽히 동작하는 List 구현체를 반환하는 정적 팩터리 메서드로, AbstractList 골격 구현으로 활용했다.// 골격 구현을 사용해 완성한 구체 클래스static List&amp;lt;Integer&amp;gt; intArrayAsList(int[] a) { Objects.requireNonNull(a); return new AbstractList&amp;lt;&amp;gt;() { @Override public Integer get(int i) { return a[i]; } @Override public Integer set(int i, Integer val) { int oldVal = a[i]; a[i] = val; return oldVal; } @Override public int size() { return a.length; } };}골격 구현 클래스의 아름다움은 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유롭다는 점에 있다.골격 구현을 확장하는 것으로 인터페이스 구현이 거의 끝나지만, 꼭 이렇게 해야 하는 것은 아니다. 구조상 골격 구현을 확장하지 못하는 처지라면 인터페이스를 직접 구현해야 한다. 이런 경우라도 인터페이스가 직접 제공하는 디폴트 메서드의 이점을 여전히 누릴 수 있다.또한, 골격 구현 클래스를 우회적으로 이용할 수도 있다. 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달하는 것이다. 래퍼 클래스와 비슷한 이 방식을 시뮬레이트한 다중 상속이라 하며, 다중 상속의 많은 장점을 제공하는 동시에 단점은 피하게 해준다.5. 골격 구현 작성 인터페이스를 잘 살펴 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정한다. 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공한다. 단, equals와 hashCode 같은 Object의 메서드는 디폴트 메서드로 제공하면 안 된다는 사실을 유념하자. 만약 인터페이스의 메서드 모두가 기반 메서드와 디폴트 메서드가 된다면 골격 구현 클래스를 별도로 만들 이유는 없다. 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성해 넣는다. 골격 구현 클래스에는 필요하면 public이 아닌 필드와 메서드를 추가해도 된다.간단한 예로 Map.Entry 인터페이스를 살펴보자. getKey, getValue는 확실히 기반 메서드이며, 선택적으로 setValue도 포함할 수 있다. 이 인터페이스는 equals와 hashCode의 동작 방식도 정의해놨다. Object 메서드들은 디폴트 메서드로 제공해서는 안 되므로, 해당 메서드들은 모두 골격 구현 클래스에 구현한다. toString도 기반 메서드를 사용해 구현해놨다.// 골격 구현 클래스public abstract class AbstractMapEntry&amp;lt;K, V&amp;gt; implements Map.Entry&amp;lt;K, V&amp;gt; { // 변경 가능한 엔트리는 이 메서드를 반드시 재정의해야 한다. @Override public V setValue(V value) { throw new UnsupportedOperationException(); } // Map.Entry.equals의 일반 규약을 구현한다. @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map.Entry)) return false; Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) &amp;amp;&amp;amp; Objects.equals(e.getValue(), getValue()); } // Map.Entry.hashCode의 일반 규약을 구현한다. @Override public int hashCode() { return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); } @Override public String toString() { return getKey() + &quot;=&quot; + getValue(); }}골격 구현은 기본적으로 상속해서 사용하는 걸 가정하므로 설계 및 문서화 지침을 모두 따라야 한다. 인터페이스에 정의한 디폴트 메서드든 별도의 추상 클래스든, 골격 구현은 반드시 그 동작 방식을 잘 정리해 문서로 남겨야 한다.단순 구현(simple implementation)은 골격 구현의 작은 변종으로, AbstractMap.SimpleEntry가 좋은 예다. 단순 구현도 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상 클래스가 아니란 점이 다르다. 쉽게 말해 동작하는 가장 단순한 구현이다. 이러한 단순 구현은 그대로 써도 되고 필요에 맞게 확장해도 된다.6. 핵심정리 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해보자. 골격 구현은 ‘가능한’ 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다. ‘가능한 한’이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다.7. Related Posts 문서화 (Item 19) 래퍼 클래스 (Item 18)" }, { "title": "Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라", "url": "/posts/item-19-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%84%9C%ED%99%94%ED%95%98%EB%9D%BC-%EA%B7%B8%EB%9F%AC%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%88%EC%A7%80%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, 상속", "date": "2022-07-02 15:31:00 +0900", "snippet": "Effective Java의 열아홉 번째 아이템 “상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라”를 읽고 정리한 내용을 포스팅합니다.1. 상속을 고려한 설계와 문서화1) 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.API 문서의 메서드 설명 끝에서 종종 “Implementation Requirements”로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다.다음은 java.util.AbstractCollection에서 발췌한 예다. public boolean remove(Object o) 주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에 ‘Object.equals(o, e)가 참인 원소’ e가 하나 이상 있다면 그중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면(즉, 호출 결과 이 컬렉션이 변경됐다면) true를 반환한다. Implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsuppoortedOperationException을 던지니 주의하자.2) 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.java.util.AbstractList의 removeRange 메서드를 예로 살펴보자. protected void removeRange(int fromIndex, int toIndex) fromIndex(포함)부터 toIndex(미포함)까지의 모든 원소를 이 리스트에서 제거한다. toIndex 이후의 원소들은 앞으로 (index만큼씩) 당겨진다. 이 호출로 리스트는 ‘toIndex - fromIndex’만큼 짧아진다. (toIndex == fromIndex라면 아무런 효과가 없다.) 이 리스트 혹은 이 리스트의 부분리스트에 정의된 clear 연산이 이 메서드를 호출한다. 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의하면 이 리스트와 부분리스트의 clear 연산 성능을 크게 개선할 수 있다. Implementation Requirements: 이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거할 때까지 ListIterator.next와 ListIterator.remove를 반복 호출하도록 구현되었다. 주의: ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다. Parameters: fromIndex 제거할 첫 원소의 인덱스 toIndex 제거할 마지막 원소의 다음 인덱스List 구현체의 최종 사용자는 removeRange 메서드에 관심이 없다. 그럼에도 이 메서드를 제공한 이유는 단지 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서다.removeRange 메서드가 없다면 하위 클래스에서 clear 메서드를 호출하면 (제거할 원소 수의) 제곱에 비례해 성능이 느려지거나 부분리스트의 메커니즘을 밑바닥부터 새로 구현해야 했을 것이다.3) 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 ‘유일’하다.꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다. 거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 크다.4) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.널리 쓰일 클래스를 상속용으로 설계한다면 문서화한 내부 사용 패턴과, protected 메서드오 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다. 이 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다.5) 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.이 규칙을 어기면 프로그램이 오동작할 것이다. 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.6) clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다(새로운 객체를 만든다). 따라서 상속용 클래스에서 Cloneable이나 Serializable을 구현할지 정해야 한다면, 이들을 구현할 때 따르는 제약도 생성자와 비슷하다는 점에서 주의하자.readObject의 경우 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다. clone의 경우 하위 클래스의 clone 메서드가 복제본의 상태를 (올바른 상태로) 수정하기 전에 재정의한 메서드를 호출한다.7) Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다.private으로 선언한다면 하위 크래스에서 무시되기 때문이다. 이 역시 상속을 허용하기 위해 내부 구현을 클래스 API로 공개하는 예 중 하나다.2. 주의할 점상속용으로 설계하지 않은 클래스는 상속을 금지하라. 상속을 금지하는 방법은 두 가지다. 클래스를 final로 선언한다. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어준다.3. 핵심정리 클래스 내부에스 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 한다. 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.4. Related Posts Cloneable (Item 13) Serializable (Item 86) 정적 팩터리 (Item 17)" }, { "title": "2장. 테스트", "url": "/posts/2%EC%9E%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "Book, 토비의 스프링", "tags": "Java, Spring, JUnit, 단위 테스트", "date": "2022-06-26 18:21:00 +0900", "snippet": "2.1 UserDaoTest 다시 보기2.1.1 테스트의 유용성코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 때와 다를 바 없이 기능을 잘 수행한다는 것을 보장하는 방법은 테스트를 통해 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다.테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.2.1.2 UserDaoTest의 특징public class UserDaoTest { public static void main(String[] args) throws SQLException { ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user = new User(); user.setId(&quot;user&quot;); user.setName(&quot;백기선&quot;); user.setPassword(&quot;married&quot;); dao.add(user); System.out.println(user.getId() + &quot; 등록 성공&quot;); User user2 = dao.get(user.getId()); System.out.println(user2.getName()); System.out.println(user2.getPassword()); System.out.println(user2.getId() + &quot; 조회 성공&quot;); }} main() 메서드를 이용해 쉽게 테스트 수행을 가능하게 했다. 테스트할 대상인 UserDao를 직접 호출해서 사용한다.웹을 통한 DAO 테스트 방법의 문제점보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 테스트를 진행한다.이러한 방법은 가장 흔히 쓰는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다. DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다. 테스트를 하는 중에 에러가 나거나 테스트에 실패했다면, 어디에서 문제가 발생했는지 찾아내야 하는 수고가 필요하다. 다른 계층의 코드와 컴포넌트, 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있다. 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기 힘들다. 그렇다면 테스트를 어떻게 만들면 이런 문제를 피할 수 있고, 효율적으로 테스트를 활용할 수 있을까?작은 단위의 테스트테스트하고자 하는 대상이 명확하다면 가능한 작은 단위로 쪼개 그 대상에만 집중해서 테스트하는 것이 바람직하다. UserDaoTest는 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트다. 웹 인터페이스나, 그것을 위한 MVC 클래스, 서비스 오브젝트 등이 필요 없다. 서버에 배포할 필요도 없이 간단하게 테스트 수행이 가능하다. 때문에 에러가 나거나 원치 않는 결과가 나와도 빠르게 원인을 찾을 수 있다.이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(unit test)라고 한다. 단위(unit)란 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다. 단위를 넘어서는 다른 코드들은 신경 쓰지 않고 참여하지도 않고 테스트가 동작할 수 있으면, 단위는 작을수록 좋다.자동수행 테스트 코드UserDaoTest의 한 가지 특징은 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 점이다. main() 메서드를 실행하는 간단한 방법만으로 테스트의 전 과정이 자동으로 진행된다.이렇게 테스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는 코드로 만들어져서 자동으로 수행될 수 있어야 한다는 것은 매우 중요하다.자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 번거로운 작업이 없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해 볼 수 있다.지속적인 개선과 점진적인 개발을 위한 테스트처음 만든 초난간 DAO 코드를, 스프링을 이용한 깔끔하고 완성도 높은 객체지향적 코드로 발전시키는 과정의 일등 공신은 테스트였다.만약 처음부터 스프링을 적용하고 XML로 설정을 만들고 모든 코드를 다 만들고 난 뒤에 이를 검증하려고 했다면, 쏟아지는 에러 메시지에 고민스러운 시간을 보내야 했을 것이다. 하지만 일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고, 테스트를 만들어 뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다.또 UserDao의 기능을 추가하려고 할 때도 미리 만들어둔 테스트 코드는 유용하게 쓰일 수 있다. 기존에 만들어뒀던 기능들이 여전히 잘 동작하는지를 확인할 수 있다.2.1.3 UserDaoTest의 문제점UserDaoTest가 UI까지 동원되는 번거로운 수동 테스트에 비해 장점이 많은 건 사실이다. 하지만 만족스럽지 못한 부분도 있다. UserDaoTest는 테스트를 수행하는 과정과 입력 데이터의 준비를 모두 자동으로 진행하도록 만들어졌다. 하지만 여전히 사람의 눈으로 확인하는 과정이 필요하다. 입력한 값과 가져온 값이 일치하는지를 테스트 코드는 확인해주지 않는다. 단지 콘솔에 값만 출력해줄 뿐이다. 결국 그 콘솔에 나온 값을 보고 등록과 조회가 성공적으로 되고 있는지를 확인하는 건 사람의 책임이다. 아무리 간단히 실행 가능한 main() 메서드라고 하더라도 매번 그것을 실행하는 것은 번거롭다. 만약 DAO가 수백 개가 되고 그에 대한 main() 메서드도 그만큼 만들어진다면, 전체 기능을 테스트해보기 위해 main() 메서드를 수백 번 실행하는 수고가 필요하다. 2.2 UserDaoTest 개선2.2.1 테스트 검증의 자동화UserDaoTest를 통해 확인하고 싶은 사항은, add()에 전달환 User 오브젝트에 담긴 사용자 정보와 get()을 통해 다시 DB에서 가져온 User 오브젝트의 정보가 서로 정확히 일치하는가이다.// 수정 전 테스트 코드System.out.println(user2.getName());System.out.println(user2.getPassword());System.out.println(user2.getId() + &quot; 조회 성공&quot;);// 수정 후 테스트 코드if (User.getName().equals(user2.getName())) { System.out.println(&quot;테스트 실패 (name)&quot;);}else if (!User.getPassword().equals(user2.getPassword())) { System.out.println(&quot;테스트 실패 (password)&quot;);}else { System.out.println(&quot;조회 테스트 성공&quot;);}처음에 add()에 전달한 User 오브젝트와 get()을 통해 가져오는 User 오브젝트의 값을 비교해서 일치하는지 확인하는 것이다. 만약 다른 값이 있다면 그때는 테스트가 실패했다고 출력하고 테스트를 마치면 된다.이 테스트는 UserDao의 두 가지 기능이 정상적으로 동작하는지를 언제든지 손쉽게 확인할 수 있게 해준다. 따라서 이 코드의 동작에 영향을 미칠 수 있는 어떤 변화라도 생기면 언제든 다시 실행해볼 수 있다.2.2.2 테스트의 효율적인 수행과 결과 관리좀 더 필리하게 테스트를 수행하고 편리하게 결과를 확인하려면 단순한 main() 메서드로는 한계가 있다. 일정한 패턴을 가진 테스트를 만들 수 있고, 많은 테스트를 간단히 실행시킬 수 있으며, 테스트 결과를 종합해서 볼 수 있고, 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.JUnit 테스트로 전환JUnit은 프레임워크다. 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다. 따라서 main() 메서드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다. 테스트 메서드 전환 main() 메서드에 있던 테스트 코드를 일반 메서드로 옮긴다. 메서드가 public으로 선언돼야 한다. 메서드에 @Test라는 애노테이션을 붙여줘야 한다. 검증 코드 전환 테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 assertThat이라는 스태틱 메서드를 이용해 변경한다. assertThat() 메서드는 첫 번째 파라미터의 값을 뒤에 나오는 매쳐라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. import static org.hamcrest.CoreWatchers.is;import static org.junit.Assert.asserThat;...public class UserDaoTest { // 테스트 메서드 전환 @Test public void addAndGet() throws SQLException { ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user = new User(); user.setId(&quot;gyumee&quot;); user.setName(&quot;박성철&quot;); user.setPassword(&quot;springno1&quot;); dao.add(user); User user2 = dao.get(user.getId()); // 검증 코드 전환 assertThat(user2.getName(), is(user.getName())); assertThat(user2.getPassword(), is(user.getPassword())); }}JUnit 테스트 실행 추가할 라이브러리 : com.springsource.org.junit-4.7.0.jar스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다. 어디에든 main() 메서드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메서드를 호출해주는 간단한 코드를 넣어주면 된다.import org.junit.runner.JUnitCore;...public static void main(String[] args) { JUnitCore.main(&quot;springbook.user.dao.UserDaoTest&quot;);}JUnit은 assertThat()을 이용해 검증했을 때 기대한 결과가 아니면 AssertionError를 던진다. 따라서 assertThat()의 조건을 만족하지 못하면 테스트는 더 이상 진행되지 않고 JUnit은 테스트가 실패했음을 알게된다. 테스트 수행 중에 일반 예외가 발생한 경우도 마찬가지다.2.3 개발자를 위한 테스팅 프레임워크 JUnit2.3.1 JUnit 테스트 실행 방법JUnitCore를 이요해 테스트를 실행하고 콘솔에 출력된 메시지를 보고 결과를 확인하는 방법은 가장 간단하긴 하지만 테스트의 수가 많아지면 관리하기가 힘들어진다.가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다. IDE JUnit 테스트 실행과 그 결과를 확인하는 방법이 매우 간단하고 직관적이며 소스와 긴밀하게 연동돼서 결과를 볼 수 있기 때문에, 개발 중에 테스트를 실행하고자 할 때는 IDE의 지원을 받는 것이 가장 편리하다. 빌드 툴 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때도 있다. 이런 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋다. 이때는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하면 된다. 2.3.2 테스트 결과의 일관성UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이다.가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그러면 테스트를 아무리 여러 번 반복해서 실행하더라도 항상 동일한 결과를 얻을 수 있다.deleteAll()와 getCount() 추가 deleteAll User 테이블의 모든 레코드를 삭제한다. getCount User 테이블의 레코드 개수를 조회한다. public void deleteAll() throws SQLException { Connection c = dataSource.getConnection(); PreparedStatement ps = c.prepareStatement(&quot;delete from users&quot;); ps.executeUpdate(); ps.close(); c.close();}public int getCount() throws SQLException { Connection c = dataSource.getConnection(); PreparedStatement ps = c.prepareStatement(&quot;select count(*) from users&quot;); ResultSet rs = ps.executeQuery(); rs.next(); int count = rs.getInt(); rs.close(); ps.close(); c.close(); return count;}deleteAll()과 getCount() 테스트@Test public void addAndGet() throws SQLException { ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); // 추가 dao.deleteAll(); assertThat(dao.getCount(), is(0)); User user = new User(); user.setId(&quot;gyumee&quot;); user.setName(&quot;박성철&quot;); user.setPassword(&quot;springno1&quot;); dao.add(user); // 추가 assertThat(dao.getCount(), is(1)); User user2 = dao.get(user.getId()); assertThat(user2.getName(), is(user.getName())); assertThat(user2.getPassword(), is(user.getPassword()));}동일한 결과를 보장하는 테스트단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다.DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아햐 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.2.3.3 포괄적인 테스트두 개 이상의 레코드를 add() 햇을 때는 getCount()의 실행 결과가 어떻게 될까? 0과 1 두 가지를 해봤으니 나머지도 당연히 잘될 것이라고 추정할 수도 있겠지만 미처 생각하지 못한 문제가 숨어 있을지도 모르니 더 꼼꼼한 테스트를 해보는 것이 좋은 자세다.getCount() 테스트여러 개의 User를 등록해가면서 getCount()의 결과를 매번 확인해보겠다.@Testpublic void count() throws SQLException { ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user1 = new User(&quot;gyumee&quot;, &quot;박성철&quot;, &quot;springno1&quot;); User user2 = new User(&quot;leegw700&quot;, &quot;이길원&quot;, &quot;springno2&quot;); User user3 = new User(&quot;bumjin&quot;, &quot;박범진&quot;, &quot;springno3&quot;); dao.deleteAll(); assertThat(dao.getCount(), is(0)); dao.add(user1); assertThat(dao.getCount(), is(1)); dao.add(user2); assertThat(dao.getCount(), is(2)); dao.add(user3); assertThat(dao.getCount(), is(3));}addAndGet() 테스트 보완이미 충분히 검증된 것 같다. 하지만 id를 조건으로 해서 사용자를 검색하는 기능을 가진 get()에 대한 테스트는 조금 부족한 감이 있다. get() 파라미터로 주어진 id에 해당하는 사용자를 가져온 것인지, 그냥 아무거나 가져온 것인지 테스트에서 검증하지는 못했다.User를 하나 더 추가해서 두 개의 User를 add() 하고, 각 User의 id를 파라미터로 전달해서 get()을 실행하도록 만들어보자.@Testpublic void addAndGet() throws SQLException { ... UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); User user1 = new User(&quot;gyumee&quot;, &quot;박성철&quot;, &quot;springno1&quot;); User user2 = new User(&quot;leegw700&quot;, &quot;이길원&quot;, &quot;springno2&quot;); dao.deleteAll(); assertThat(dao.getCount(), is(0)); dao.add(user1); dao.add(user2); assertThat(dao.getCount(), is(2)); User userget1 = dao.get(user1.getId()); assertThat(userget1.getName(), is(user1.getName())); assertThat(userget1.getPassword(), is(user1.getPassword())); User userget2 = dao.get(user2.getId()); assertThat(userget2.getName(), is(user2.getName())); assertThat(userget2.getPassword(), is(user2.getPassword()));}get() 예외조건에 대한 테스트get() 메서드에 전달된 id 값에 해당하는 사용자 정보가 없다면 어떻게 될까? 이럴땐 두 가지 방법이 있을 것이다. null과 같은 특별한 값을 리턴 id에 해당하는 정보를 찾을 수 없다고 예외를 던짐각기 장단점이 있는데 여기서는 후자의 방법을 써보자.@Test(expected=EmptyResultDataAccessException.class) // 발생할 것으로 기대되는 예외 클래스 지정public void getUserFailure() throws SQLException { ApplicationContext context = new GenericXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao dao = context.getBean(&quot;userDao&quot;, UserDao.class); dao.deleteAll(); assertThat(dao.getCount(), is(0)); dao.get(&quot;unknown_id&quot;); // 예외 발생(예외가 발생하지 않으면 테스트 실패)}테스트를 성공시키기 위한 코드의 수정위의 테스트가 성공하도록 get() 메서드 코드를 수정해야 한다. 주어진 id에 해당하는 데이터가 없으면 지정했던 예외를 던진다.public User get(String id) throws SQLException { ... ResultSet rs = ps.executeQuery(); User user = null; if (rs.next()) { user = new User(); user.setId(rs.getString(&quot;id&quot;)); user.setName(rs.getString(&quot;name&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); } rs.close(); ps.close(); c.close(); if (user == null) throw new EmptyResultDataAccessException(1); return user;}포괄적인 테스트개발자가 테스트를 직접 만들 때 자주 하는 실수가 하나 있다. 바로 성공하는 테스트만 골라서 만드는 것이다. 개발자는 머릿속으로 이 코드가 잘 돌아가는 케이스를 상상하면서 코드를 만드는 경우가 일반적이다. 그래서 테스트를 작성할 때도 문제가 될 만한 상황이나, 입력 값 등은 교모히도 잘 피해서 코드를 만드는 습성이 있다.그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다. get() 메서드의 경우라면, 존재하지 않는 id가 주어졌을 때는 어떻게 반응할지를 먼저 결정하고, 이를 확인할 수 있는 테스트를 먼저 만들려고 한다면 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다." }, { "title": "Item 18. 상속보다는 컴포지션을 사용하라", "url": "/posts/item-18-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, 상속, 컴포지션", "date": "2022-06-26 03:15:00 +0900", "snippet": "Effective Java의 열여덟 번째 아이템 “상속보다는 컴포지션을 사용하라”를 읽고 정리한 내용을 포스팅합니다.1. 상속의 문제점상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다. 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다. 하지만 일반적인 구체 클래스를 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.본문에서 말하는 ‘상속’은 클래스가 다른 클래스를 확장하는 구현 상속만을 말한다.메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.다르게 말하면, 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 이러한 이유로 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해두지 않으면 하위 클래스는 상위 클래스의 변화에 발맞춰 수정돼야만 한다.다음은 상속을 잘못 사용한 예이다. 성능을 높이기 위해 HashSet이 처음 생성된 이후 원소가 몇 개 더해졌는지 알 수 있도록 한다.public class InstrumentedHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { // 추가된 원소의 수 private int addCount = 0; public InstrumentedHashSet() {} public InstrumentedHashSet(int initCap, float, loadFactor) { super(initCap, loadFactor); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; }}이 클래스는 잘 구현된 것처럼 보이지만 제대로 작동하지 않는다. 이 클래스의 인스턴스에 addAll 메서드로 원소 3개를 더했다고 해보자. 이제 getAddCount 메서드를 호출하면 3을 반환하리라 기대하겠지만, 실제로는 6을 반환한다.그 원인은 HashSet의 addAll 메서드가 add 메서드를 사용해 구현된 데 있다. addAll 메서드에서 3을 더하고 다시 add 메서드를 세번 호출하며 3을 더해 6이 된 것이다.이 문제를 고치는 방법에는 세 가지가 있다. 하지만 또 다른 문제를 동반한다. addAll 메서드르 재정의하지 않는다. 하지만 HashSet의 addAll이 add 메서드를 이용해 구현했음을 가정한 해법이라는 한계를 지닌다. 따라서 가정에 기댄 InstrumentedHashSet도 깨지기 쉽다. 주어진 컬렉션을 순회하며 원소 하나당 add 메서드를 한 번만 호출한다. 하지만 상위 클래스의 메서드 동작을 다시 구현하는 이 방시은 어렵고, 시간도 더 들고, 자칫 오류를 내거나 성능을 떨어뜨릴 수도 있다. 하위 클래스에서는 접근할 수 없는 private 필드를 써야 하는 상황이라면 이 방식으로는 구현 자체가 불가능하다. 메서드를 재정의하는 대신 새로운 메서드로 추가한다. 다음 릴리스에서 상위 클래스에 새 메서드가 추가됐는데, 운 없게도 하필 하위 클래스에 추가한 메서드와 시그니처가 같고 반환 타입은 다르다면 컴파일조차 되지 않는다. 만약 반환 타입이 같다면 세 메서드를 재정의한 꼴이 되며, 상위 클래스의 메서드가 요구하는 규약을 만족하지 못할 가능성이 크다. 2. 컴포지션다행히 위에서 제시한 문제를 모두 피해가는 묘안이 있다. 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(composition)이라 한다.새 클래스의 인스턴스 메서드들은 기존 클래스에 대응하는 메서드를 호출해 그 결과를 반환한다. 이 방식을 전달(forwarding)이라 하며, 새 클래스의 메서드들을 전달 메서드(forwarding method)라 부른다. 그 결과 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향받지 않는다.다음은 이전에 봤던 InstrumentedHashSet을 컴포지션과 전달 방식으로 다시 구현한 코드이다.// 래퍼 클래스public class InstrumentedSet&amp;lt;E&amp;gt; extends ForwardingSet&amp;lt;E&amp;gt; { private int addCount = 0; public InstrumentedSet(Set&amp;lt;E&amp;gt; s) { super(s); } @Override public boolean add(E e) { addCount++; return super.add(e); } @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; }}// 재사용할 수 있는 전달 클래스public class ForwardingSet&amp;lt;E&amp;gt; implements Set&amp;lt;E&amp;gt; { private final Set&amp;lt;E&amp;gt; s; public ForwardingSet(Set&amp;lt;E&amp;gt; s) { this.s = s; } public void clear() { s.clear(); } public boolean contains(Object o) { return s.contains(o); } public boolean isEmpty() { return s.isEmpty(); } public int size() { return s.size(); } public Iterator&amp;lt;E&amp;gt; iterator() { return s.iterator(); } public boolean add(E e) { return s.add(e); } public boolean remove(Object o) { return s.remove(o); } public boolean containsAll(Collection&amp;lt;?&amp;gt; c) { return s.containsAll(c); } public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) { return s.addAll(c); } public boolean removeAll(Collextion&amp;lt;?&amp;gt; c) { return s.removeAll(c); } public boolean retainAll(Collection&amp;lt;?&amp;gt; c) { return s.retainAll(c); } public Object[] toArray() { return s.toArray(); } public &amp;lt;T&amp;gt; T[] toArray(T[] a) { return s.toArray(a); } @Override public boolean equals(Object o) { return s.equals(o); } @Override public int hashCode() { return s.hashCode(); } @Override public String toString() { return s.toString(); }}InstrumentedSet은 HashSet의 모든 기능을 정의한 Set 인터페이스를 활용해 설계되어 견고하고 아주 유연하다. 임의의 Set에 계측 기능을 덧씌워 새로운 Set으로 만드는 것이 이 클래스의 핵심이다.상속 방식은 구체 클래스 각가을 따로 확장해야 하며, 지원하고 싶은 상위 클래스의 생성자 각각에 대응하는 생성자를 별도로 정의해줘야 한다. 하지만 지금 선보인 컴포지션 방식은 한 번만 구현해두면 어떠한 Set 구현체라도 계측할 수 있으며, 기존 생성자들과도 함께 사용할 수 있다.컴포지션과 전달의 조합은 넓은 의미로 위임(delegation)이라고 부른다. 단, 엄밀히 따지면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당한다.3. 래퍼 클래스다른 Set 인스턴스를 감싸고(wrap) 있다는 뜻에서 InstrumentedSet 같은 클래스를 래퍼 클래스라 하며, 다른 Set에 계측 기능을 덧씌운다는 뜻에서 데코레이터 패턴이라고 한다.래퍼 클래스는 담점이 거의 없다. 한가지, 래퍼 클래스가 콜백 프레임워크와는 어울리지 않는다는 점만 주의하면 된다. 콜백 프레임워크에서는 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출(콜백)때 사용하도록 한다. 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 대신 자신(this)의 참조를 넘기고, 콜백 때는 래퍼가 아닌 내부 객체를 호출하게 된다. 이를 SELF 문제라고 한다.전달 메서드들을 작성하는게 지루하겠지만, 재사용할 수 있는 전달 클래스를 인터페이스당 하나씩만 만들어두면 원하는 기능을 덧씌우는 래퍼 클래스들을 아주 손쉽게 구현할 수 있다.4. 핵심 정리 상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야한다. 그런데 is-a 관계일 때도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 컴포지션을 사용하자.5. Related Posts 문서화 (Item 19)" }, { "title": "Item 17. 변경 가능성을 최소화하라", "url": "/posts/item-17-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%EC%84%B1%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, 불변 클래스", "date": "2022-06-15 23:15:00 +0900", "snippet": "Effective Java의 열일곱 번째 아이템 “변경 가능성을 최소화하라”를 읽고 정리한 내용을 포스팅합니다.1. 불변 클래스불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다. 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal이 여기에 속한다.불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.클래스를 불변으로 만들려면 다음 다섯 가지 규칙을 따라야 한다. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다. 클래스를 확장할 수 없도록 한다. 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다. 모든 필드를 final로 선언한다. 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다. 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장한다. 모든 필드를 private으로 선언한다. 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다. 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행하라. 2. 예제다음은 복수수를 표현한 불변 클래스의 예제이다.public final class Complex { private final double re; private final double im; public Complex(double re, double im) { this.re = re; this.im = im; } public double readPart() { return re; } public double imaginaryPart() { return im; } public Complex plus(Complex c) { return new Complex(re + c.re, im + c.im); } public Complex minus(Complex c) { return new Complex(re - c.re, im - c.im); } public Complex times(Complex c) { return new Complex(re * c.re - im * c.im, re * c.im + im * c.re); } public Complex dividedBy(Complex c) { return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp); } @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Complex)) return false; Complex c = (Complex) o; return Double.compare(c.re, re) == 0 &amp;amp;&amp;amp; Double.compare(c.im, im) == 0; } @Override public int hashCode() { return 31 * Double.hashCode(re) + Double.hashCode(im); } @Override public String toString() { return &quot;(&quot; + re + &quot; + &quot; im + &quot;i)&quot;; }}실수부와 허수부 값을 반환하는 접근자 메서드와 사칙연산 메서드를 정의했다. 이 사칙연산 메서드들이 인스턴스 자신은 수정하지 않고 새로운 Complex 인스턴스를 만들어 반환하는 모습에 주목하자. 또한 메서드 이름으로 (add 같은) 동사 대신 (plus) 같은 전치사를 사용한 점에도 주목하자.3. 장단점불변 객체는 다음과 같은 장점이 있다. 불변 객체는 단순하다. 불변 객체는 생성된 시점의 상태를 파괴할 때까지 그대로 간직한다. 모든 생성자가 클래스 불변식을 보장한다면 그 클래스르 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다. 불변 객체는 근본적으로 thread-safe하여 따로 동기화할 필요 없다. 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다. 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다. 따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하기를 권한다. ex) 상수(public static final), 캐싱 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다. ex) Map의 key, Set의 element 불변 객체는 그 자체로 실패 원자성을 제공한다. 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다. 불변 객체에도 단점이 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다. 값의 가짓수가 많다면 이를 모두 만드는 데 큰 비용을 치러야 한다. 원하는 객체를 완성하기까지의 단계가 많고, 그 중간 단계에서 만들어진 객체들이 모두 버려진다면 성능 문제가 더 불거진다. 위와 같은 문제에 대처하는 방법은 두 가지다. 흔히 쓰일 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법 이러한 다단계 연산을 기본으로 제공한다면 더 이상 각 단계마다 객체를 생성하지 않아도 된다. 가변 동반 클래스 클라이언트들이 원하는 복잡한 연산들을 정확히 예측할 수 있다면 package-private의 가변 동반 클래스만으로 충분하다. 그렇지 않다면 이 클래스를 public으로 제공하는 게 최선이다. ex) String - StringBuilder 4. 설계 방법본문을 시작하며 5가지 규칙을 통해 불변 클래스를 만드는 기본적인 방법을 알아보았다. 추가적으로 또 다른 설계 방법 두 가지를 알아본다. 모든 생성자를 private 혹은 packge-private으로 만들고 public 정적 팩터리를 제공하여 자신을 상속하지 못하게 한다. 바깥에서 볼 수 없는 package-private 구현 클래스를 원하는 만큼 만들어 활용할 수 있으니 final 클래스로 만드는 것보다 훨씬 유연하다. 다수의 구현 클래스를 활용한 유연성을 제공한다. 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다. public class Complex { private final double re; private final double im; private Complex(double re, double im) { this.re = re; this.im = im; } public static Complex valueOf(double re, double im) { return new Complex(re, im); } ...} 어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없도록 한다. 어떤 불변 클래스는 계산 비용이 큰 값을 나중에 (처음 쓰일 때) 계산하여 final이 아닌 필드에 캐시해놓기도 한다. 똑같은 값을 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감하는 것이다. 5. 핵심 정리 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다. 단순한 값 객체는 항상 불변으로 만들자. 무거운 값 객체도 불변으로 만들 수 있는지 고심해야 한다. 성능 때문에 어쩔 수 없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하도록 하자. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자. 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다. 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.6. Related Posts readObject 메서드 (Item 88) 정적 팩터리 (Item 1) 방어적 복사 (Item 50) 실패 원자성 (Item 76)" }, { "title": "Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라", "url": "/posts/item-16-public-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C%EB%8A%94-public-%ED%95%84%EB%93%9C%EA%B0%80-%EC%95%84%EB%8B%8C-%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Getter", "date": "2022-06-14 17:12:00 +0900", "snippet": "Effective Java의 열여섯 번째 아이템 “public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며이번 주제는 이전 포스팅과 상당히 밀접한 내용입니다. 이전에 public 클래스의 인스턴스는 되도록 public이 아니어야 한다고 했는데요. 여기에 초점을 맞춰 자세히 알아보겠습니다.1. public 클래스의 필드종종 인스턴스 필드를 모아놓는 일 외에는 아무 목적도 없는 퇴보한 클래스를 작성하려 할 때가 있습니다. 예를 들어 java.awt 패키지의 Point 클래스가 있습니다.package java.awt;public class Point extends Point2D implements java.io.Serializable { public int x; public int y; ...}이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못합니다. API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없습니다.이를 해결하기 위해 필드를 모두 private으로 바꾸고 public 접근자(getter)를 추가합니다.public class Point { private double x; private double y; public Point(double x, double y) { this.x = x; this.y = y; } public double getX() { return x; } public double getY() { return y; }}패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있습니다.만약 public 클래스의 필드가 불변이라면 어떨까요? 직접 노출될 때의 단점이 조금은 줄어들겠지만, 여전히 좋은 생각은 아닙니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점은 여전합니다. 단, 불변식은 보장할 수 있게 됩니다.2. 예외 상황위에서는 public 클래스에 대해서만 이야기했습니다. package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 문제가 없습니다. 그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 됩니다.이 방식은 클래스 선언 면에서나 이를 사용하는 클라이언트 코드 면에서나 접근자 방식보다 훨씬 깔끔합니다. 클라이언트 코드가 이 클래스 내부 표현에 묶이기는 하나, 클라이언트도 어차피 이 클래스를 포함하는 패키지 안에서만 동작하는 코드일 뿐입니다. 따라서 패키지 바깥 코드는 전혀 손대지 않고도 데이터 표현 방식을 바꿀 수 있습니다.3. 핵심 정리 public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다. package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.4. Related Posts 캡슐화 (Item 15)" }, { "title": "Item 15. 클래스와 멤버의 접근 권한을 최소화하라", "url": "/posts/item-15-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%A4%EB%B2%84%EC%9D%98-%EC%A0%91%EA%B7%BC-%EA%B6%8C%ED%95%9C%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java", "date": "2022-06-12 23:27:00 +0900", "snippet": "Effective Java의 열다섯 번째 아이템 “클래스와 멤버의 접근 권한을 최소화하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다.잘 설계되 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리합니다. 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않습니다. 이 개념은 이번 주제에 핵심이 되며 정보 은닉 또는 캡슐화라고도 부릅니다. 본문에서 자세히 알아보겠습니다.1. 정보 은닉정보 은닉은 내부 구현을 숨겨, 구현과 API를 분리하는 것입니다. 이를 통해 얻을 수 있는 장점은 어떤 것들이 있을까요?장점정보 은닉의 장점은 정말 많습니다. 그중 대부분은 시스템을 구성하는 컴포넌트들을 서로 독립시켜서 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 해주는 것과 연관되어 있습니다. 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있습니다. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적습니다. 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음, 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있습니다. 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 큽니다. 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있습니다. 2. 접근 제어 메커니즘Java는 정보 은닉을 위한 다양한 장치를 제공합니다. 그중 접근 제어 메커니즘은 클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)을 명시합니다. 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해집니다. 이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심입니다.접근 제어 메커니즘의 기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 한 좁히는 것입니다. 다시 말해, 소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다는 것입니다.톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 public과 package-private 두 가지입니다. public : 공개 API가 되며, 하위 호환을 위해 지속적으로 관리해줘야 한다. package-private : 해당 패키지 안에서만 이용할 수 있으며, API가 아닌 내부 구현이 되기 때문에 언제든지 수정할 수 있다.따라서 패키지 외부에서 써야 한다면 public으로, 그렇지 않으면 package-private로 선언하는 것이 좋습니다.멤버에 부여할 수 있는 접근 수준은 네 가지입니다. private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. (default) protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다. public : 모든 곳에서 접근할 수 있다.먼저 클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private으로 만듭니다. 그런 다음 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어줍니다. 만약 권한을 풀어주는 일을 자주 하게 된다면 시스템에서 컴포넌트를 더 분해해야 하는 것은 아닌지 다시 고민해봐야 합니다.그런데 접근성을 좁히지 못하게 방해하는 제약이 하나 있습니다. 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것입니다. 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환 원칙)을 지키기 위해 필요합니다.3. 주의할 점1) public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됩니다. 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 되는 것입니다. public 가변 필드를 갖는 클래스는 필드가 수정될 때 다른 작업을 할 수 없게 되므로 스레드에 안전하지 않습니다. 내부 구현을 바꾸고 싶을 때 public 필드가 final이면서 불변 객체를 참조하더라도 그 필드를 없애는 방식으로는 리팩터링할 수 없게 됩니다.예외적으로, 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로서의 상수라면 public static final 필드로 공개해도 괜찮습니다. 이런 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 합니다.2) 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 됩니다. 예를 들어 다음 코드에는 보안 허점이 존재합니다.public static final Thing[] VALUES = { ... };해결책은 두 가지가 있습니다. 첫 번째 방법은 앞 코드의 public 배열을 private으로 만들고 public 불변 리스트를 추가하는 것입니다.private static final Thing[] PRIVATE_VALUES = { ... };public static final List&amp;lt;Thing&amp;gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));두 번째는 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법입니다. (방어적 복사)private static final Thing[] PRIVATE_VALUES = { ... };public static final Thing[] values() { return PRIVATE_VALUES.clone();}어느 반환 타입이 더 쓰기 편할지, 성능은 어느 쪽이 나을지를 고민하여 둘 중 하나를 선택하면 됩니다.4. 모듈 시스템Java 9에서는 모듈 시스템이라는 개념이 도입되었습니다. 여기서 모듈은 패키지의 묶음입니다. 패키지가 클래스의 묶음이죠. 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있습니다.모듈 시스템에는 두 가지 암묵적인 접근 수준이 있습니다. 일반적인 public 수준과 protected 수준과 같으나, 그 효과가 모듈 내부로 한정됩니다. 이런 형태로 공유해야 하는 상황은 흔하지 않습니다. 그래야 하는 상황이 벌어지더라도 패키지들 사이에서 클래스들을 재배치하면 대부분 해결됩니다.5. 핵심 정리 프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 한다. public 클래스는 public static final 필드 외에는 어떠한 필드도 가져가서는 안 된다. public static final 필드가 참조하는 객체가 불변인지 확인하라.6. Related Posts 최적화 (Item 67) 상속을 고려한 설계 (Item 19) public 클래스에서의 접근자 메서드 (Item 16) 명명 규칙 (Item 68) 불변 객체 (Item 17)" }, { "title": "1. 카프카의 탄생과 빅데이터 파이프라인에서 카프카의 역할", "url": "/posts/1-%EC%B9%B4%ED%94%84%EC%B9%B4%EC%9D%98-%ED%83%84%EC%83%9D%EA%B3%BC-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%97%90%EC%84%9C-%EC%B9%B4%ED%94%84%EC%B9%B4%EC%9D%98-%EC%97%AD%ED%95%A0/", "categories": "Book, 아파치 카프카 애플리케이션 프로그래밍 with 자바", "tags": "아파치 카프카 애플리케이션 프로그래밍 with 자바, Kafka, Big Data", "date": "2022-06-04 17:02:00 +0900", "snippet": "‘아파치 카프카 애플리케이션 프로그래밍 with 자바’를 읽고 정리한 내용을 포스팅합니다.1. 카프카의 탄생링크드인의 초기 운영 시에는 단방향 통신을 통해 소스 애플리케이션에서 타깃 애플리케이션으로 연동하는 소스코드를 작성했다. 시간이 지날수록 아키텍처가 거대해졌고, 소스 애플리케이션과 타깃 애플리케이션의 개수가 많아지면서 데이터를 전송하는 라인이 기하급수적으로 복잡해졌다.이에따라 소스코드 및 버전 관리에서 이슈가 발생했고, 타깃 애플리케이션에 장애가 생길 경우 그 영향은 소스 애플리케이션에 그대로 전달되었다. 이런 데이터 파이프라인의 파편화를 개선하기 위해 연구한 결과 아파치 카프카가 탄생했다.카프카는 각각의 애플리케이션끼리 연결하여 데이터를 처리하는 것이 아니라 한 곳에 모아 처리할 수 있도록 중앙집중화했다. 카프카를 중앙에 배치함으로써 소스 애플리케이션과 타깃 애플리케이션 사이의 의존도를 최소화하여 커플링을 완화하였다.카프카를 통해 전달할 수 있는 데이터 포맷은 사실상 제한이 없다. 직렬화, 역질렬화를 통해 ByteArray로 통신하기 때문에 자바에서 선언 가능한 모든 객체를 지원한다.카프카 클러스터 중 일부 서버에 장애가 발생하더라도 데이터를 지속적으로 복제하기 때문에 안전하게 운영할 수 있다. 또한, 데이터를 묶음 단위로 처리하는 배치 전송을 통해 낮은 지연과 높은 데이터 처리량도 가지게 되었다.2. 빅데이터 파이프라인에서 카프카의 역할빅데이터로 적재되는 데이터의 종류는 스키마 기반의 정형 데이터부터 비정형 데이터까지 다양하다. 이런 방대한 양의 데이터를 기존의 데이터베이스로 관리하는 것은 불가능에 가깝다. 빅데이터를 저장하고 활용하기 위해서는 일단 생성되는 데이터를 모두 모으는 것이 중요한데, 이때 사용되는 개념이 ‘데이터 레이크(data lake)’다.데이터 레이크는 이름에서 유추할 수 있는 것처럼 데이터가 모이는 저장 공간을 뜻한다. 데이터 웨어하우스와 다르게 필터링되거나 패키지화되지 않은 데이터가 저장된다는 점이 특징이다. 즉, 운영되는 서비스로부터 수집 가능한 모든 데이터를 모으는 것이다.서비스에서 발생하는 데이터를 데이터 레이크로 모으려면 어떻게 해야 할까? 단순히 생각해보면 발생하는 데이터를 데이터 레이크에 직접 end-to-end 방식으로 넣을 수 있다. 그러나 이 방식은 서비스가 비대해지고 복잡해지면서 파편화되고 복잡도가 올라가는 문제점이 발생한다. 이를 해결하기 위해서 데이터를 추출하고 변경, 적재하는 과정을 묶은 데이터 파이프라인을 구축해야 한다.end-to-end 방식의 데이터 수집 및 적재를 개선하고 안정성을 추구하며, 유연하면서도 확장 가능하게 자동화한 것을 ‘데이터 파이프라인‘이라고 부른다. 그리고 데이터 파이프라인을 안정적이고 확장성 높게 운영하기 위한 좋은 방법 중 하나가 바로 아파치 카프카를 활용하는 것이다.아파치 카프카가 데이터 파이프라인으로 적합한 이유는 다음과 같다.높은 처리량 카프카는 프로듀서가 브로커로 데이터를 보낼 때와 컨슈머가 브로커로부터 데이터를 받을 때 모두 묶어서 전송한다. 많은 양의 데이터를 묶음 단위로 처리하는 배치로 빠르게 처리할 수 있기 때문에 대용량의 실시간 로그데이터를 처리하는 데에 적합하다. 파티션 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하고 데이터를 병렬처리할 수 있다. 파티션 개수만큼 컨슈머 개수를 늘려서 동일 시간당 데이터 처리량을 늘리는 것이다.확장성 카프카는 데이터가 얼마나 들어올지 예측하기 어려운 가변적인 환경에서 안정적으로 확장 가능하도록 설계되었다. 데이터가 적을 때는 카프카 클러스터의 브로커를 최소한의 개수로 운영하다가 데이터가 많아지면 클러스터의 브로커 개수를 자연스럽게 늘려 scale-out할 수 있다. 반대로 데이터 개수가 적어지고 추가 서버들이 더는 필요 없어지면 브로커 개수를 줄여 scale-in할 수 있다.영속성 영속성이란 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 뜻한다. 카프카는 다른 메시징 플랫폼과 다르게 전송받은 데이터를 메모리에 저장하지 않고 파일 시스템에 저장한다. 때문에 브로커 애플리케이션이 장애 발생으로 인해 급작스럽게 종료되더라도 프로세스를 재시작하여 안전하게 데이터를 다시 처리할 수 있다.고가용성 클러스터로 이루어진 카프카는 데이터의 replication(복제)을 통해 고가용성의 특징을 가지게 되었다. 프로듀서로 전송받은 데이터를 여러 브로커 중 1대의 브로커에만 저장하는 것이 아니라 또 다른 브로커에도 저장하는 것이다. 한 브로커에 장애가 발생하더라도 복제된 데이터가 나머지 브로커에 저장되어 있으므로 지속적으로 데이터 처리가 가능하다. 추가로 on-premise 환경의 서버 랙 또는 public cloud의 리전 단위 장애에도 데이터를 안전하게 복제할 수 있는 브로커 옵션들이 준비되어 있다." }, { "title": "WebFlux - 개념", "url": "/posts/webflux-%EA%B0%9C%EB%85%90/", "categories": "Server, Spring", "tags": "Spring, WebFlux, Reactive Programming", "date": "2022-06-03 00:08:00 +0900", "snippet": "최근 회사에서 웹플럭스(WebFlux)에 대한 이야기를 들었다. 처음 들어본 단어였지만 이미 핫한 기술이었고, 이전에 항상 사용했던 Spring MVC와는 또다른 구조였기에 상당히 흥미로웠다. 그리고 예전에 진행했던 프로젝트에서 비동기 처리를 위해 Future를 사용했는데 웹플럭스 방식으로 처리했다면 더 좋지 않았을까 하는 생각도 들었다.이번 포스팅에서는 웹플럭스에 대한 개념을 정리하고 더 깊은 내용은 다음 포스팅에서 이어나간다.1. Reactive Programming웹플럭스를 이해하기 위해서는 먼저 리액티브 프로그래밍을 이해해야 한다. 리액티브 프로그래밍은 변화의 전파와 데이터 흐름과 관련된 선언적 프로그래밍 패러다임이다.여기서 ‘변화의 전파와 데이터 흐름’이라는 것은 데이터가 변경 될 때마다 이벤트를 발생시켜 데이터를 계속적으로 전달하는 것을 말한다. 쉽게 말하면, 데이터 A의 변화에 따라 데이터 B의 값이 변화하는 방식이다.‘선언적 프로그래밍’은 실행할 동작을 구체적으로 명시하는 명령형 프로그래밍과 달리 단순히 목표를 선언하는 프로그래밍 방식이다. 즉, 프로그램이 아닌 주변 데이터의 변경에 따른 이벤트가 흐름을 주도하는 방식을 말한다.리액티브 선언 (Reactive Menifesto)리액티브의 애플리케이션과 시스템 개발의 원칙을 공식적으로 정의한 문서이다. 반응성 (Responsive) 시스템은 즉각 응답해야하며, 이로 인해 일관성있는 service quality를 제공할 수 있어야 한다. 회복성 (Resilient) 장애가 발생해도 시스템은 반응해야 한다. 여러 컴포넌트의 시간과 공간 분리(컴포넌트가 각각 독립적인 생명주기를 갖고 다른 프로세스에서 실행), 작업 위임시 비동기적으로 위임하는 등의 기법이 있다. 탄력성 (Elastic) 시스템은 다양한 워크로드에서도 반응성을 유지해야 한다. 입력값이나 작업량이 변하더라도 유연하게 반응성을 유지해야 하며, 다양한 HW/SW 플랫폼에서도 효율적인 cost로 반응성을 확보해야 한다. 메시지 주도 (Message driven) 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원하도록 경계를 명확히 정의한다. 또한 비동기 메시지를 전달해 컴포넌트 간 통신이 이뤄진다. 2. WebFlux3. Reference https://realzero0.github.io/study/2021/12/02/Lets_Start_Webflux.html https://yunzai.dev/posts/RxJava_%EB%A6%AC%EC%97%91%ED%8B%B0%EB%B8%8C(Reative)_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80/ https://velog.io/@bahar-j/%EC%9B%B9%ED%94%8C%EB%9F%AD%EC%8A%A4-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EA%B4%80%ED%95%9C-%EA%B3%A0%EC%B0%B0 https://madplay.github.io/post/spring-webflux-references-overview https://hungseong.tistory.com/44 https://juneyr.dev/reactive-programming" }, { "title": "Kafka - 개념", "url": "/posts/kafka-%EA%B0%9C%EB%85%90/", "categories": "Infra, Kafka", "tags": "Kafka", "date": "2022-06-02 00:03:00 +0900", "snippet": "…" }, { "title": "Item 14. Comparable을 구현할지 고려하라", "url": "/posts/item-14-comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Override, Comparable, Comparator", "date": "2022-05-28 01:05:00 +0900", "snippet": "Effective Java의 열네 번째 아이템 “Comparable을 구현할지 고려하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며이번 포스팅은 정렬과 관련 있습니다. 개발을 하다 보면 정렬이 필요한 순간이 정말 많은데요. 그만큼 확실히 알아두면 유용한 내용이 내용일 될 것 같습니다. 본문에서 Comparable 인터페이스와 compareTo 메서드 작성 요령, 그리고 비슷한 기능을 하는 Comparator 인터페이스에 대해 알아보겠습니다.1. Comparablepackage java.lang;import java.util.*;public interface Comparable&amp;lt;T&amp;gt; { public int compareTo(T o);}Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻합니다. 그래서 Comparable을 구현한 객체들의 배열은 Arrays.sort 메서드를 통해 손쉽게 정렬할 수 있습니다. 또한 검색, 극단값 계산, 자동 정렬되는 컬렉션 관리도 역시 쉽게 할 수 있습니다. 예를 들어 String이 Comparable을 구현한 덕분에 다음 코드는 문자열 배열을 알파벳순으로 출력합니다. String[] values = new String[]{&quot;heung&quot;, &quot;bae&quot;, &quot;hoon&quot;, &quot;na&quot;}; Set&amp;lt;String&amp;gt; s = new TreeSet&amp;lt;&amp;gt;(); Collections.addAll(s, values); System.out.println(s); /* 실행 결과 [bae, heung, hoon, na] */사실상 자바 플랫폼 라이브러리의 모든 값 클래스와 열거 타입은 Comparable을 이미 구현하고 있습니다. Comparable을 구현하면 Comparable을 활용하는 수많은 제네릭 알고리즘과 컬렉션의 힘을 누릴 수 있습니다. 따라서 알파벳, 숫자같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현해야 합니다.2. 일반 규약compareTo 메서드의 일반 규약은 equals의 규약과 비슷합니다. 이 객체와 주어진 객체의 순서를 비교한다. 이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다. 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다. 다음 설명에서 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)을 뜻하며, 표현식의 값이 음수, 0, 양수일 때 -1, 0, 1을 반환하도록 정의했다. Comparable을 구현한 클래스는 모든 x, y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야 한다. Comparable을 구현한 클래스는 추이성을 보장해야 한다. 즉, (x.compareTo(y) &amp;gt; 0 &amp;amp;&amp;amp; y.compareTo(z) &amp;gt; 0)이면 x.compareTo(z) &amp;gt; 0이다. Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))다. (x.compareTo(y) == 0) == (x.equals(y))여야 한다. 이번 권고가 필수는 아니지만 꼭 지키는 것이 좋다. Comparable을 구현하고 이 권고를 지키지 않는 모든 클래스는 그 사실을 명시해야 한다. 모든 객체에 대해 전역 동치관계를 부여하는 equals 메서드와 달리, compareTo는 타입이 다른 객체를 신경쓰지 않아도 됩니다. 타입이 다른 객체가 주어지면 간단히 ClassCastException을 던져도 되며, 대부분 그렇게 합니다.compareTo 규약을 지키지 못하면 비교를 활용하는 클래스와 어울리지 못합니다. 비교를 활용하는 클래스의 예로는 정렬된 컬렉션인 TreeSet과 TreeMap, 검색과 정렬 알고리즘을 활용하는 유틸리티 클래스인 Collections와 Arrays가 있습니다.세 규약은 compareTo 메서드로 수행하는 동치성 검사도 equals 규약과 똑같이 반사성, 대칭성, 추이성을 충족해야 함을 뜻합니다. 그래서 주의사항도, 우회법도 같습니다.마지막 규약은 필수는 아니지만 꼭 지키길 권합니다. 간단히 말하면 compareTo 메서드로 수행한 동치성 테스트의 결과가 equals와 같아야 한다는 것입니다. 이를 잘 지키면 compareTo로 줄지은 순서와 equals의 결과가 일관되게 됩니다.3. 작성 요령compareTo 메서드 작성 요령은 equals와 비슷합니다. 몇 가지 차이점만 주의하면 됩니다.3.1. Comparable은 타입을 인수로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인수 타입은 컴파일타임에 정해진다.입력 인수의 타입을 확인하거나 형변환할 필요가 없다는 뜻입니다. 인수의 타입이 잘못됐다면 컴파일 자체가 되지 않습니다.3.2. compareTo 메서드는 각 필드가 동치인지를 비교하는 것이 아니라 그 순서를 비교한다.객체 참조 필드를 비교하려면 compareTo 메서드를 재귀적으로 호출합니다. Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 비교자(Comparator)를 대신 사용합니다.public final class CaseInsensitiveString implements Comparable&amp;lt;CaseInsensitiveString&amp;gt; { private final String s; public CaseInsensitiveString(String s) { this.s = Objects.requireNonNull(s); } @Override public int compareTo(CaseInsensitiveString cis) { return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s); // 자바가 제공하는 기본 Comparator } ...}3.3. compareTo 메서드에서 관계 연산자 &amp;lt;와 &amp;gt;를 사용하는 이전 방식은 거추장스럽고 오류를 유발하니 추천하지 않는다.자바 7 이전에는 정수 기본 타입 필드를 비교할 때 관계 연산자인 &amp;lt;와 &amp;gt;를 사용하라고 권고했습니다. 하지만 이제는 박싱된 기본 타입 클래스에 새로 추가된 정적 메서드인 compare을 사용하는 것을 추천합니다.3.4. 클래스에 핵심 필드가 여러 개라면 어느 것을 먼저 비교하느냐가 중요해진다.가장 핵심적인 필드부터 비교해 나아가야 합니다. 비교 결과가 0이 아니라면, 즉 순서가 결정되면 거기서 끝내고 곧장 결과를 반환합니다. 가장 핵심이 되는 필드가 똑같다면, 똑같지 않은 필드를 찾을 때까지 그다음으로 중요한 필드를 비교해 나갑니다.다음은 PhoneNumber 클래스용 compreTo 메서드를 이 방식으로 구현한 모습니다.public class PhoneNumber implements Comparable&amp;lt;PhoneNumber&amp;gt; { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = (short) areaCode; this.prefix = (short) prefix; this.lineNum = (short) lineNum; } @Override public int compareTo(PhoneNumber pn) { int result = Short.compare(areaCode, pn.areaCode); if (result == 0) { result = Short.compare(prefix, pn.prefix); if (result == 0) result = Short.compare(lineNum, pn.lineNum); } return result; } ...}4. Comparator자바 8에서는 Comparator 인터페이스가 일련의 생성 메서드와 팀을 꾸려 메서드 연쇄 방식으로 Comparator 인스턴스를 생성할 수 있게 되었습니다. 그리고 이 Comparator는 Comparable 인터페이스가 원하는 compareTo 메서드를 구현하는 데 활용할 수 있습니다.다음은 PhoneNumber용 compareTo 메서드에 이 방식을 적용한 모습입니다.import java.util.Comparator;import static java.util.Comparator.comparingInt;public class PhoneNumber implements Comparable&amp;lt;PhoneNumber&amp;gt; { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = (short) areaCode; this.prefix = (short) prefix; this.lineNum = (short) lineNum; } private static final Comparator&amp;lt;PhoneNumber&amp;gt; COMPARATOR = comparingInt((PhoneNumber pn) -&amp;gt; pn.areaCode) .thenComparingInt(pn -&amp;gt; pn.prefix) .thenComparingInt(pn -&amp;gt; pn.lineNum); @Override public int compareTo(PhoneNumber pn) { return COMPARATOR.compare(this, pn); } ...}Comparator는 수많은 보조 생성 메서드들을 가지고 있습니다. 자바의 숫자용 기본 타입을 모두 커버할 뿐 아니라 객체 참조용 Comparator 생성 메서드도 준비되어 있습니다. 이처럼 Comparator은 매우 간결하게 쓸 수 있다는 장점이 있지만, 약간의 성능 저하가 뒤따른다는 단점도 가지고 있습니다.5. 주의할 점종종 ‘값의 차’를 기준으로 첫 번째 값이 두 번째 값보다 작으면 음수를, 두 값이 같으면 0을, 첫 번째 값이 크면 양수를 반환하는 compareTo나 compare 메서드와 마주하게 됩니다. 예를 들면 다음과 같은 코드가 있습니다.static Comparator&amp;lt;Object&amp;gt; hashCodeOrder = new Comparator&amp;lt;Object&amp;gt;() { @Override public int compare(Object o1, Object o2) { return o1.hashCode() - o2.hashCode(); }};이 방식은 사용하면 안 됩니다. 정수 오버플로를 일으키거나 IEEE 754 부동소수점 계산 방식에 따른 오류를 낼 수 있습니다. 그 대신 다음의 두 방식 중 하나를 사용하는 것을 권장합니다.1) 정적 compare 메서드를 활용한 Comparatorstatic Comparator&amp;lt;Object&amp;gt; hashCodeOrder = new Comparator&amp;lt;Object&amp;gt;() { @Override public int compare(Object o1, Object o2) { return Integer.compare(o1.hashCode(), o2.hashCode()); }};2) 생성 메서드를 활용한 Comparatorstatic Comparator&amp;lt;Object&amp;gt; hashCodeOrder = Comparator.comparingInt(o -&amp;gt; o.hashCode());6. 핵심 정리 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하자. compareTo 메서드에서 필드의 값을 비교할 때 &amp;lt;와 &amp;gt; 연산자는 쓰지 말아야 한다. 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 생성 메서드를 사용하자.7. Related Posts 열거 타입 (Item 34) equals 규약 (Item 10)" }, { "title": "Item 13. clone 재정의는 주의해서 진행하라", "url": "/posts/item-13-clone-%EC%9E%AC%EC%A0%95%EC%9D%98%EB%8A%94-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%84%9C-%EC%A7%84%ED%96%89%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Override, clone", "date": "2022-05-24 23:26:00 +0900", "snippet": "Effective Java의 열세 번째 아이템 “clone 재정의는 주의해서 진행하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스(mixin interface)지만, 아쉽게도 의도한 목적을 제대로 이루지 못했습니다. 가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라는 데 있습니다. 그래서 Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메서드를 호출할 수 없습니다.하지만 이를 포함한 여러 문제점에도 불구하고 Cloneable 방식은 널리 쓰이고 있어서 잘 알아두는 것이 좋습니다. 이번 포스팅에서는 clone 메서드를 잘 동작하게끔 해주는 구현 방법과 언제 그렇게 해야 하는지, 그리고 가능한 다른 선택지에 대해 알아보겠습니다.1. Cloneable 인터페이스위에서 언급했던것 처럼 Cloneable은 복제해도 되는 클래스임을 명시하는 용도로 사용되는 인터페이스입니다. 다음은 java.lang 패키지에 구현된 실제 코드입니다.package java.lang;public interface Cloneable {}이상한 점이 있습니다. 일반적으로 인터페이스를 구현한다는 것은 해당 클래스가 그 인터페이스에서 정의한 기능을 제공한다고 선언하는 행위입니다. 그런데 Cloneable은 어떠한 메서드도 정의하고 있지 않습니다. 그렇다면 대체 무슨 일을 하는 걸까요?Cloneable은 Object의 protected 메서드인 clone의 동작 방식을 결정합니다. Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException을 던집니다. 참고로 이는 이례적으로 사용한 예이니 따라하지 않는 것이 좋습니다.실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이루어지라 기대합니다. 이 기대를 만족시키려면 그 클래스와 모든 상위 클래스는 허술하게 기술된 프로토콜을 지켜야만 하는데, 그 결과로 깨지기 쉽고, 위험하고, 모순적인 메커니즘이 탄생합니다. 생성자를 호출하지 않고도 객체를 생성할 수 있게 되는 것입니다.2. 일반 규약다음은 Object 명세서에서 가져온 clone 메서드의 일반 규약입니다. 이 객체의 복사본을 생성해 반환한다. ‘복사’의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다. 일반적인 의도는 다음과 같다. 어떤 객체 x에 대해 다음 식은 참이다. x.clone() != x x.clone().getClass() == x.getClass() x.clone().equals(x) 하지만 위의 요구를 반드시 만족해야 하는 것은 아니다. 관례상, 이 메서드가 반환하는 객체는 super.clone을 호출해 얻어야 한다. 이 클래스와 (Object를 제외한) 모든 상위 클래스가 이 관례를 따른다면 다음 식은 참이다. x.clone().getClass() == x.getClass() 관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.위 규약은 허술합니다. clone 메서드가 super.clone이 아닌, 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 불평하지 않을 것입니다. 하지만 이 클래스의 하위 클래스에서 super.class를 호출한다면 잘못된 클래스의 객체가 만들어져, 결국 하위 클래스의 clone 메서드가 제대로 동작하지 않게 됩니다.3. 작성 요령상위 클래스가 제대로 동작하는 clone 메서드를 가지고 있다고 생각하고, 이를 상속해 Cloneable을 구현하는 방법을 소개합니다. 구현 방법은 해당 클래스가 어떤 필드를 가지고 있는지에 따라 세 가지로 나뉘는데요. 하나하나 예제를 통해 알아보겠습니다.3.1. 가변 상태를 참조하지 않는 클래스클래스의 모든 필드가 기본 타입이거나 불변 객체를 참조할 경우입니다.public class PhoneNumber implements Cloneable { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = (short) areaCode; this.prefix = (short) prefix; this.lineNum = (short) lineNum; } @Override public PhoneNumber clone() { try { return (PhoneNumber) super.clone(); } catch (CloneNotSupportedException e) { throw new AssertionError(); } }}Object의 clone 메서드는 Object를 반환하지만 PhoneNumber의 clone 메서드는 PhoneNumber을 반환합니다. 자바가 공변 반환 타이핑(convariant return typing)을 지원하니 이렇게 하는 것이 가능하고 권장하는 방식입니다. 다시 말해, 재정의한 메서드의 반환 타입은 상위 클래스의 메서드가 반환하는 타입의 하위 타입일 수 있습니다.3.2. 가변 상태를 참조하는 클래스간단했던 앞서의 구현이 클래스가 가변 객체를 참조하는 순간 재앙으로 돌변합니다.public class Stack implements Cloneable { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; return result; } // 원소를 위한 공간을 적어도 하나 이상 확보한다. private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); }}이 클래스의 clone 메서드가 단순히 super.clone의 결과를 그대로 반환한다면 어떻게 될까요? 반환된 Stack 인스턴스의 size 필드는 올바른 값을 갖겠지만, elements 필드는 원본 Stack 인스턴스와 똑같은 배열을 참조할 것입니다. 따라서 원본이나 복제본 중 하나를 수정하면 다른 하나도 수정되어 불변식을 해칠 것입니다.Stack 클래스의 하나뿐인 생성자를 호출하면 이러한 상황은 절대 일어나지 않습니다. clone 메서드는 사실상 생성자와 같은 효과를 냅니다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 합니다.Stack의 clone 메서드는 제대로 동작하려면 스택 내부 정보를 복사해야 합니다. 가장 쉬운 방법은 elements 배열의 clone을 재귀적으로 호출하는 것입니다.@Overridepublic Stack clone() { try { Stack result = (Stack) super.clone(); result.elements = elements.clone(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); }}배열의 clone은 런타임 타입과 컴파일 타입 모두가 원본 배열과 똑같은 배열을 반환합니다. 따라서 배열을 복제할 때는 배열의 clone 메서드를 사용하라고 권장합니다. 사실, 배열은 clone 기능을 제대로 사용하는 유일한 예라고 할 수 있습니다.3.3. 복잡한 가변 상태를 참조하는 클래스clone을 재귀적으로 호출하는 것만으로는 충분하지 않을 때도 있습니다. 해시테이블용 clone 메서드를 생각해 보겠습니다. 해시테이블 내부는 버킷들의 배열이고, 각 버킷은 키-값 쌍을 담는 연결 리스트의 첫 번째 엔트리를 참조합니다.public class HashTable implements Cloneable { private Entry[] buckets = new Entry[10]; private static class Entry { final Object key; Object value; Entry next; Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next; } public void add(Object key, Object value) { this.next = new Entry(key, value, null); } } ...}Stack에서처럼 단순히 버킷 배열의 clone을 재귀적으로 호출하면 어떻게 될까요?@Overridepublic HashTable clone() { HashTable result = null; try { result = (HashTable)super.clone(); result.buckets = this.buckets.clone(); return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); }}복제본은 자신만의 버킷 배열을 갖지만, 이 배열은 원본과 같은 연결 리스트를 참조하여 원본과 복제본 모두 예기치 않게 동작할 가능성이 생깁니다. 이를 해결하려면 각 버킷을 구성하는 연결 리스트를 복사해야 합니다.@Overridepublic HashTable clone() { HashTable result = null; try { result = (HashTable) super.clone(); result.buckets = new Entry[this.buckets.length]; for (int i = 0; i &amp;lt; this.buckets.length; i++) { if (buckets[i] != null) { result.buckets[i] = this.buckets[i].deepCopy(); // 연결 리스트 복사 } } return result; } catch (CloneNotSupportedException e) { throw new AssertionError(); }}책에서는 deepCopy를 구현하는 세 가지 방법을 소개합니다.3.3.1 재귀public Entry deepCopy() { return new Entry(key, value, next == null ? null : next.deepCopy());}private 클래스인 HashTable.Entry는 깊은 복사를 지원하도록 보강되었습니다. HashTable의 clone 메서드는 먼저 적절한 크기의 새로운 버킷 배열을 할당한 다음, 원래의 버킷 배열을 순회하며 비어있지 않은 각 버킷에 대해 깊은 복사를 수행합니다. 이때 Entry의 deepCopy 메서드는 자신이 가리키는 연결 리스트 전체를 복사하기 위해 자신을 재귀적으로 호출합니다.이 기법은 간단하며, 버킷이 너무 길지 않다면 잘 작동합니다. 하지만 재귀 호출 때문에 리스트의 원소 수만큼 스택 프레임을 소비하여, 리스트가 길면 스택 오버플로를 일으킬 위험이 있기 때문에 연결 리스트를 복제하는 방법으로는 그다지 좋지 않습니다.3.3.2 반복public Entry deepCopy() { Entry result = new Entry(key, value, next); for (Entry p = result; p.next != null; p = p.next) { p.next = new Entry(p.next.key, p.next.value, p.next.next); } return result;}deepCopy가 재귀 호출 대신 반복자를 사용해 순회하면 스택 오버플로 문제를 해결할 수 있습니다.3.3.3 고수준 메서드super.clone을 호출하여 얻은 객체의 모든 필드를 초기 상태로 설정한 다음, 원본 객체의 상태를 다시 생성하는 고수준 메서드들을 호출합니다. 즉, buckets 필드를 새로운 버킷 배열로 초기화한 다음 원본 테이블에 담긴 모든 키-값 쌍 각각에 대해 복제본 테이블의 HashTable.put(key, value) 메서드를 호출해 둘의 내용이 같게 해주는 것입니다.고수준 API를 활용해 복제하면 간단하게 작성할 수 있지만, 아무대로 저수준에서 바로 처리할 때보다는 느립니다. 또한 Cloneable 아키텍처의 기초가 되는 필드 단위 복사를 우회하기 때문에 전체 Cloneable 아키텍처와는 어울리지 않는 방식이기도 합니다.4. 주의할 점1) clone에서는 재정의될 수 있는 메서드를 호출하지 않아야 한다.만약 clone이 하위 클래스에서 재정의한 메서드를 호출하면, 하위 클래스는 복제 과정에서 자신의 상태를 교정할 기회를 잃게 되어 원본과 복제본의 상태가 달라질 가능성이 큽니다.2) public인 clone 메서드에서는 throws 절을 없애야 한다.Object의 clone 메서드는 CloneNotSupportedException을 던진다고 선언했지만 재정의한 메서드는 그렇지 않습니다. 검사 예외를 던지지 않아야 그 메서드를 사용하기 편하기 때문입니다.3) 상속용 클래스는 Cloneable을 구현해서는 안 된다.Object의 방식을 모방하여, 제대로 작동하는 clone 메서드를 구현해 protected로 두고 CloneNotSupportedException도 던질 수 있다고 선언하는 것입니다. 다른 방법으로는 clone을 동작하지 않게 구현해놓고 하위 클래스에서 재정의하지 못하게 할 수도 있습니다.4) Cloneable을 구현한 thread-safe한 클래스를 작성할 때는 clone 메서드 역시 적절히 동기화해줘야 한다.Object의 clone 메서드는 동기화를 고려하지 않았습니다. 그러니 super.clone 호출 외에 다른 할 일이 없더라도 clone을 재정의하고 동기화해줘야 합니다.5. 더 나은 객체 복사 방식Cloneable을 이미 구현한 클래스를 확장한다면 어쩔 수 없이 clone을 잘 작동하도록 구현해야 합니다. 그렇지 않은 상황에서는 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있습니다. 여기서 복사 생성자와 복사 팩터리란 단순히 자신과 같은 클래스의 인스턴스를 인수로 받는 것을 말합니다.// 복사 생성자public Yum(Yum yum) { ... };// 복사 팩터리public static Yum newInstance(Yum yum) { ... };모순적이고 위험한 객체 생성 메커니즘(생성자를 쓰지 않는 방식)을 사용하지 않으며, 엉성하게 문서화된 규약에 기대지 않고, 정상적인 final 필드 용법과도 충돌하지 않으며, 불필요한 검사 예외를 던지지도 않고, 형변환도 필요하지 않습니다.추가로 해당 클래스가 구현한 인터페이스 타입의 인스턴스를 인수로 받을 수 있습니다. 인터페이스 기반 복사 생성자와 복사 팩터리의 더 정확한 이름은 ‘변환 생성자(conversion constructor)’와 ‘변환 팩터리(conversion factory)’입니다. 이들을 이용하면 클라이언트는 원본의 구현 타입에 얽매이지 않고 복제본의 타입을 직접 선택할 수 있습니다.다음은 HashSet 객체를 TreeSet 타입으로 복제한 클라이언트 코드입니다.Set&amp;lt;String&amp;gt; hashSet = new HashSet&amp;lt;&amp;gt;();hashSet.add(&quot;heung&quot;);hashSet.add(&quot;bae&quot;);hashSet.add(&quot;hoon&quot;);hashSet.add(&quot;na&quot;);System.out.println(&quot;HashSet: &quot; + hashSet);Set&amp;lt;String&amp;gt; treeSet = new TreeSet&amp;lt;&amp;gt;(hashSet); // 복제(변환)System.out.println(&quot;TreeSet: &quot; + treeSet);/* 실행 결과HashSet: [na, hoon, bae, heung]TreeSet: [bae, heung, hoon, na]*/6. 핵심 정리 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안 된다. 새로운 클래스도 Cloneable을 구현해서는 안 된다. final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 그물게 허용해야 한다. 기본 원칙은 ‘복제 기능은 생성자와 팩터리를 이용하는 것이 최고’라는 것이다. 예외적으로 배열은 clone 메서드 방식이 가장 깔끔한 복제 방법이다.7. Related Posts 믹스인 인터페이스 (Item 20) 리플렉션 (Item 65) Checked Exception (Item 71) 상속을 고려한 설계 (Item 19) 동기화 (Item 78)" }, { "title": "Item 12. toString을 항상 재정의하라", "url": "/posts/item-12-tostring%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Override, toString", "date": "2022-05-21 11:52:00 +0900", "snippet": "Effective Java의 열두 번째 아이템 “toString을 항상 재정의하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없습니다. 이 메서드는 PhoneNumber@6aaa5eb0 처럼 단순히 클래스_이름@16진수_해시코드를 반환합니다. 때문에 재정의가 필요한 것인데요. 본문에서 toString의 일반 규약과 작성 요령을 알아보겠습니다.1. 일반 규약 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야 한다. 모든 하위 클래스에서 재정의하라.toString을 잘 구현한 클래스는 사용하기에 훨씬 편하고, 그 클래스를 사용한 시스템은 디버깅하기 쉽습니다.toString 메서드는 우리가 직접 호출하지 않아도 어딘가에서 쓰일 수 있습니다. 예를 들어 작성한 객체를 참조하는 컴포넌트가 오류 메시지를 로깅할 때 자동으로 호출할 수 있습니다. 이때 toString을 제대로 재정의 하지 않았다면 쓸모없는 메시지만 로그에 남을 것입니다. 이외에도 객체를 println, printf, 문자열 연결 연산자(+), assert 구문에 넘길 때 혹은 디버거가 객체를 출력할 때 자동으로 호출됩니다.2. 예제PhoneNumber용 toString을 재정의합니다.public class PhoneNumber { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = (short) areaCode; this.prefix = (short) prefix; this.lineNum = (short) lineNum; } ... @Override public String toString() { return String.format(&quot;%03d-%03d-%04d&quot;, areaCode, prefix, lineNum); }}이제 print만으로도 객체의 상태를 확인할 수 있습니다.PhoneNumber phoneNumber = new PhoneNumber(123, 456, 7890);System.out.println(phoneNumber); // 123-456-7890객체에 어떤 문제가 생겼을 경우 위처럼 간단하게 문제를 진단할 수 있습니다. toString을 재정의하지 않았다면 그다지 쓸모없는 메시지가 출력될 것입니다.3. 작성 요령1) toString은 그 객체가 가진 주요 정보 모두를 반환하는 것이 좋다.PhoneNumber 클래스처럼 전화번호를 나타내는 주요 정보인 prefix, middle, suffix를 반환하는 것입니다. 그런데 객체가 거대하거나 객체의 상태가 문자열로 표현하기에 적합하지 않다면 무리가 있습니다. 이런 상황이라면 맨해튼 거주자 전화번호부(총 1487536)나 Thread[main,5,main]같은 요약 정보를 담아야 합니다. 이상적으로는 스스로를 완벽히 설명하는 문자열이어야 합니다.2) toString을 구현할 때는 반환값의 포맷을 문서화할지 정해야 합니다.전화번호나 행렬 같은 값 클래스라면 문서화하기를 권합니다. 포맷을 명시하면 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 됩니다. 따라서 그 값 그대로 입출력에 사용하거나 CSV 파일처럼 사람이 읽을 수 있는 데이터 객체로 저장할 수도 있습니다. 포맷을 명시하기로 했다면, 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩터리나 생성자를 함께 제공해 주면 좋습니다.문서화에는 단점도 있습니다. 포맷을 한번 명시하면 평생 그 포맷에 얽매이게 된다는 것입니다. 클래스를 사용하는 프로그래머들이 그 포맷에 맞춰 파싱하고, 새로운 객체를 만들고, 영속 데이터로 저장하는 코드를 작성할 것입니다. 만약 향후 릴리스에서 포맷을 바꾼다면 이를 사용하던 코드들과 데이터들은 엉망이 될 것입니다.3) 포맷을 명시하든 아니든 작성자의 의도는 명확히 밝혀야 한다.주석을 활용하여 toString에 대한 의도를 명시해 줘야 한다는 뜻입니다. 포맷을 명시하기로 했다면 아주 정확하게 작성해야 합니다. 다시 PhoneNumber의 toString을 보겠습니다./*** 이 전화번호의 문자열 표현을 반환한다.* 이 문자열은 &quot;XXX-YYY-ZZZZ&quot; 형태의 12글자로 구성된다.* XXX는 지역 코드, YYY는 프리픽스, ZZZZ는 가입자 번호다.* 각각의 대문자는 10진수 숫자 하나를 나타낸다.** 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,* 앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면* 전화번호의 마지막 네 문자는 &quot;0123&quot;이 된다.*/@Overridepublic String toString() { return String.format(&quot;%03d-%03d-%04d&quot;, areaCode, prefix, lineNum);}다른 예로, 포맷을 명시하지 않기로 했다면 다음처럼 작성할 수 있습니다./*** 이 약물에 관한 대략적인 설명을 반환한다.* 다음은 이 설명의 일반적인 형태이나,* 상세 형식은 정해지지 않았으며 향후 변경될 수 있다.** &quot;[약물 #9: 유형=사랑, 냄새=테레빈유, 겉모습=먹물]&quot;*/@Overridepublic String toString() { ... }이러한 설명을 읽고도 이 포맷에 맞춰 코딩하거나 특정 값을 빼내어 영구 저장한 프로그래머는 나중에 포맷이 바뀌어 피해를 입어도 자기 자신을 탓할 수밖에 없을 것입니다.4) 포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.예를 들어 PhoneNumber 클래스는 지역 코드, 프리픽스, 가입자 번호용 접근자를 제공해야 합니다. 그렇지 않으려면 이 정보가 필요한 프로그래머는 toString의 반환값을 파싱할 수밖에 없습니다. 성능이 나빠질 뿐만 아니라 향후 포맷이 바뀌었을 때 시스템이 망가는 결과를 초래할 수 있습니다.4. 핵심 정리 모든 구체 클래스에서 Object의 toString을 재정의하자. toString을 재정의한 클래스는 시스템을 디버깅하기 쉽게 해준다. toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.5. Related Posts 정적 유틸리티 클래스 (Item 4) 열거 타입 (Item 34)" }, { "title": "Item 11. equals를 재정의하려거든 hashCode도 재정의하라", "url": "/posts/item-11-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%A0%A4%EA%B1%B0%EB%93%A0-hashcode%EB%8F%84-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Override, hashCode", "date": "2022-05-20 17:00:00 +0900", "snippet": "Effective Java의 열한 번째 아이템 “equals를 재정의하려거든 hashCode도 재정의하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며equals를 재정의한 클래스가 hashCode를 재정의하지 않으면 일반 규약을 어기게 되어, 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것입니다. 때문에 반드시 equals를 재정의한 클래스는 hashCode도 재정의해야 합니다. 본문에서 hashCode의 일반 규약과 작성 요령, 주의할 점을 알아보겠습니다.1. 일반 규약다음은 Object 명세서에서 발췌한 규약입니다. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다. equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다. equals(Object)가 두 객체를 다르다고 판단했다면, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.hashCode 재정의를 잘못했을 때 크게 문제가 되는 것은 두 번째 조항입니다. 논리적으로 같은 객체는 같은 해시코드를 반환해야 하는 것인데요. 이전 포스팅에서 다루었듯이 equals는 물리적으로 다른 두 객체를 논리적으로는 같다고 할 수 있습니다. 하지만 Object의 기본 hashCode 메서드는 이 둘이 전혀 다르다고 판단하여, 규약과 달리 서로 다른 값을 반환합니다.다음은 equals를 재정의한 PhoneNumber 클래스입니다.public class PhoneNumber { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = (short) areaCode; this.prefix = (short) prefix; this.lineNum = (short) lineNum; } @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof PhoneNumber)) return false; PhoneNumber pn = (PhoneNumber)o; return pn.areaCode == areaCode &amp;amp;&amp;amp; pn.prefix == prefix &amp;amp;&amp;amp; pn.lineNum == lineNum; }}PhoneNumber 클래스를 사용하는 클라이언트 코드입니다.Map&amp;lt;PhoneNumber, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();PhoneNumber p1 = new PhoneNumber(123, 456, 7890);map.put(p1, &quot;heung&quot;);PhoneNumber p2 = new PhoneNumber(123, 456, 7890);System.out.println(p1.equals(p2));System.out.println(map.get(p1));System.out.println(map.get(p2));/* 실행 결과trueheungnull*/p1이라는 PhoneNumber 객체 key로 하여 HashMap에 heung를 넣었습니다. 동일한 번호를 가지는 새로운 인스턴스 p2를 만들고 이전의 p1과 equals 메서드를 사용해 비교했습니다. PhoneNumber 클래스에서 equals를 재정의했기 때문에 true가 반환됩니다. 하지만 HashMap에서 p2에 해당하는 값을 꺼냈을 때는 null이 반환되는 것을 확인할 수 있습니다. 이유는 Object의 기본 hashCode 메서드가 이 둘이 전혀 다르다고 판단하여 서로 다른 값을 반환하기 때문입니다.이 문제는 PhoneNumber에 적절한 hashCode 메서드만 작성해 주면 해결됩니다. 올바른 hashCode 메서드는 어떤 모습이어야 할까요? 올바르지 않게 작성하려면 아주 간단합니다. 예를 들어 다음 코드는 적법하게 구현했지만, 절대 사용해서는 안 됩니다.@Overridepublic int hashCode() { return 42;}이 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하니 적법합니다. 하지만 모든 객체에서 똑같은 값을 반환하기 때문에 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결리스트처럼 동작하게 됩니다. 그 결과 시간 복잡도가 O(1)인 해시테이블이 O(n)으로 느려져서 객체가 많아지면 도저히 쓸 수 없게 됩니다. 올바른 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환합니다. 이것이 바로 hashCode의 세 번째 규약이 요구하는 속성입니다.2. 작성 요령이상적인 해시 함수는 주어진 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 합니다. 이상을 완벽히 실현하기는 어렵지만 비슷하게 만들기는 그다지 어렵지 않습니다. 다음은 올바른 hashCode를 작성하는 간단한 요령입니다. int 변수 result를 선언한 후 값 c로 초기화한다. 이때 c는 해당 객체의 첫 번째 핵심 필드를 단계 2-1 방식으로 계산한 해시코드다. 여기서 핵심 필드란 equals 비교에 사용되는 필드를 말한다. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다. 해당 필드의 해시코드 c를 계산한다. 기본 타입 필드라면, Type.hashCode(f)를 수행한다. 여기서 Type은 해당 기본 타입의 박싱 클래스다. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 표준형을 만들어 그 표준형의 hashCode를 호출한다. 필드의 값이 null이면 0을 사용한다. 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 2-2 방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면 단순히 상수를 사용한다. 모든 원소가 핵심 원소라면 Arrays.hashCode를 사용한다. 계산한 해시코드 c로 result를 갱신한다. (result = 31 * result + c;) result를 반환한다.파생 필드는 해시 코드 계산에서 제외해도 됩니다. 즉, 다른 필드로부터 계산해 낼 수 있는 필드는 모두 무시해도 됩니다. 또한 equals 비교에 사용되지 않은 필드는 ‘반드시’ 제외해야 합니다. 그렇지 않으면 hashCode 규약 두 번째를 어기게 될 위험이 있습니다.단계 2-2의 곱셈 31 * result는 필드를 곱하는 순서에 따라 result 값이 달라지게 합니다. 그 결과 클래스에 비슷한 필드가 여러 개 일 때 해시 효과를 크게 높여줍니다. 곱할 숫자를 31로 정한 이유는 31이 홀수이면서 소수여서 최적화에 효과적이기 때문입니다.3. 예제위의 요령을 적용해 PhoneNumber 클래스를 개선했습니다.public class PhoneNumber { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = (short) areaCode; this.prefix = (short) prefix; this.lineNum = (short) lineNum; } @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof PhoneNumber)) return false; PhoneNumber pn = (PhoneNumber)o; return pn.areaCode == areaCode &amp;amp;&amp;amp; pn.prefix == prefix &amp;amp;&amp;amp; pn.lineNum == lineNum; } @Override public int hashCode() { int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result; }}PhoneNumber 인스턴스의 핵심 필드 3개만을 사용해 해시코드를 계산합니다. 그 과정에 비결정적 요소는 전혀 없으므로 동치인 PhoneNumber 인스턴스들은 같은 해시코드를 가질 것이 확실합니다.Map&amp;lt;PhoneNumber, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();PhoneNumber p1 = new PhoneNumber(123, 456, 7890);map.put(p1, &quot;heung&quot;);PhoneNumber p2 = new PhoneNumber(123, 456, 7890);System.out.println(map.get(p2)); // heung위에서 봤던 테스트 코드를 다시 실행시켜 보겠습니다. 이전에는 null이 출력됐었는데요. 이제는 heung가 출력되는 것을 확인할 수 있습니다.소개한 해시 함수 작성 요령은 자바 라이브러리가 사용한 방식과 견주어도 손색이 없으며 대부분의 쓰임에도 문제가 없습니다. 단, 해시 충돌이 더욱 적은 방법을 꼭 써야 한다면 구아바의 com.google.common.hash.Hashing을 참고하는 것이 좋습니다.@Overridepublic int hashCode() { return Hashing.goodFastHash(32) .hashObject(this, PhoneNumberFunnel.INSTANCE) .hashCode();}private static class PhoneNumberFunnel implements Funnel&amp;lt;PhoneNumber&amp;gt; { private static final PhoneNumberFunnel INSTANCE = new PhoneNumberFunnel(); @Override public void funnel(PhoneNumber from, PrimitiveSink into) { into.putShort(from.areaCode).putShort(from.prefix).putShort(from.lineNum); }}4. 주의할 점hashCode를 재정의할 때는 몇 가지 주의해야 할 사항이 있습니다.Object 클래스가 제공하는 hash 메서드는 성능이 민감하지 않은 상황에서만 사용해야 합니다.Object 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해 주는 정적 메서드인 hash를 제공합니다. 이 메서드를 활용하면 앞서의 요령대로 구현한 코드와 비슷한 수준의 hashCode 함수를 단 한 줄로 작성할 수 있습니다. 하지만 입력 인수를 담기 위한 배열이 만들어지고, 입력 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문에 속도가 느립니다.클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기 보다는 캐싱하는 방식을 고려해야 합니다.이 타입의 객체가 주로 해시의 key로 사용될 것 같다면 인스턴스가 만들어질 때 해시 코드를 계산해둬야 합니다. 해시의 key로 사용되지 않는 경우라면 hashCode가 처음 호출될 때 계산하는 지연 초기화 전략을 고려해야 합니다. 필드를 지연 초기화하려면 그 클래스를 thread-safe하게 만들어야 합니다. PhoneNumber 클래스는 굳이 이렇게까지 할 이유는 없지만, 예시를 위해 만들었습니다.private volatile int hashCode;@Override public int hashCode() { if (this.hashCode != 0) { return hashCode; } synchronized (this) { int result = hashCode; if (result == 0) { result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); this.hashCode = result; } return result; }}성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 됩니다.속도는 빨라지겠지만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있습니다. 특히 어떤 필드는 특정 영역에 몰린 인스턴스들의 해시코드를 넓은 범위로 고르게 퍼트려주는 효과가 있을지도 모릅니다. 하필 이런 필드를 생략한다면 해당 영역의 수많은 인스턴스가 단 몇 개의 해시코드로 집중되어 해시테이블의 속도가 선형으로 느려질 것입니다.hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말아야 합니다.자세한 생성 규칙을 공표하면 클라이언트는 이 값에 의지하게 됩니다. 이는 향후 해시 기능을 개선할 여지를 없애버리는 일입니다. 자세한 규칙을 공표하지 않는다면, 해시 기능에서 결함을 발견했거나 더 나은 해시 방식을 알아낸 경우 다음 릴리스에서 수정할 수 있습니다.5. 핵심 정리 equals를 재정의 할 때는 hashCode도 반드시 재정의해야 한다. 재정의한 hashCode는 Object의 API 문서에 기술된 일반 규약을 따라야 한다. 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. Lombok 라이브러리 또는 AutoValue 프레임워크를 사용하면 euqals와 hashCode를 자동으로 만들어준다.6. Related Posts equals (Item 10) 지연 초기화 (Item 83)" }, { "title": "Item 10. equals는 일반 규약을 지켜 재정의하라", "url": "/posts/item-10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Override, equals", "date": "2022-05-13 23:43:00 +0900", "snippet": "Effective Java의 열 번째 아이템 “equals는 일반 규약을 지켜 재정의하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며equals 메서드는 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어서 자칫하면 끔찍한 결과를 초래합니다. 본문에서 equals 메서드의 재정의가 어떠한 상황에서 필요한지 그리고 올바른 구현 방법과 주의사항을 알아보겠습니다.1. 재정의가 불필요한 경우equals로 인해 발생하는 문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것입니다. 그냥 두면 그 클래스의 인스턴스는 오직 자기 자신과만 같게 됩니다.다음은 equals 메서드의 재정의가 필요하지 않는 경우입니다. 각 인스턴스가 본질적으로 고유하다. 값을 표현하는 것이 아니라 동작하는 개체를 표현하는 클래스가 여기 해당합니다. 예를 들어 Thread 클래스가 있습니다. 인스턴스의 ‘논리적 동치성(logical equality)’을 검사할 일이 없다. 논리적 동치성이란 두 인스턴스가 논리적으로 같음을 의미합니다. 예를 들어 java.util.regex.Parrern의 두 인스턴스가 같은 정규표현식을 나타내는 경우가 있습니다. 이러한 논리적 동치성을 검사할 일이 없다면 equals 재정의는 필요하지 않습니다. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다. 예를 들어 대부분의 Set 구현체는 AbstractSet이 구현한 equals를 상속받아쓰고, List 구현체들은 AbstractList로부터, Map 구현체들은 AbstractMap으로부터 상속받아 그대로 씁니다. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다. 이 경우에는 당연히 재정의가 필요하지 않습니다. 위에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 ‘최선’입니다.2. 재정의가 필요한 경우equals 메서드의 재정의가 필요한 경우는 두 객체가 물리적으로 같은지가 아니라 논리적으로 같은지, 즉 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때입니다.주로 Integer와 String처럼 값을 표현하는 클래스들을 equals로 비교하는 프로그래머는 객체가 같은지 보다는 값이 같은지를 알고 싶어 할 것입니다. equals가 논리적 동치성을 확인하도록 정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함을 물론 Map의 키와 Set의 원소로 사용할 수 있게 됩니다.3. 규약equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 합니다. 다음은 Object 명세에 적힌 규약입니다. 반사성 null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다. 단순히 말하면 객체는 자기 자신과 같이야 한다는 뜻입니다. 대칭성 null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true다. 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다는 뜻입니다. 추이성 null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true다. 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다는 뜻입니다. 일관성 null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다. 두 객체가 같다면 어느 하나 혹은 두 객체 모두가 수정되지 않는 한 앞으로도 영원히 같아야 한다는 뜻입니다. 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 됩니다. not-null null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다. 모든 객체가 null과 같지 않아야 한다는 뜻입니다. 이 규약을 어기면 프로그램이 이상하게 동작하거나 종료될 것이고, 원인이 되는 코드를 찾기도 굉장히 어려울 것입니다. 컬력션 클래스들을 포함해 수많은 클래스는 전달받은 객체가 equals 규약을 지킨다고 가정하고 동작합니다.사실 반사성과 not-null은 일반적으로 만족하게 될 것입니다. 하지만 대칭성, 추이성, 일관성은 자칫하면 어길 수 있기 때문에 주의가 필요합니다.4. 올바른 구현 방법 == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다. 자기 자신이면 true를 반환합니다. 이는 단순한 성능 최적화용으로, 비교 작업이 복잡한 상황일 때 값어치를 할 것입니다. instanceof 연산자로 입력이 올바른 타입인지 확인한다. 그렇지 않다면 false를 반환합니다. 이때의 올바른 타입은 equals가 정의된 클래스인 것이 보통이지만, 가끔은 그 클래스가 구현한 특정 인터페이스가 될 수도 있습니다. 어떤 인터페이스는 자신을 구현한 클래스끼리도 비교할 수 있도록 equals 규약을 수정하기도 합니다. 이런 인터페이스를 구현한 클래스라면 equals에서 해당 인터페이스를 사용해야 합니다. Set, List, Map, Map.Entry 등의 컬렉션 인터페이스들이 여기 해당합니다. 입력을 올바른 타입으로 형변환한다. 앞서 2번에서 instanceof 검사를 했으면 이 단계는 무조건 성공합니다. 입력 객체와 자기 자신의 대응되는 ‘핵심’ 필드들이 모두 일치하는지 하나씩 검사한다. 모든 필드가 일치하면 true를, 하나라도 다르면 false를 반환합니다. 2단계에서 인터페이스를 사용했다면 입력의 필드 값을 가져올 때도 그 인터페이스 메서드를 사용해야 합니다. 타입이 클래스라면 해당 필드에 직접 접근할 수도 있습니다. 다음은 위의 구현 방법을 따라 작성한 PhoneNumber 클래스용 equals 메서드입니다.public final class PhoneNumber { private final short areaCode, prefix, lineNum; public PhoneNumber(int areaCode, int prefix, int lineNum) { this.areaCode = rangeCheck(areaCode, 999, &quot;지역코드&quot;); this.prefix = rangeCheck(prefix, 999, &quot;프리픽스&quot;); this.lineNum = rangeCheck(lineNum, 9999, &quot;가입자 번호&quot;); } private static short rangeCheck(int val, int max, String arg) { if (val &amp;lt; 0 || val &amp;gt; max) throw new IllegalArgumentException(arg + &quot;: &quot; + val); return (short) val; } @Override public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof PhoneNumber)) return false; PhoneNumber pn = (PhoneNumber)o; return pn.lineNum == lineNum &amp;amp;&amp;amp; pn.prefix == prefix &amp;amp;&amp;amp; pn.areaCode == areaCode; } ...}5. 주의사항 equals를 재정의할 땐 hashCode도 반드시 재정의하자. 너무 복잡하게 해결하려 들지 말자. 필드들의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있습니다. 오히려 너무 공격적으로 파고들다가 문제를 일으키기도 합니다. 일반적으로 별칭(alias)은 비교하지 않는 것이 좋습니다. 예를 들어 File 클래스라면, 심볼릭 링크를 비교해 같은 파일을 가리키는지를 확인하려 들면 안 됩니다. Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자. public boolean equals(MyClass o) { ... }와 같은 메서드는 Object.equals를 재정의 한 것이 아닙니다. 입력 타입이 Object가 아니므로 재정의가 아니라 다중정의한 것 입니다. 기본 equals를 그대로 둔 채로 추가한 것일지라도, 이처럼 타입을 구체적으로 명시한 equals는 오히려 해가 됩니다. 이 메서드는 하위 클래스에서 @Override이 긍정 오류를 내게 하고 보안 측면에서도 잘못된 정보를 줍니다. 6. 테스트equals를 작성하고 테스트하는 일은 지루하고 이를 테스트하는 코드도 항상 뻔합니다. 이러한 작업을 대신해 줄 오픈소스가 있으니, 바로 구글이 만든 AutoValue 프레임워크입니다. 클래스에 어노테이션 하나만 추가하면 AutoValue가 이 메서드들을 알아서 작성해 주며, 직접 작성하는 것과 근본적으로 똑같은 코드를 만들어 줄 것입니다.7. 핵심 정리꼭 필요한 경우가 아니면 equals를 재정의하지 말자. 많은 경우에 Object의 equals가 여러분이 원하는 비교를 정확히 수행해 준다. 재정의해야 할 때는 그 클래스의 핵심 필드 모두를 빠짐없이, 다섯 가지 규약을 확실히 지켜가며 비교해야 한다.8. Related Posts 인스턴스 통제 클래스 (Item 1) 불변 클래스 (Item 17) hashCode (Item 11) 다중정의 (Item 52) @Override (Item 40)" }, { "title": "Item 9. try-finally보다는 try-with-resources를 사용하라", "url": "/posts/item-9-try-finally-%EB%B3%B4%EB%8B%A4%EB%8A%94-try-with-resources%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, try-finally, try-with-resources", "date": "2022-05-11 21:45:00 +0900", "snippet": "Effective Java의 아홉 번째 아이템 “try-finally보다는 try-with-resources를 사용하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며Java 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 있습니다. 예를 들어 InputStream, OutputStream, java.sql.Connection 등이 있죠. 자원 닫기는 클라이언트가 놓치기 쉬워서 예측할 수 없는 성능 문제로 이어지기도 합니다.이런 자원 중 상당수가 안정망으로 finalizer를 활용하고 있습니다. 하지만 이전 포스팅에서 알아봤듯이 finalizer는 그리 믿을만하지 못합니다. 본문에서 자원이 제대로 닫힘을 보장하는 전통적인 방법 try-finally와 보다 개선된 방법인 try-with-resources에 대해 알아보겠습니다.1. try-finally다음은 입력받은 경로의 파일을 읽어들이는 메서드입니다.static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); }}위 예제는 try-finally를 사용해 BufferedReader 자원의 닫힘을 보장합니다. 깔끔하고 괜찮아 보이는데, 만약 닫아야 하는 자원이 둘 이상일 때는 어떻게 해야 할까요?다음은 파일을 읽어 복사하는 메서드입니다.static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &amp;gt;= 0) { out.write(buf, 0, n); } } finally { out.close(); } } finally { in.close(); }}닫아햐 하는 자원이 InputStream, OutputStream 두 개가 되었습니다. 이때는 try-finally를 중첩으로 사용해야 합니다. 보이는 것과 같이 코드가 많이 지저분해집니다. 자원이 많아질수록 걷잡을 수 없겠죠.그런데 왜 중첩으로 사용해야 하는지 의문이 들 수 있습니다. 하나의 try-finally로는 안될까요? 아래처럼 말이죠.static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &amp;gt;= 0) { out.write(buf, 0, n); } } finally { in.close(); out.close(); }}얼핏 보면 문제없어 보입니다. 하지만 finally 블록에서도 예외가 발생할 수 있다는 것을 잊지 말아야 합니다. in.close()에서 예외가 발생하면 out.close()는 실행되지 않습니다. 자원이 닫히지 않는 것이죠. 물론 위의 예제에서는 OutputStream이 안전망으로 finalizer를 사용하기 때문에 finalize 메서드가 호출되어 자원이 닫힐 것입니다. 하지만 finalizer보다는 직접 닫아주는 게 좋겠죠.try-finally는 복잡해지는 코드 외에 한 가지 더 문제를 가지고 있습니다. 예외가 try 블록과 finally 블록 모두에서 발생할 수 있다는 것입니다. 예를 들어 try 블록에서 어떤 예외가 발생했고 연쇄적으로 finally 블록에도 예외가 발생했다고 가정하면, try 블록에서 발생한 첫 번째 예외가 finally에서 발생한 두 번째 예외에 가려지게 됩니다. 그러면 스택 추적 내역에 첫 번째 예외에 관한 정보는 남지 않게 되어 실제 시스템에서의 디버깅이 어려워집니다.이러한 문제들은 Java 7부터 추가된 try-with-resources를 사용하면 해결할 수 있습니다.2. try-with-resources먼저 이 구조를 사용하기 위해서는 해당 자원이 AutoCloseable 인터페이스를 구현해야 합니다.public interface AutoCloseable { void close() throws Exception;}Java 라이브러리와 서드파티 라이브러리들의 수많은 클래스와 인터페이스은 이미 AutoCloseable을 구현하거나 확장해뒀습니다. 예제에서 사용된 InputStream와 OutputStream 역시 AutoCloseable을 구현하고 있습니다.이제 사용법을 알아봐야겠죠. 위에서 보았던 메서드들을 try-with-resources 방식으로 수정해 보겠습니다.static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); }}static void copy(String src, String dst) throws IOException { try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) { byte[] buf = new byte[BUFFER_SIZE]; int n; while ((n = in.read(buf)) &amp;gt;= 0) { out.write(buf, 0, n); } }}try-with-resources는 코드에서는 보이지 않지만 내부적으로 close 메서드를 호출합니다. try-finally에 비해 훨씬 짧아져 읽기 편합니다. 그리고 문제를 진단하기도 좋습니다. try 블록과 close 호출 양쪽에서 예외가 발생하면, close에서 발생한 예외는 숨겨지고 try 블록에서 발생한 예외가 기록됩니다. 숨겨진 예외들도 그냥 버려지지는 않고, 스택 추적 내역에 ‘숨겨졌다(suppressed)’는 꼬리표를 달고 출력됩니다. 또한, Java 7에서 Throwable에 추가된 getSuppressed 메서드를 이용하면 프로그램 코드로 가져올 수도 있습니다.3. 핵심 정리꼭 회수해야 하는 자원을 다룰 때는 try-finally 말고, try-with-resources를 사용하자. 예외는 없다. 코드는 더 짧고 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다. try-finally로 작성하면 실용적이지 못할 만큼 코드가 지저분해지는 경우라도, try-with-resources로는 정확하고 쉽게 자원을 회수할 수 있다.4. Related Posts finalizer (Item 8)" }, { "title": "Item 8. finalizer와 cleaner 사용을 피하라", "url": "/posts/item-8-finalizer%EC%99%80-cleaner-%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Finalizer, Cleaner", "date": "2022-04-30 14:37:00 +0900", "snippet": "Effective Java의 여덟 번째 아이템 “finalizer와 cleaner 사용을 피하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며Java는 finalizer와 cleaner라는 두 가지 객체 소멸자를 제공합니다. 본문에서 finalizer와 cleaner가 무엇이고 어떤 문제점을 가지고 있는지, 그리고 어떤 쓰임새가 있는지 자세히 알아보겠습니다.1. finalizer와 cleaner란?finalizerfinalize 메서드는 Object 클래스에서 제공하는 기본 메서드입니다. 어떤 클래스든지 오버라이드 할 수 있고, 해당 클래스의 객체가 GC의 대상이 될 때 호출됩니다. 객체가 없어지기 전 다른 연관 자원을 정리하는 용도로 사용합니다.public class Room { ... @Override protected void finalize() throws Throwable { System.out.println(&quot;run finalizer&quot;); }}Room 클래스는 finalize 메서드를 오버라이드 했습니다. 아래는 실제로 finalize 메서드가 호출되는지 확인하기 위해 작성한 클라이언트 코드입니다.new Room();System.gc();/* 실행 결과run finalizer*/Room 클래스의 객체를 만들고 GC를 동작시켰습니다(System.gc()가 실제로 GC의 동작을 보장하지는 않습니다). 예상했던 것처럼 finalize 메서드가 호출되는 것을 확인할 수 있습니다.그러나 finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요합니다. 나름의 쓰임새가 몇 가지 있긴 하지만 기본적으로 쓰지 말아야 합니다. 그래서 Java 9에서는 finalizer를 deprecated API로 지정하고 cleaner를 그 대안으로 소개했습니다.CleanerJava 9에서 도입된 소멸자로, 생성된 Cleaner가 더 이상 사용되지 않을 때 스레드에서 정의된 클린 작업을 수행합니다.public class Room { private static final Cleaner cleaner = Cleaner.create(); private static class State implements Runnable { int numJunkPiles; State(int numJunkPiles) { this.numJunkPiles = numJunkPiles; } @Override public void run() { System.out.println(&quot;run cleaner&quot;); numJunkPiles = 0; } } public Room(int numJunkPiles) { State state = new State(numJunkPiles); cleaner.register(this, state); }}State 클래스는 Runnable을 구현하여 run 메서드를 오버라이드 했고, numJunkPiles 필드는 Room 클래스의 객체가 회수될 때 반드시 수거해야 하는 자원입니다. Room의 객체가 생성될 때 State 객체가 Cleaner에 등록됩니다. 그리고 Room의 객체가 GC의 대상이 되어 메모리가 회수될 때 Cleaner에 등록된 State 객체의 run 메서드가 호출됩니다.new Room(99);System.gc();/* 실행 결과run cleaner*/Room 클래스의 객체를 만들고 GC를 동작시켰습니다(보장하지는 않습니다). 역시 예상했던 것처럼 run 메서드가 호출된 것을 확인할 수 있습니다.cleaner은 finalizer 보다 덜 위험하지만 여전히 예측할 수 없고, 느리고, 일반적으로 불필요합니다. 구체적으로 어떤 문제가 있길래 사용을 피하라는 걸까요? 아래에서 finalizer와 cleaner의 문제점을 하나하나 알아보겠습니다.2. finalizer와 cleaner의 문제점2.1 즉시 수행된다는 보장이 없다.finalizer와 cleaner는 즉시 수행된다는 보장이 없습니다. 객체에 접근할 수 없게 된 후 finalizer와 cleaner가 실행되기까지 얼마나 걸릴지 알 수 없습니다. 즉, finalizer와 cleaner로는 제때 실행되어야 하는 작업을 절대 할 수 없습니다.예를 들어 파일 닫기를 finalizer와 cleaner에 맡기면 중대한 오류를 일으킬 수 있습니다. 시스템이 동시에 열 수 있는 파일 개수에 한계가 있기 때문입니다. 시스템이 finalizer나 cleaner 실행을 게을리해서 파일을 계속 열어 둔다면 새로운 파일을 열지 못해 프로그램이 실패할 수 있습니다.finalizer와 cleaner가 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며, 이는 GC 구현마다 천차만별입니다. finalizer나 cleaner 수행 시점에 의존하는 프로그램의 동작 또한 마찬가지입니다.finalizer 스레드는 다른 애플리케이션 스레드보다 우선순위가 낮아서 실행될 기회를 제대로 얻지 못할 수 있습니다. 자바 언어 명세는 어떤 스레드가 finalizer를 수행할지 명시하지 않으니 이 문제를 예방할 보편적인 해법은 없습니다. 한편, cleaner는 자신을 수행할 스레드를 제어할 수 있다는 면에서 조금 낫습니다. 하지만 여전히 백그라운드에서 수행되며 가비지 컬렉터의 통제하에 있으니 즉각 수행되리라는 보장은 없습니다.2.2 수행 여부를 보장하지 않는다.자바 언어 명세는 finalizer나 cleaner의 수행 시점뿐 아니라 수행 여부조차 보장하지 않습니다. 접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수 있습니다. 따라서 프로그램 생애주기와 상관없는, 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 됩니다. 예를 들어 데이터베이스 같은 공유 자원의 영구 락(lock) 해제를 finalizder나 cleaner에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출 것입니다.2.3 finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료됩니다. 잡지 못한 예외 때문에 해당 객체는 자칫 마무리가 덜 된 상태로 남을 수 있습니다. 그리고 다른 스레드가 이처럼 훼손된 객체를 사용하려 한다면 어떻게 동작할지 예측할 수 없습니다. 보통의 경우엔 잡지 못한 예외가 스레드를 중단시키고 스택 추적 내역을 출력하겠지만, 같은 일이 finalizer에서 일어난다면 경고조차 출력하지 않습니다. 그나마 cleaner를 사용하는 라이브러리는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않습니다.2.3 성능 문제를 동반한다.finalizer와 cleaner는 심각한 성능 문제를 동반합니다. 책에서의 테스트 결과로는 간단한 AutoCloseable 객체를 생성하고 GC가 수거하기까지 12ns가 걸린 반면(try-with-resources 사용), finalizer를 사용하면 550ns가 걸렸습니다. 다시 말해 finalizer를 사용한 객체를 생성하고 파괴하니 50배나 느렸습니다. 이는 finalizer가 GC의 효율을 떨어뜨리기 때문입니다.cleaner도 클래스의 모든 인스턴스를 수거하는 형태로 사용하면 성능은 finalizer와 비슷합니다. 하지만 잠시 후에 살펴볼 안전망 형태로만 사용하면 훨씬 빨라집니다. 안전망 방식에서는 객체 하나를 생성, 정리, 파괴하는 데 약 66ns가 걸렸습니다. 안전망을 설치하는 대가로 약 5배 정도 느려진다는 뜻입니다.2.4 finalizer 공격에 노출되어 보안 문제를 일으킬 수 있다.생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 됩니다. 이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있습니다. 이렇게 일그러진 객체가 만들어지고 나면, 이 객체의 메서드를 호출해 애초에는 허용되지 않았을 작업을 수행하는 건 일도 아닙니다.객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지도 않습니다. 이러한 공격은 끔찍한 결과를 초래할 수 있습니다. final 클래스들은 그 누구도 하위 클래스를 만들 수 없으니 이 공격에서 안전합니다. final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언해야 합니다.(예제 추가)3. finalizer와 cleaner의 대안 - AutoCloseable파일이나 스레드 등 종료해야 할 자원을 담고 있는 객체의 클래스에서 finalizer나 cleaner를 대신해 줄 묘안은 무엇일까요? 그저AutoCloseable을 구현(implement)해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 됩니다(일반적으로 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용합니다).구체적인 구현법과 관련하여 알아두면 좋을 것이 하나 있습니다. 각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋습니다. 다시 말해, close 메서드에서 이 객체는 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 이 필드를 검사해서 객체가 닫힌 후에 불렸다면 IllegalStateException을 던지는 것입니다.3. finalizer와 cleaner의 쓰임새finalizer와 cleaner는 대체 어디에 쓰는 것일까요? 적절한 쓰임새가 두 가지 있습니다.3.1 안전망자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안전망 역할입니다. finalizer나 cleaner가 즉시 (혹은 끝까지) 호출되리라는 보장은 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 것이 아예 안 하는 것보다는 낫습니다.안전망 역할의 finalizer를 작성할 때는 위에서 언급한 문제점들을 고려하여 그럴만한 값어치가 있는지 심사숙고해야 합니다. 자바 라이브러리 일부 클래스는 안전망 역할의 finalizer를 제공합니다. 대표적으로 FileInputStream, FileOutputStream, ThreadPoolExecutor가 있습니다.3.2 네이티브 피어네이티브 피어(native peer)와 연결된 객체에서 역할입니다. 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말합니다. 네이티브 피어는 자바 객체가 아니니 가비지 컬렉터는 그 존재를 알지 못합니다. 그 결과 자바 피어를 회수할 때 네이티브 객체까지 회수하지 못합니다. finalizer나 cleaner가 나서서 처리하기에 적당한 작업입니다.단, 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당됩니다. 성능 저하를 감당할 수 없거나 네이티브 피어가 사용하는 자원을 즉시 회수해야 한다면 앞서 설명한 close 메서드를 사용해야 합니다.4. 사용 예제cleaner를 안전망으로 활용한 예제입니다. 본문의 처음에 보여드렸던 Room 클래스에 AutoCloseable 구현을 추가했습니다.public class Room implements AutoCloseable { private static final Cleaner cleaner = Cleaner.create(); private static class State implements Runnable { int numJunkPiles; State(int numJunkPiles) { this.numJunkPiles = numJunkPiles; } @Override public void run() { System.out.println(&quot;방 청소&quot;); numJunkPiles = 0; } } private final State state; private final Cleaner.Cleanable cleanable; public Room(int numJunkPiles) { state = new State(numJunkPiles); cleanable = cleaner.register(this, state); } @Override public void close() { cleanable.clean(); }}방(room) 자원을 수거하기 전에 반드시 청소(clean)해야 한다고 가정해 보겠습니다. static으로 선언된 중첩 클래스인 State는 cleaner가 방을 청소할 때 수거할 자원들을 담고 있습니다. 이 예에서는 단순히 방 안의 쓰레기 수를 뜻하는 numJunkPiles 필드가 수거할 자원에 해당합니다(더 현실적으로 만들려면 numJunkPiles는 네이티브 피어를 가리키는 포인터를 담은 final long 변수여야 합니다). State는 Runnable을 구현하고, 그 안의 run 메서드는 cleanable에 의해 딱 한 번만 호출될 것입니다. 이 cleanable 객체는 Room 생성자에서 cleaner에 Room과 State를 등록할 때 얻습니다.run 메서드가 호출되는 상황은 둘 중 하나입니다. 보통은 Room의 close 메서드를 호출할 때입니다. close 메서드에서 Cleanable의 clean을 호출하면 이 메서드 안에서 run을 호출합니다. 혹은 GC가 Room을 회수할 때까지 클라이언트가 close를 호출하지 않는다면, cleaner가 State의 run 메서드를 호출해줄 것입니다.State 인스턴스는 절대로 Room 인스턴스를 참조해서는 안 됩니다. Room 인스턴스를 참조할 경우 순환 참조가 생겨 GC가 Room 인스턴스를 회수해갈 (자동 청소될) 기회가 오지 않습니다. State가 정적 중첩 클래스인 이유가 여기에 있습니다. 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖게 되기 때문입니다. 이와 비슷하게 람다 역시 바깥 객체의 참조를 갖기 쉬우니 사용하지 않는 것이 좋습니다.앞서 이야기 한 대로 Room의 cleaner은 단지 안전망으로 쓰였습니다. 클라이언트가 모든 Room 생성을 try-with-resources 블록으로 감쌌다면 자동 청소는 전혀 필요하지 않습니다. 다음은 클라이언트 코드 예제입니다.try (Room myRoom = new Room(7)) { System.out.println(&quot;안녕&quot;);}/* 실행 결과안녕방 청소*/기대한 대로 “안녕”을 출력한 후, 이어서 close 메서드가 호출되고 “방 청소”를 출력합니다. 만약 try-with-resources를 사용하지 않았다면 어떻게 될까요?new Room(7);System.out.println(&quot;안녕&quot;);/* 실행 결과안녕*/“방 청소”는 출력되지 않습니다. 이것이 앞서 “예측할 수 없다”라고 말한 상황입니다. 그렇다면 이제 안전망이 동작하는지 확인해 봐야겠죠.new Room(7);System.out.println(&quot;안녕&quot;);System.gc();/* 실행 결과안녕방 청소*/명시적으로 GC를 동작시켰습니다. 객체의 메모리가 회수되면서 cleaner가 run 메서드를 실행시켜 “방 청소”가 출력되었습니다.5. 핵심 정리cleaner(Java 8까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.6. Related Posts try-with-resource (Item 9) 중첩 클래스 (Item 24)" }, { "title": "Item 7. 다 쓴 객체 참조를 해제하라", "url": "/posts/item-7-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Memory Leak, Stack, Cache, Listner, Callback", "date": "2022-04-27 00:04:00 +0900", "snippet": "Effective Java의 일곱 번째 아이템 “다 쓴 객체 참조를 해제하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며자바는 다 쓴 객체를 GC(Garbage Collector)가 알아서 회수해 갑니다. 그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 이는 절대 사실이 아닙니다. 가비지 컬렉션 언어에서는 의도치 않게 객체를 살려두는 ‘메모리 누수‘를 찾기가 아주 까다롭습니다. 객체 참조 하나를 살려두면 GC는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체)를 회수해가지 못합니다. 때문에 단 몇 개의 객체가 매우 많은 객체를 회수하지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있습니다.본문에서 다 쓴 참조(앞으로 다시 쓰지 않을 참조)가 해제되지 않아 메모리 누수가 발생하는 예와 해결 방법을 알아보겠습니다.1. 메모리 누수 예CG가 알아서 다 쓴 객체를 회수해가는데 왜 메모리 누수가 발생하는 걸까요? 원인은 프로그래머가 작성한 클래스에 있습니다. 어떤 클래스가 자기 메모리를 직접 관리한다면, GC는 해당 메모리가 더 이상 쓸 일이 없는 참조라는 것을 인식하지 못하게 될 수 있습니다. 따라서 여전히 다 쓴 참조가 해제되지 않고 메모리 누수가 발생하는 것입니다. 세 가지 예제를 통해 자세히 알아보겠습니다.1.1 스택스택은 아시다시피 후입선출 방식의 자료구조입니다. java.util 패키지에서 구현체를 제공해 주지만, 메모리 누수가 발생하는 상황을 만들기 위해 직접 구현했습니다.public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } /** * 원소를 위한 공간을 적어도 하나 이상 확보한다. * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다. */ private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); }}위 예제에서는 스택에 원소가 쌓였다가(push) 꺼내질 때(pop) 메모리 누수가 일어납니다. 더 이상 사용되지 않을 꺼내진 객체들을 GC는 회수하지 않습니다. 그 이유는 스택이 해당 객체들의 다 쓴 참조를 여전히 가지고 있기 때문입니다. 위의 예제에서는 elements 배열의 ‘활성 영역’ 밖의 참조들이 모두 여기에 해당합니다. 여기서 활성 영역은 size보다 작은 인덱스를 말합니다.이를 해결하기 위한 방법은 간단합니다. 해당 참조를 다 썼을 때 null 처리(참조 해제)해주면 됩니다. 다음은 pop 메서드를 개선한 코드입니다.public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // 다 쓴 참조 해제 return result;}예제의 Stack 클래스는 왜 null 처리가 필요한 걸까요? 이유는 elements 배열로 저장소 풀을 만들어 원소들을 관리(자기 메모리를 직접 관리)하기 때문입니다. 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않습니다. 문제는 GC가 이 사실을 알 길이 없다는 것입니다. GC의 관점에서는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체입니다. 비활성 영역의 객체가 더 이상 쓸모없다는 것은 프로그래머만 아는 사실입니다. 때문에 프로그래머는 비활성 영역이 되는 순간 null 처리해서 해당 객체는 더 이상 쓰지 않을 것임을 GC에 알려야 합니다.1.2 캐시캐시 역시 메모리 누수를 일으키는 주범입니다. 객체 참조를 캐시에 넣고 나서, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있습니다. 다음은 캐시를 사용한 예제입니다.public class CacheKey { private Integer value; private LocalDateTime created; public CacheKey(Integer value) { this.value = value; this.created = LocalDateTime.now(); } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; CacheKey cacheKey = (CacheKey) o; return value.equals(cacheKey.value); } @Override public int hashCode() { return Objects.hash(value); }}public class Post { private Long id; private String title; private String content;}CacheKey 클래스는 캐시의 key로 사용되고 Post 클래스는 캐싱된 value로 사용됩니다.public class PostRepository { private Map&amp;lt;CacheKey, Post&amp;gt; cache; public PostRepository() { this.cache = new HashMap&amp;lt;&amp;gt;(); } public Post getPostById(CacheKey key) { if (cache.containsKey(key)) { return cache.get(key); } else { // TODO DB에서 읽어오거나 REST API를 통해 Post 검색 Post post = new Post(); // 검색된 Post cache.put(key, post); return post; } } public Map&amp;lt;CacheKey, Post&amp;gt; getCache() { return cache; }}Repository는 실제 캐싱이 되는 부분입니다. getPostById 메서드는 캐시에서 해당 key가 이미 존재하는지 확인합니다. 존재하지 않으면 DB나 다른 API를 통해 Post를 얻고 캐시에 저장합니다. 여기서 캐시는 HashMap을 사용했습니다.다음은 Post를 조회하는 클라이언트 코드입니다.PostRepository postRepository = new PostRepository();CacheKey cacheKey = new CacheKey(1);CacheKey newCacheKey = new CacheKey(1);Post post1 = postRepository.getPostById(cacheKey);Post post2 = postRepository.getPostById(newCacheKey); // post1과 post2는 같은 인스턴스 (캐시)System.out.println(postRepository.getCache().size());System.out.println(&quot;run GC&quot;);System.gc(); // GC 동작System.out.println(&quot;wait&quot;);Thread.sleep(1000);System.out.println(postRepository.getCache().size());/* 실행 결과cache size : 1run GCwaitcache size : 1*/처음 getPostById 메서드를 실행했을 때, CacheKey(1)을 key로 하여 새로운 Post 참조가 캐싱됩니다. 그리고 두 번째 getPostById에서 역시 동일한 값을 가지는 key로 조회하였기 때문에 캐싱된 Post 참조가 반환됩니다. 캐시에는 하나의 참조가 캐싱된 것이기 때문에 size는 1입니다.다음, 명시적으로 GC를 실행시켰습니다. 그리고 다시 캐시 size를 확인해 보면 당연히 1인 것을 알 수 있습니다. 아무런 문제가 없어 보입니다. 그런데 만약 CacheKey(1)를 더 이상 쓸 일이 없고 프로그래머가 이를 잊었다면 어떨까요? 캐싱되어 있는 참조가 계속 남아서 메모리를 차지할 것입니다.이를 해결하는 방법은 여러 가지인데, 위의 예제처럼 운 좋게 캐시 외부에서 key를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap을 사용해 캐시를 만드는 것을 권장합니다. 다 쓴 엔트리는 그 즉시 자동으로 제거될 것입니다. 단, WeakHashMap은 이러한 상황에서만 유용하다는 사실을 기억해야 합니다.public class PostRepository { private Map&amp;lt;CacheKey, Post&amp;gt; cache; public PostRepository() { this.cache = new WeakHashMap&amp;lt;&amp;gt;(); // HashMap -&amp;gt; WeakHashMap } public Post getPostById(CacheKey key) { if (cache.containsKey(key)) { return cache.get(key); } else { // TODO DB에서 읽어오거나 REST API를 통해 Post 검색 Post post = new Post(); cache.put(key, post); return post; } } public Map&amp;lt;CacheKey, Post&amp;gt; getCache() { return cache; }}PostRepository postRepository = new PostRepository();CacheKey cacheKey = new CacheKey(1);CacheKey newCacheKey = new CacheKey(1);Post post1 = postRepository.getPostById(cacheKey);Post post2 = postRepository.getPostById(newCacheKey);System.out.println(&quot;cache size : &quot; + postRepository.getCache().size());cacheKey = null; // 참조 해제System.out.println(&quot;run GC&quot;);System.gc();System.out.println(&quot;wait&quot;);Thread.sleep(1000);System.out.println(&quot;cache size : &quot; + postRepository.getCache().size());/* 실행 결과cache size : 1run GCwaitcache size : 0*/클라이언트 코드를 보면 cacheKey = null;가 추가되었습니다. 캐싱되어 있는 참조가 더 이상 쓸 일이 없기 때문에, null로 처리해 주어 참조를 해제하는 부분입니다. WeakHashMap는 다 쓴 엔트리를 제거한다고 했습니다. 따라서 GC가 동작할 때 캐싱되어 있는 참조 중 사용되지 않는 참조가 제거됩니다. 때문에 실행 결과는 GC가 동작한 후의 size가 0이 나오게 된 것입니다.캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용합니다. 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해 줘야 합니다. (Scheduled ThreadPoolExecutor 같은) 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있습니다. LinkedHashMap은 removeEldestEntry 메서드를 써서 후자의 방식으로 처리합니다. 더 복잡한 캐시를 만들고 싶다면 java.lang.ref 패키지를 직접 활용해야 합니다.1.3 리스너와 콜백리스너와 콜백도 캐시처럼 메모리 어딘가에 저장되어야 합니다. 클라이언트가 리스너 또는 콜백을 등록만 하고 명확히 해지하지 않는다면, 뭔가 조치해 주지 않는 한 계속 쌓여갈 것입니다. 이럴 때 콜백을 약한 참조(weak reference)로 저장하면 GC가 즉시 수거해갑니다. 예를 들어 위에서 언급했던 WeakHashMap에 key로 저장하면 됩니다. 로직이 동일하기 때문에 예제 코드는 생략하겠습니다.2. 핵심 정리책에서 소개한 메모리 누수의 예는 스택, 캐시, 리스너와 콜백 이렇게 세 가지이다. 그리고 해결 방법으로는 직접 null 처리, 특정한 자료구조 사용, 백그라운드 스레드 사용 이렇게 세 가지가 있다.메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.3. Related Posts 변수의 범위 (Item 57)" }, { "title": "Item 6. 불필요한 객체 생성을 피하라", "url": "/posts/item-6-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Static Factory Method, Caching, Auto Boxing", "date": "2022-04-23 14:04:00 +0900", "snippet": "Effective Java의 여섯 번째 아이템 “불필요한 객체 생성을 피하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많습니다. 본문에서는 불필요한 객체를 생성하는 예를 알아보고, 이를 개선해 봅니다.1. 불필요한 객체 생성 예1.1. StringString s = new String(&quot;heung&quot;);이 코드는 실행될 때마다 String 인스턴스를 새로 만듭니다. 반복문이나 빈번히 호출되는 메서드 안에 있다면, 쓸데없는 String 인스턴스가 수백만 개 만들어질 수도 있습니다.String admin = new String(&quot;heung&quot;);String user = new String(&quot;heung&quot;);System.out.println(admin == user); // false우리는 생성자에 넘겨진 &quot;heung&quot; 자체가 이 생성자로 만들어내려는 String과 기능적으로 완전히 동일하다는 것을 알고 있습니다. 따라서 다음과 같이 개선할 수 있습니다.String s = &quot;heung&quot;;이 코드는 매번 새로운 인스턴스를 만드는 대신 하나의 String 인스턴스를 사용합니다. 나아가 이 방식을 사용하면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장됩니다.String admin = &quot;heung&quot;;String user = &quot;heung&quot;;System.out.println(admin == user); // true1.2. 불변 클래스다음은 불변 클래스 Boolean 타입의 객체를 생성하는 예제입니다.Boolean b1 = new Boolean(true);Boolean b2 = new Boolean(true);System.out.println(b1 == b2); // false보이는 것과 같이 생성자는 호출할 때마다 새로운 객체를 만듭니다. 쓸모없는 인스턴스가 여러 개 만들어질 수 있는 것이죠. 따라서 Boolean은 정적 팩터리 메서드를 제공합니다(실제로 Boolean의 생성자는 Java 9에서 deprecated API로 지정되었습니다).public final class Boolean { public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); ... public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; } ...}Boolean b1 = Boolean.valueOf(true);Boolean b2 = Boolean.valueOf(true);System.out.println(b1 == b2); // true생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있습니다. 또한 불변 객체뿐만 아니라 가변 객체라 해도 사용 중에 변경되지 않을 것임을 안다면 재사용할 수 있습니다.1.3. 비싼 객체생성 비용이 아주 큰 객체도 더러 있습니다. 이런 ‘비싼 객체’가 반복해서 필요하다면 캐싱하여 재사용하길 권합니다. 다음은 주어진 문자열이 유효한 로마 숫자인지를 확인하는 메서드입니다.public class RomanNumerals { static boolean isRomanNumeral(String s) { return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;); }}이 방식은 문제는 String.matches 메서드를 사용한다는 것에 있습니다. String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않습니다. 이 메서드가 내부에서 만드는 정규표현식용 Pattern 인스턴스는, 한 번 쓰고 버려져서 곧바로 GC의 대상이 됩니다. Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 높습니다.다음은 캐싱을 사용해 개선한 코드입니다.public class RomanNumerals { private static final Pattern ROMAN = Pattern.compile( &quot;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;); static boolean isRomanNumeral(String s) { return ROMAN.matcher(s).matches(); }}정규표현식을 포현하는 (불변인) Pattern 인스턴스를 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고, 나중에 isRomanNumeral 메서드가 호출될 때마다 이 인스턴스를 재사용합니다. 이렇게 하면 isRomanNumeral가 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있습니다.다음은 성능 비교를 위해 작성한 테스트 코드입니다.long start = System.currentTimeMillis();for (int j = 0; j &amp;lt; 1000000; j++) { isRomanNumeral(&quot;MCMLXXVI&quot;);}long end = System.currentTimeMillis();System.out.println(end - start);isRomanNumeral 메서드를 백만 번 호출하여 런타임 시간을 측정합니다. 참고로 MCMLXXVI는 로마 숫자이며 1976를 의미합니다.캐싱을 사용하지 않은 코드 : 647 ms캐싱을 사용한 코드 : 139 ms코드 개선(캐싱)을 통해 약 4.5배 빨라진 것을 확인할 수 있었습니다.성능과는 별개로 한 가지 더 이점이 있습니다. 코드가 더 명확해졌다는 것입니다. 개선 전에는 존재조차 몰랐던 Pattern 인스턴스를 static final 필드로 끄집어내고 이름을 지어주어 코드의 의미가 훨씬 잘 드러납니다.1.4. 오토박싱오토박싱(auto boxing)은 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해 주는 기술입니다. 그런데 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아닙니다. 의미상으로는 별다를 것 없지만 성능에서는 그렇지 않습니다.다음은 Integer.MAX_VALUE까지의 총합을 구하는 예제입니다.private static long getSum() { Long sum = 0L; for (long i = 0; i &amp;lt;= Integer.MAX_VALUE; i++) sum += i; return sum;}long 타입의 i가 Long 타입으로 오토박싱이 일어납니다. 변수 sum을 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 약 2^31개나 만들어진 것입니다. 다음은 성능 비교를 위한 테스트 코드입니다.long start = System.currentTimeMillis();sum();long end = System.currentTimeMillis();System.out.println(end - start);위의 getSum 메서드에서 변수 sum의 타입이 Long 일 때와 long 일 때의 런타임 시간을 비교해보겠습니다.Long sum 일 때 : 2963 mslong sum 일 때 : 692 ms약 4.2배 빨라졌네요. 따라서, 우리는 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 유의해야 합니다.2. 주의할 점이번 아이템을 “객체 생성은 비싸니 피해야 한다”로 오해하면 안 됩니다. 특히나 요즘의 JVM에서는 별다른 일을 하지 않는 작은 객체를 생성하고 회수하는 일이 크게 부담되지 않습니다. 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일입니다.거꾸로, 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 자신만의 객체 풀(pool)을 만드는 것은 좋지 않습니다. 물론 객체 풀을 만드는 것이 나을 때도 있습니다. 하지만 일반적으로는 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨립니다. 요즘 JVM의 GC는 상당히 잘 최적화되어서 가벼운 객체용을 다룰 때는 직접 만든 객체 풀보다 훨씬 빠릅니다.3. Related Posts 불변 (Item 17) 정적 팩터리 메서드 (Item 1) 기본 타입과 박싱된 기본 타입 (Item 61)" }, { "title": "Item 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라", "url": "/posts/item-5-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%AA%85%EC%8B%9C%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%9D%98%EC%A1%B4-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Dependency Injection, Factory Method Pattern", "date": "2022-04-20 22:08:00 +0900", "snippet": "Effective Java의 다섯 번째 아이템 “자원을 직접 명시하지 말고 의존 객체 주입을 사용하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며먼저 본문을 시작하기 전에 타이틀의 의미를 살펴보겠습니다. “자원을 직접 명시한다“가 무엇을 의미하는 걸까요? 코드를 보면 이해가 쉽습니다.public class SpellChecker { private Dictionary dictionary = new KorDictionary(); ...}SpellChecker 클래스는 Dictionary 타입의 필드를 가지고 있습니다. 그리고 해당 필드(dictionary)는 선언과 동시에 초기화되고 있죠. 바로 이것이 자원을 직접 명시한다는 것입니다. 말 그대로 자원(dictionary)이 KorDictionary 클래스의 인스턴스임을 직접 명시하는 것입니다.1. 자원을 직접 명시한 예본격적으로 예제를 통해 자세히 알아보겠습니다. 아래는 위에서 언급했던 Dictionary 인터페이스와 그것을 구현(implement)한 KorDictionary, EngDictionary 클래스의 전체 코드입니다.public interface Dictionary { boolean contains(String word); List&amp;lt;String&amp;gt; closeWordsTo(String typo);}public class KorDictionary implements Dictionary { @Override public boolean contains(String word) { // TODO 단어가 한국어 사전에 포함되어 있는지 검사하는 로직 return false; } @Override public List&amp;lt;String&amp;gt; closeWordsTo(String typo) { // TODO 오타와 비슷한 한국어 단어를 찾는 로직 return null; }}public class EngDictionary implements Dictionary { @Override public boolean contains(String word) { // TODO 단어가 영어 사전에 포함되어 있는지 검사하는 로직 return false; } @Override public List&amp;lt;String&amp;gt; closeWordsTo(String typo) { // TODO 오타와 비슷한 영어 단어를 찾는 로직 return null; }}예제를 간단히 하여 본문의 주제에만 집중하기 위해 메서드는 구현 코드는 주석으로 대체하였습니다.이제 자원을 명시하는 SpellChecker 클래스를 보겠습니다. 첫 번째는 정적 유틸리티 클래스, 두 번째는 싱글턴으로 구현한 모습입니다.// 정적 유틸리티 클래스public class SpellChecker { private static final Dictionary dictionary = new KorDictionary(); private SpellChecker() {} public static boolean isValid(String word) { return dictionary.contains(word); } public static List&amp;lt;String&amp;gt; suggestions(String typo) { return dictionary.closeWordsTo(typo); }}// 싱글턴public class SpellChecker { private final Dictionary dictionary = new KorDictionary(); private SpellChecker() {} public static SpellChecker INSTANCE = new SpellChecker(); public boolean isValid(String word) { return dictionary.contains(word); } public List&amp;lt;String&amp;gt; suggestions(String typo) { return dictionary.closeWordsTo(typo); }}정적 유틸리티 클래스와 싱글턴 모두 한국어 사전(KorDictionary)을 사용합니다. 그런데 우리는 영어 사전(EngDictionary)이 필요할 때도 있습니다. 위의 방식에서는 EngDictionary 타입의 필드를 추가하면 영어 사전을 사용할 수 있겠죠. 하지만 필요한 다른 종류의 사전이 늘어나면 어떻게 해야 할까요? 당연히 그 수만큼 필드를 추가하는 것은 비효율적일 것입니다.아주 간단히 생각해 보면 dictionary 필드에서 final 한정자를 제거하고, 다른 사전으로 교체하는 메서드를 추가할 수 있습니다.public void replaceDictionary(Dictionary dictionary) { this.dictionary = dictionary;}하지만 이 방식 역시 어색하고 오류를 내기 쉬우며 멀티스레드 환경에서는 쓸 수 없습니다. 결론적으로 사용하는 자원에 따라 동작이 달라지는 클래스에게 정적 유틸리티 클래스나 싱글턴 방식은 적합하지 않습니다.2. 의존 객체 주입대신, “클래스(SpellChecker)가 여러 자원 인스턴스를 지원해야 하며 클라이언트가 원하는 자원(dictionary)을 사용해야 한다” 이 조건을 만족하는 간단한 패턴이 있습니다. 바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식입니다. 이는 의존 객체 주입의 한 형태로, SpellChecker를 생성할 때 의존 객체인 Dictionary을 주입하는 것입니다.public class SpellChecker { private final Dictionary dictionary; public SpellChecker(Dictionary dictionary) { this.dictionary = Objects.requireNonNull(dictionary); } public boolean isValid(String word) { return dictionary.contains(word); } public List&amp;lt;String&amp;gt; suggestions(String typo) { return dictionary.closeWordsTo(typo); }}SpellChecker korSpellChecker = new SpellChecker(new KorDictionary());SpellChecker engSpellChecker = new SpellChecker(new EngDictionary());예제에서는 dictionary라는 딱 하나의 자원만 사용하지만, 의존 객체 주입은 자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 동작하고, 불변을 보장하여 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있도록 합니다. 또한 이전 포스팅에서 다루었던 생성자, 정적 팩터리, 빌더에도 똑같이 응용할 수 있습니다.이 패턴의 변형으로, 생성자에 자원 팩터리를 넘겨주는 방식이 있습니다. 여기서 팩터리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체를 말합니다. 즉, 팩터리 메서드 패턴을 구현한 것입니다.Java 8에서 소개한 함수형 인터페이스 Supplier&amp;lt;T&amp;gt;가 팩터리를 표현한 완벽한 예시입니다. Supplier&amp;lt;T&amp;gt;를 입력으로 받는 메서드는 일반적으로 한정적 와일드카드 타입을 사용해 팩터리의 타입 매개변수를 제한해야 합니다. 이 방식을 사용해 클라이언트는 자신이 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩터리를 넘길 수 있습니다.public class SpellChecker { private final Dictionary dictionary; public SpellChecker(Supplier&amp;lt;? extends Dictionary&amp;gt; dictionarySupplier) { this.dictionary = dictionarySupplier.get(); } public boolean isValid(String word) { return dictionary.contains(word); } public List&amp;lt;String&amp;gt; suggestions(String typo) { return dictionary.closeWordsTo(typo); }} SpellChecker korSpellChecker = new SpellChecker(KorDictionary::new); SpellChecker engSpellChecker = new SpellChecker(EngDictionary::new);의존 객체 주입이 유연성과 테스트 용이성을 개선해 주기는 하지만, 의존성이 수 천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 합니다. 이런 어질러짐을 해소하기 위해서는 Dagger, Guice, Spring과 같은 의존 객체 주입 프레임워크를 사용할 수 있습니다.3. 핵심 정리클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스를 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안 된다. 대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 기막히게 개선해 준다.4. Related Posts 정적 유틸리티 클래스 (Item 4) 불변 (Item 17) 정적 팩터리 (Item 1) 빌더 (Item 2)" }, { "title": "Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라", "url": "/posts/item-4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94%EB%A5%BC-%EB%A7%89%EC%9C%BC%EB%A0%A4%EA%B1%B0%EB%93%A0-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Constructor", "date": "2022-04-15 21:15:00 +0900", "snippet": "Effective Java의 네 번째 아이템 “인스턴스화를 막으려거든 private 생성자를 사용하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며책에서 인스턴스화를 막아놓는 클래스의 예시로 유틸리티 클래스를 언급합니다. 본문에서 유틸리티 클래스에 대한 개념과 인스턴스화를 막는 방법을 알아보겠습니다.1. 유틸리티 클래스유틸리티 클래스란 인스턴스 메서드와 인스턴스 변수를 일절 제공하지 않고, 정적 메서드와 정적 변수만을 제공하는 클래스를 의미합니다. 유틸리티 클래스의 존재 의의는 클래스 본래의 목적인 ‘데이터와 데이터 처리를 위한 로직의 캡슐화’를 실행하는 것이 아닌, ‘비슷한 기능의 메서드와 상수를 모아서 캡슐화’를 하는 것에 있습니다.개발을 하다 보면 종종 유틸리티 클래스를 만들고 싶을 때가 있습니다. java.lang.Math와 java.util.Arrays처럼 기본 타입 값이나 배열 관련 메서드들을 모아놓을 수 있고, java.util.Collections처럼 특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드를 모아놓을 수도 있습니다. 또한 final 클래스와 관련한 메서드들을 모아놓을 때도 사용할 수 있습니다.다음 예제는 org.springframework.util 패키지의 StringUtils의 일부 코드입니다.package org.springframework.util;public abstract class StringUtils { private static final String[] EMPTY_STRING_ARRAY = new String[0]; private static final String FOLDER_SEPARATOR = &quot;/&quot;; private static final String WINDOWS_FOLDER_SEPARATOR = &quot;\\\\&quot;; private static final String TOP_PATH = &quot;..&quot;; private static final String CURRENT_PATH = &quot;.&quot;; private static final char EXTENSION_SEPARATOR = &#39;.&#39;; public static boolean hasLength(@Nullable CharSequence str) { return str != null &amp;amp;&amp;amp; str.length() &amp;gt; 0; } public static boolean hasText(@Nullable CharSequence str) { return str != null &amp;amp;&amp;amp; str.length() &amp;gt; 0 &amp;amp;&amp;amp; containsText(str); } private static boolean containsText(CharSequence str) { int strLen = str.length(); for(int i = 0; i &amp;lt; strLen; ++i) { if (!Character.isWhitespace(str.charAt(i))) { return true; } } return false; } ...}이러한 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아닙니다. 정적 멤버만을 가지고 있기 때문에 인스턴스 없이 모든 기능을 수행할 수 있습니다. 그런데 문제는 java는 생성자를 명시해 주지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다는 것입니다. 때문에 사용자는 이 생성자가 자동으로 생성된 것인지 구분할 수 없어 인스턴스를 만들 가능성이 있습니다. 이는 곧 필요 없는 인스턴스를 생성하게 되어 메모리를 낭비하는 것입니다.그런데 위의 예제를 보면 abstract 키워드를 사용하여 추상 클래스로 정의되어 있습니다. 추상 클래스는 인스턴스를 만들 수 없기 때문에 문제가 없는 것처럼 보이는데요. 추상 클래스도 인스턴스화가 가능합니다. 추상 클래스를 상속받는 하위 클래스를 만들어서 인스턴스화하면 그만입니다. 모든 하위 클래스의 생성자에는 상위 클래스의 생성자를 호출하는 코드가 숨겨져 있기 때문입니다.2. 해결 방법그러면 유틸리티 클래스의 인스턴스화를 어떻게 막아야 할까요? 방법은 간단합니다. 컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때뿐이니 private 생성자를 추가해주면 됩니다.public class UtilityClass { ... // 기본 생성자가 만들어지는 것을 막는다. (인스턴스 방지용) private UtilityClass() { throw new AssertionError(); } ...}명시적 생성자가 private이니 클래스의 외부에서는 접근할 수 없습니다. 그리고 클래스 내부에서 실수로라도 생성자를 호출하는 것을 방지하기 위해 생성자를 호출했을 경우 AssertionError를 던지도록 구현합니다(꼭 에러를 던질 필요는 없습니다). 추가적으로 코드의 가독성을 위해 위의 예제처럼 적절한 주석을 달아주는 것을 권장합니다.private 생성자를 만들면 상속을 불가능하게 하는 효과도 있습니다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데, 이를 private으로 선언했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버리는 것입니다.3. Related Posts 상속 (Item 19)" }, { "title": "Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라", "url": "/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Singleton, Design Pattern", "date": "2022-04-12 23:45:00 +0900", "snippet": "Effective Java의 세 번째 아이템 “private 생성자나 열거 타입으로 싱글턴임을 보증하라”를 읽고 정리한 내용을 포스팅합니다.1. 싱글턴(singleton)싱글턴이란 어떤 클래스가 최초 한 번만 메모리를 할당하고, 그 메모리의 인스턴스를 만들어 사용하는 디자인 패턴입니다. 즉, 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다.싱글턴의 전형적인 예로는 함수와 같은 무상태(stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트를 들 수 있습니다.2. 사용하는 이유인스턴스가 한 개만 생성되도록 하면 어떤 이점이 있을까요?가장 먼저 떠올릴 수 있는 이점은 아무래도 메모리일 것입니다. 최초 한 번의 new 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때 메모리 낭비를 방지할 수 있습니다. 또한 객체의 두 번째 접근부터는 객체 로딩이 줄어 더 빠른 속도을 기대할 수 있습니다.또 다른 이점은 데이터 공유가 쉽다는 것입니다. 인스턴스가 전역으로 사용되기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있습니다.이외에도 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶은 경우 사용합니다.3. 싱글턴 구현 방식인스턴스가 오직 한 개만 존재하도록 하는 이 싱글턴을 구현하는 세 가지 방식을 알아보겠습니다.3.1 public 필드생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public 필드를 제공하는 방식입니다.public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} public void leaveTheBuilding() { ... }}private 생성자는 public static final 필드인 Elvis.INSTANCE를 초기화할 때 딱 한 번만 호출됩니다. public이나 protected 생성자가 없기 때문에 Elvis 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장됩니다.Elvis elvis1 = Elvis.INSTANCE;Elvis elvis2 = Elvis.INSTANCE;System.out.println(elvis1 == elvis2);/* 실행 결과true*/public 필드 방식의 장점은 해당 클래스가 싱글턴임이 API에 명백히 드러난다는 것입니다. public static 필드가 final이니 절대로 다른 객체를 참조할 수 없습니다. 두 번째 장점은 간결함입니다. 구현이 쉬워 코드가 깔끔하고 가독성도 좋습니다.그런데 예외 상황이 있습니다. 권한이 있는 클라이언트는 리플렉션 API인 AccessibleObject.setAccessible을 사용하면 private 생성자를 호출할 수 있습니다.try { Constructor&amp;lt;Elvis&amp;gt; defaultConstructor = Elvis.class.getDeclaredConstructor(); defaultConstructor.setAccessible(true); // private 생성자 호출 허용 Elvis elvis1 = defaultConstructor.newInstance(); Elvis elvis2 = defaultConstructor.newInstance(); System.out.println(elvis1 == elvis2);} catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) { e.printStackTrace();}/* 실행 결과false*/먼저 Elvis.class.getDeclaredConstructor 메서드를 통해 Constructor 객체를 얻습니다. 그리고 setAccessible(true)를 사용해 private 생성자 호출을 허용하면 newInstance()를 통해 새로운 인스턴스를 생성할 수 있습니다. 이제 elvis1과 elvis2 인스턴스를 비교해 보면 false가 출력되는 것을 확인할 수 있습니다.이러한 공격을 방어하기 위해서는 생성자를 수정하여 두 번째 객체가 생성되려 할 때 예외를 던지도록 해야 합니다.public class Elvis { public static final Elvis INSTANCE = new Elvis(); private static boolean created; private Elvis() { // 인스턴스가 이미 만들어졌을 경우 예외 throw if (created) { throw new UnsupportedOperationException(&quot;can&#39;t be created by constructor.&quot;); } created = true; } public void leaveTheBuilding() { ... }}이제 다시 테스트를 해 보겠습니다.// 수정된 Elvis 테스트try { Constructor&amp;lt;Elvis&amp;gt; defaultConstructor = Elvis.class.getDeclaredConstructor(); defaultConstructor.setAccessible(true); Elvis elvis1 = defaultConstructor.newInstance(); // 에러 Elvis elvis2 = defaultConstructor.newInstance(); // 에러 System.out.println(elvis1 == elvis2);} catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) { e.printStackTrace();}/* 실행 결과java.lang.reflect.InvocationTargetExceptionCaused by: java.lang.UnsupportedOperationException: can&#39;t be created by constructor....*/Elvis 클래스의 public static final Elvis INSTANCE = new Elvis();에서 이미 인스턴스를 만들었기 때문에 보이는 것과 같이 UnsupportedOperationException가 발생했습니다. 이제는 리플렉션을 통해 새로운 인스턴스를 생성할 수 없어졌습니다.한 가지 더 문제점이 있습니다. 역직렬화를 할때 새로운 인스턴스가 생길 수 있다는 것입니다. 먼저 Elvis 클래스의 직렬화를 위해 Serializable 인터페이스를 구현합니다.public class Elvis implements Serializable { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} public void leaveTheBuilding() { ... }}다음은 Elvis 클래스를 직렬화한 후 다시 역직렬화해 기존의 Elvis 인스턴스와 동일한지 비교하는 예제입니다.try (ObjectOutput out = new ObjectOutputStream(new FileOutputStream(&quot;elvis.obj&quot;))) { out.writeObject(Elvis.INSTANCE);} catch (IOException e) { e.printStackTrace();}try (ObjectInput in = new ObjectInputStream(new FileInputStream(&quot;elvis.obj&quot;))) { Elvis elvis = (Elvis) in.readObject(); System.out.println(elvis == Elvis.INSTANCE);} catch (IOException | ClassNotFoundException e) { e.printStackTrace();}/* 실행 결과false*/실행 결과에서 알 수 있듯이 동일하지 않은 인스턴스가 생성되었습니다. 이를 해결하기 위해서는 Elvis 클래스에 readResolve 메서드를 추가해 주어야 합니다.public class Elvis implements Serializable { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} public void leaveTheBuilding() { ... } private Object readResolve() { return INSTANCE; }}이제 다시 위의 테스트 코드를 실행시켜 보면 true를 출력하는 것을 확인할 수 있습니다. 역직렬화를 할 때 내부적으로 readResolve라는 메서드를 호출하도록 설계되어 있기 때문입니다.3.2 정적 팩터리생성자와 필드는 private으로 감춰두고, 유일할 인스턴스를 접근할 수 있는 수단으로 정적 팩터리 메서드를 제공하는 방식입니다.public class Elvis { private static final Elvis INSTANCE = new Elvis(); private Elvis() {} public static Elvis getInstance() { return INSTANCE; } public void leaveTheBuilding() { ... }}다음은 정적 팩터리 메서드를 사용하여 두 객체를 만들고 인스턴스를 비교하는 예제입니다.Elvis elvis1 = Elvis.getInstance();Elvis elvis2 = Elvis.getInstance();System.out.println(elvis1 == elvis2);/* 실행 결과true*/Elvis.getInstance 메서드는 항상 같은 객체의 참조를 반환하기 때문에 제2의 인스턴스는 결코 만들어지지 않습니다.정적 팩터리 방식의 첫 번째 장점은 API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다는 점입니다.Elvis elvis1 = Elvis.getInstance();Elvis elvis2 = Elvis.getInstance();System.out.println(elvis1);System.out.println(elvis2);/* 실행 결과example.item3.Elvis@6aaa5eb0example.item3.Elvis@6aaa5eb0*/위와 같은 클라이언트 코드가 있습니다. Elvis가 싱글턴이니 elvis1과 elvis2는 같은 인스턴스를 참조하고 있을 것입니다. 하지만 어떤 이유로 인해 싱글턴이 아니게, 즉 서로 다른 인스턴스를 만들고 싶다면 어떻게 해야 할까요?public static Elvis getInstance() { return new Elvis();}정적 팩터리 방식에서는 클라이언트 코드를 수정하지 않고 정적 팩터리 메서드를 수정하면 간단하게 변경할 수 있습니다.Elvis elvis1 = Elvis.getInstance();Elvis elvis2 = Elvis.getInstance();System.out.println(elvis1);System.out.println(elvis2);/* 실행 결과example.item3.Elvis@6aaa5eb0example.item3.Elvis@3498ed*/두 번째 장점은 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다는 점입니다. 다음은 Elvis 클래스를 제네릭 싱글턴 팩터리 패턴으로 만든 예제입니다. public class Elvis&amp;lt;T&amp;gt; { private static final Elvis&amp;lt;Object&amp;gt; INSTANCE = new Elvis&amp;lt;&amp;gt;(); private Elvis() {} @SuppressWarnings(&quot;unchecked&quot;) public static &amp;lt;T&amp;gt; Elvis&amp;lt;T&amp;gt; getInstance() { return (Elvis&amp;lt;T&amp;gt;) INSTANCE; } public void leaveTheBuilding() { ... } }제네릭 싱글턴 팩터리는 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리 입니다. 제네릭 싱글턴 팩터리를 사용하면 동일한 인스턴스를 참조하지만 서로 다른 타입의 객체를 만들 수 있습니다.Elvis&amp;lt;String&amp;gt; elvis1 = Elvis.getInstance();Elvis&amp;lt;Integer&amp;gt; elvis2 = Elvis.getInstance();System.out.println(elvis1);System.out.println(elvis2);/* 실행 결과example.item3.Elvis@6aaa5eb0example.item3.Elvis@6aaa5eb0*실행 결과를 보면 elvis1과 elvis2는 같은 인스턴스를 참조하고 있습니다. 하지만 둘은 서로 다른 타입을 가지고 있습니다.세 번째 장점은 정적 팩터리의 메서드 참조를 함수형 인터페이스 Supplier로 사용할 수 있다는 점입니다.다음은 Java에서 제공하는 함수형 인터페이스 Supplier의 선언 부분입니다.@FunctionalInterfacepublic interface Supplier&amp;lt;T&amp;gt; { T get();}Elvis의 getInstance 메서드는 인자는 받지 않고 인스턴스를 리턴합니다. 그 구조가 Supplier의 get 메서드와 동일합니다. 따라서 Elvis getInstance 메서드의 참조를 Supplier로 사용할 수 있습니다.Supplier&amp;lt;Elvis&amp;gt; elvisSupplier = Elvis::getInstance; // 물론 람다식도 가능합니다. () -&amp;gt; Elvis.getInstance();Elvis elvis1 = elvisSupplier.get();Elvis elvis2 = elvisSupplier.get();System.out.println(elvis1);System.out.println(elvis2);/* 실행 결과example.item3.Elvis@1a407d53example.item3.Elvis@1a407d53*/Supplier의 get 메서드와 Elvis의 getInstance가 매핑됩니다. 실행 결과를 보면 get 메서드가 동일한 Elvis 인스턴스를 리턴하는 것을 알 수 있습니다.정적 팩터리 방식에도 public 필드 방식과 같이 리플렉션과 직렬화에서 예외 상황이 발생할 수 있습니다. 예제 코드는 public 필드 방식과 거의 동일하니 생략하겠습니다.3.3 열거 타입원소가 하나인 열거 타입을 선언하는 방식입니다.public enum Elvis { INSTANCE; public void leaveTheBuilding() { ... }}열거 타입은 상수 하나당 인스턴스를 하나씩 만들어 public static final 필드로 공개합니다. 열거 타입의 인스턴스는 클라이언트가 직접 생성할 수 없고 런타임에 한 번만 생성됩니다.Elvis elvis1 = Elvis.INSTANCE;Elvis elvis2 = Elvis.INSTANCE;System.out.println(elvis1 == elvis2);/* 실행 결과true*/public 필드 방식과 비슷하지만, 더 간결하고 추가 노력 없이 직렬화 할 수 있고 심지어 아주 복잡한 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아줍니다.조금 부자연스러워 보일 수는 있으나 대부분의 상황에서 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법입니다. 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없습니다. 다른 인터페이스를 구현하는 것은 가능합니다.4. 문제점싱글턴은 여러 문제점을 가지고 있어 안티 패턴으로도 불리는데요, 그 이유를 알아보겠습니다.첫 번째, 멀티스레드 환경에서 동시성 문제가 발생할 수 있습니다. 하나의 인스턴스를 여러 스레드에서 공유하고 있기 때문에, 어떤 스레드에서 인스턴스의 상태를 변경한다면 이는 다른 스레드에도 영향이 미치게 됩니다. 결국 일관된 값을 보장할 수 없게 되는 것입니다.두 번째, 테스트를 수행하기 어렵습니다. 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜(mock) 구현으로 대체할 수 없습니다. 때문에 격리된 환경에서 독립적인 테스트를 수행하기 어렵습니다.세 번째, 의존 관계상 클라이언트가 구체 클래스에 의존하게 됩니다. new 키워드를 직접 사용하여 클래스 안에서 생성하고 있으므로 객체 지향 설계 SOLID 원칙 중 DIP(의존 역전 원칙)를 위반하게 되고, OCP(개방 폐쇄 원칙) 또한 위반하게 될 가능성이 높습니다.네 번째, 객체지향과 맞지 않습니다. 싱글턴의 사용은 전역 상태를 만들 수 있습니다. 아무 객체나 자유롭게 접근하고 수정할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 지양되어야 할 모델입니다. 또한 싱글턴은 private 생성자를 갖고 있기 때문에 상속이 불가능합니다. 때문에 다형성과 같은 객체지향의 특징이 적용되지 않습니다.싱글턴은 하나의 인스턴스를 생성하고 재사용할 수 있다는 장점이 있기 때문에 필요한 경우가 분명히 있습니다. 하지만 싱글턴을 직접 구현하면 다른 단점들이 너무 크게 부각되기 때문에 활용이 쉽지 않습니다. 때문에 스프링과 같은 프레임워크를 활용하여 프레임워크가 객체를 싱글턴으로 관리하도록 하면 단점을 많이 극복할 수 있습니다.5. Related Posts 함수 (Item 24) 리플렉션 API (Item 65) 제네릭 싱글턴 팩터리 (Item 30) 메서드 참조 (Item 43) 함수형 인터페이스 (Item 44) readResolve (Item 89)" }, { "title": "Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라", "url": "/posts/effective-java-item-2-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EB%A7%8E%EB%8B%A4%EB%A9%B4-%EB%B9%8C%EB%8D%94%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Constructor, Builder", "date": "2022-04-10 18:03:00 +0900", "snippet": "Effective Java의 두 번째 아이템 “생성자에 매개변수가 많다면 빌더를 고려하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며생성자와 정적 팩터리는 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 제약이 있습니다. 본문에서 이를 해결하기 위한 세 가지 대안을 제시하고, 그중 일반적으로 가장 효과적인 빌더 패턴에 대해 자세히 알아봅니다.1. 대안1.1 점층적 생성자 패턴필수 매개 변수만 받는 생성자, 선택 매개변수 1개를 함께 받는 생성자, 선택 매개변수 2개를 함께 받는 생성자, … 형태로 선택 매개변수를 전부 다 받는 생성자까지 늘려가는 방식입니다.다음은 필수 매개변수 2개와 선택 매개변수 3개를 받는 User 클래스의 점층적 생성자 패턴 예제입니다.public class User { // 필수 매개변수 private final String name; private final int age; // 선택 매개변수 private final String address; private final String phone; private final String email; public User(String name, int age) { this(name, age, null, null, null); } public User(String name, int age, String address) { this(name, age, address, null, null); } public User(String name, int age, String address, String phone) { this(name, age, address, phone, null); } public User(String name, int age, String address, String phone, String email) { this.name = name; this.age = age; this.address = address; this.phone = phone; this.email = email; }}이 클래스의 인스턴스를 만들려면 원하는 매개변수를 모두 포함한 생성자 중 가장 짧은 것을 골라 호출하면 됩니다. 위 예제 코드는 깔끔하고 괜찮아 보이지만 한계가 분명히 존재합니다. 매개변수의 개수가 많아질수록 클라이언트 코드를 작성하거나 읽기 어려워진다는 것입니다. 코드를 읽을 때 각 값의 이미가 무엇인지 헷갈릴 것이고, 매개변수가 몇 개인지도 주의해서 세어 보아야 할 것입니다. 또한 타입이 같은 매개변수가 연달아 늘어져 있으면 찾기 어려운 버그로 이어질 가능성도 있습니다.1.2. 자바빈즈 패턴매개변수가 없는 생성자로 객체를 만든 후, setter 메서드를 호출해 원하는 매개변수의 값을 설정하는 방식입니다.다음은 위의 예제와 동일한 User 클래스에 자바빈즈 패턴을 적용한 예제입니다.public class User { private String name; private int age; private String address; private String phone; private String email; public User() {} public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } public void setAddress(String address) { this.address = address; } public void setPhone(String phone) { this.phone = phone; } public void setEmail(String email) { this.email = email; }}기본 생성자를 통해 인스턴스를 생성하고 setter 메서드를 사용해 값을 넣어줘 인스턴스를 완성합니다. 이러한 자바빈즈 패턴은 점층적 생성자 패턴의 단점을 보완하여, 인스턴스를 만들기 쉽고 읽기 쉬운 코드가 되었습니다.하지만 자바빈즈 패턴에도 역시 한계가 존재합니다. 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 됩니다. 때문에 클래스를 불변으로 만들 수 없으며 스레드의 안정성을 얻기 위해서는 프로그래머의 추가 작업이 필요합니다.1.3. 빌더 패턴클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개 변수만으로 생성자(혹은 정적 팩터리)를 호출해 빌더 객체를 얻습니다. 그다음 빌더 객체가 제공하는 일종의 setter 메서드로 원하는 선택 매개변수들을 설정합니다. 마지막으로 매개변수가 없는 build 메서드를 호출해 필요한 객체(보통은 불변)를 얻습니다.다음은 계층적으로 설계된 클래스에서 빌더를 활용한 예제입니다. 추상 클래스인 Pizza는 추상 빌더를, 구체 클래스인 ChicagoPizza, HawaiianPizza는 구체 빌더를 선언했습니다.public abstract class Pizza { public enum Topping { HAM, MUSHROOM, ONION, PERPER, SAUSAGE } final Set&amp;lt;Topping&amp;gt; toppings; abstract static class Builder&amp;lt;T extends Builder&amp;lt;T&amp;gt;&amp;gt; { EnumSet&amp;lt;Topping&amp;gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // 하위 클래스는 이 메서드를 재정의하여 this를 반환 protected abstract T self(); } Pizza(Builder&amp;lt;?&amp;gt; builder) { toppings = builder.toppings.clone(); }}public class ChicagoPizza extends Pizza { public enum Size { SMALL, MEDIUM, LARGE } private Size size; public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; { private final Size size; public Builder(Size size) { this.size = Objects.requireNonNull(size); } @Override public ChicagoPizza build() { return new ChicagoPizza(this); } @Override protected Builder self() { return this; } } private ChicagoPizza(Builder builder) { super(builder); size = builder.size; }}public class HawaiianPizza extends Pizza { private final boolean pineapple; public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; { private boolean pineapple = true; public Builder() {} public Builder pineappleOut() { pineapple = false; return this; } @Override public HawaiianPizza build() { return new HawaiianPizza(this); } @Override protected Builder self() { return this; } } private HawaiianPizza(Builder builder) { super(builder); pineapple = builder.pineapple; }}시카고 피자의 빌더는 크기(size) 매개변수를 필수로 받고, 하와이안 피자의 빌더는 필수 매개변수는 없지만 pineappleOut 메서드을 통해 파인애플을 뺄지 결정할 수 있습니다. 그리고 두 빌더 모두 Pizza.Builder를 상속받았기 때문에 addTopping을 통해 토핑을 추가할 수 있습니다. 참고로 빌더의 build 메서드는 해당하는 구체 하위 클래스를 반환하고, self 메서드는 메서드 체이닝을 위해 this(빌더)를 반환합니다.// 빌더 사용 예제ChicagoPizza chicagoPizza = new ChicagoPizza.Builder(LARGE) .addTopping(HAM).addTopping(SAUSAGE) .build();HawaiianPizza hawaiianPizza = new HawaiianPizza.Builder() .addTopping(ONION).addTopping(MUSHROOM) .pineappleOut() .build();빌더 패턴은 점층적 생성자 패턴과 자바빈즈 패턴의 단점을 모두 보완했습니다. 메서드 체인을 사용해 객체를 생성하여 일관성을 해치지 않으며 작성하기 쉽고 가독성이 좋습니다. 추가적으로 위의 예제처럼 공변 반환 타이핑을 이용하면 형변환에 신경 쓰지 않고 빌더를 사용할 수 있기 때문에 계층적으로 설계된 클래스와 함께 쓰기에도 좋습니다.하지만 빌더 패턴에 장점만 있는 것은 아닙니다. 객체를 만들려면, 그에 앞서 빌더부터 만들어야 합니다. 빌더 생성 비용이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수도 있습니다. 또한 점층적 생성자 패턴보다는 코드가 장황해서 매개변수가 4개 이상은 되어야 값어치를 합니다. 하지만 API의 확장성을 고려하여 애초에 빌더로 시작하는 편이 나을 때가 많습니다. 공변 반환 타이핑(covariant return typing) 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 것을 의미합니다.2. 핵심 정리생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 것이 더 낫다. 매개변수 중 다수가 필수가 아니거나 같은 타입이면 특히 더 그렇다. 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.3. Related Posts 불변 (Item 17)" }, { "title": "Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라", "url": "/posts/effective-java-item-1-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "Book, Effective Java", "tags": "Java, Effective Java, Static Method, Constructor", "date": "2022-04-09 23:22:00 +0900", "snippet": "Effective Java의 첫 번째 아이템 “생성자 대신 정적 팩터리 메서드를 고려하라”를 읽고 정리한 내용을 포스팅합니다.0. 들어가며시작하기 전에 정적 팩터리 메서드(static factory method)의 개념을 알아보겠습니다. 다음은 Boolean 클래스에서 제공하는 정적 팩터리 메서드입니다.// 정적 팩터리 메서드 예시public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE;}해당 메서드는 기본 타입인 boolean 값을 받아 Boolean 객체 참조로 변환해 줍니다. 정적 팩터리 메서드란 단순히 클래스의 인스턴스를 반환하는 static 메서드 것입니다.이처럼 클래스는 클라이언트에 public 생성자 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있습니다. 이 방식에는 장점과 단점이 모두 존재하는데, 본문에서 간단한 예제를 통해 자세히 살펴보겠습니다.1. 장점1.1. 이름을 가질 수 있다.생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못합니다. 반면 정적 팩터리 메서드는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.다음 예제는 BigInteger 클래스가 제공하는 probablePrime라는 정적 팩터리 메서드입니다.package java.math;public class BigInteger extends Number implements Comparable&amp;lt;BigInteger&amp;gt; { // probablePrime라는 이름을 통해 &#39;값이 소수인 BigInteger를 반환한다&#39;라는 의미를 명확히 합니다. public static BigInteger probablePrime(int bitLength, Random rnd) { if (bitLength &amp;lt; 2) throw new ArithmeticException(&quot;bitLength &amp;lt; 2&quot;); return (bitLength &amp;lt; SMALL_PRIME_THRESHOLD ? smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) : largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd)); }}1.2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.이 덕분에 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱 하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있습니다. 비슷한 기법으로 플라이웨이트 패턴이 있습니다.반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저하게 통제할 수 있습니다. 이런 클래스를 통제 클래스라 합니다.그렇다면 인스턴스를 통제하는 이유는 무엇일까요?인스턴스를 통제하면 클래스를 싱글턴 또는 인스턴스화 불가로 만들 수 있습니다. 또한 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐 임을 보장할 수 있습니다.public class Developer { boolean canBackend; boolean canFrontend; private Developer() {} // 인스턴스를 미리 만들어 놓고, 이를 재활용 한다. private static final Developer developer = new Developer(); public static Developer getBackEnd() { developer.canBackend = true; return developer; } public static Developer getFrontEnd() { developer.canFrontend = true; return developer; } public static Developer getFullStack() { developer.canBackend = true; developer.canFrontend = true; return developer; }} 플라이웨이트 패턴(Flyweight Pattern) 어떤 클래스의 인스턴스 한 개만 가지고 여러 개의 가상 인스턴스를 제공하고 싶을 때 사용하는 패턴입니다. 즉, 인스턴스를 가능한 대로 공유시켜 쓸데없이 new 연산자를 통한 메모리 낭비를 줄이는 방식입니다.1.3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.이 능력은 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 ‘엄청난 유연성’을 선물합니다. API를 만들 때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있습니다. 이는 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술입니다.자바 컬렉션 프레임워크는 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 덧붙이 총 45개의 유틸리티 구현체를 제공하는데, 이 구현체 대부분을 단 하나의 인스턴스 불가 동반 클래스인 java.util.Collections에서 정적 팩터리 메서드를 통해 얻도록 했습니다.컬렉션 프레임워크는 이 45개의 클래스를 공개하지 않기 때문에 API 외견을 훨씬 작게 만들 수 있습니다. API가 작아진 것은 물론 개념적인 무게, 즉 프로그래머가 API를 사용하기 위해 익혀야 하는 개념의 수와 난이도도 낮췄습니다. 프로그래머는 명시한 인터페이스대로 동작하는 객체를 얻을 것임을 알기에 굳이 별도 문서를 찾아가며 실제 구현 클래스가 무엇인지 알아보지 않아도 됩니다. 나아가 정적 팩터리 메서드를 사용하는 클라이언트는 객체를 인터페이스만으로 다루게 됩니다. 인스턴스화 불가 동반 클래스(companion class) java 8 이전에는 인터페이스에서 정적 메서드를 정의할 수 없기 때문에 인스턴스화 불가 동반 클래스를 두어 관련된 정적 메서드를 제공했습니다. 대표적인 예로 위에서 언급한 Collection 인터페이스와 Collections 동반 클래스가 있습니다. java 8 이후에는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기 때문에, 동반 클래스에 두었던 정적 메서드를 인터페이스 자체에 둘 수 있게 되었습니다. 따라서 인스턴스화 불가 동반 클래스를 둘 이유가 없어졌습니다.1.4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없습니다. 클라이언트는 팩터리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수도 없고 알 필요도 없습니다.다음은 EnumSet 클래스가 제공하는 noneOf라는 정적 팩터리 메서드입니다.package java.util;public abstract class EnumSet&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; { ... public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; EnumSet&amp;lt;E&amp;gt; noneOf(Class&amp;lt;E&amp;gt; elementType) { Enum&amp;lt;?&amp;gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + &quot; not an enum&quot;); // 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet 인스턴스를 반환합니다. // 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환합니다. if (universe.length &amp;lt;= 64) return new RegularEnumSet&amp;lt;&amp;gt;(elementType, universe); else return new JumboEnumSet&amp;lt;&amp;gt;(elementType, universe); } ...}package java.util;// 위의 noneOf 메서드는 반환형이 EnumSet 인데, RegularEnumSet와 JumboEnumSet를 반환했습니다.// 이렇게 할 수 있는 이유는 RegularEnumSet와 JumboEnumSet이 EnumSet의 하위 타입이기 때문입니다. (장점 3)class RegularEnumSet&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; extends EnumSet&amp;lt;E&amp;gt; { ...}class JumboEnumSet&amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; extends EnumSet&amp;lt;E&amp;gt; { ...}1.5. 정적 펙터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.다음 예제는 프로젝트 내부에 HelloService의 동작을 구현하는 구현체가 존재하지 않는 상황에서 HelloService 사용하는 예제입니다.public interface HelloService { String hello();}public class HelloServiceFactory { /* ServiceLoader를 통해 외부 라이브러리(jar)에 포함된 구현체를 읽어들여 사용합니다. 즉, 어떤 구현체가 올지 모르지만 해당 구현체가 따르는 인터페이스 기반으로 사용하는 것입니다. 이는 특정 구현체에 의존하지 않기 때문에(import도 하지 않음) 유연한 코드입니다. */ public static Optional&amp;lt;HelloService&amp;gt; getService() { ServiceLoader&amp;lt;HelloService&amp;gt; loader = ServiceLoader.load(HelloService.class); return loader.findFirst(); }}public class HelloMain { public static void main(String[] args) { HelloServiceFactory.getService() .ifPresent(HelloService::hello); }}이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이 됩니다. 대표적인 서비스 제공자 프레임워크로는 JDBC가 있습니다. 서비스 제공자 프레임워크에서의 제공자는 서비스의 구현체입니다. 그리고 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해 줍니다.서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이뤄집니다. 서비스 인터페이스 : 구현체의 동작을 정의 제공자 등록 API : 제공자가 구현체를 등록할 때 사용 서비스 접근 API : 클라이언트가 서비스의 인스턴스를 얻을 때 사용클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있습니다. 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 돌아가며 반환합니다. 이 서비스 접근 API가 바로 서비스 제공자 프레임워크의 근간이라고 한 ‘유연한 정적 팩터리’의 실체입니다.3개의 핵심 컴포넌트와 더불어 종종 서비스 제공자 인터페이스라는 네 번째 컴포넌트가 쓰이기도 합니다. 이 컴포넌트는 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명해 줍니다. 서비스 제공자 인터페이스가 없다면 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야 합니다.서비스 제공자 프레임워크 패턴에는 여러 변형이 있습니다. 예컨대 서비스 접근 API는 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에 반환할 수 있습니다. 브리지 패턴이라 알려진 것입니다. 의존 객체 주입 프레임워크도 강력한 서비스 제공자라고 생각할 수 있습니다. 브리지 패턴(Bridge pattern) 구현부에서 추상층을 분리하여 각자 독립적으로 변형 및 확장이 가능하도록 만드는 패턴입니다. 즉, 기능과 구현에 대해 두 개의 별도의 클래스로 구현합니다.2. 단점2.1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.어찌 보면 이 제약은 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있습니다.// 컴파일 에러// 하위 클래스(JuniorDeveloper)에서 상위 클래스(Developer)의 생성자를 사용할 수 없기 때문에 에러가 발생합니다.public class JuniorDeveloper extends Developer { ...}2.2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 합니다.// document 생성mvn javadoc:javadocjava document에서 생성자의 경우 해당 내용을 정의하는 영역이 있어 한눈에 확인할 수 있지만, 정적 팩터리 메서드의 경우 많은 메서드들 사이에 정의되어 있어 사용자가 직접 찾아봐야 하는 번거로움이 존재합니다. 이런 불편을 해소하기 위해서는 아래와 같이 document에 관련 설명을 추가하는 것을 권장합니다./** * 이 클래스는 생성자를 제공하지 않으며, 인스턴스를 얻기 위해 정적 팩터리 메서드를 사용합니다. * @see #getBackEnd() * @see #getFrontEnd() * @see #getFullStack() */public class Developer { ...}3. 핵심 정리정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 그렇다고 하더라도 정적 팩터리를 사용하는 것이 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하는 습관이 있다면 고치자.4. Related Posts 불변 (Item 17) 싱글턴 (Item 3) 인스턴스화 불가 (Item 4) 인터페이스 기반 프레임워크 (Item 20) EnumSet 클래스 (Item 36) 리플랙션 (Item 65) 의존 객체 주입 (Item 5)" }, { "title": "Lambda Expression", "url": "/posts/lambda/", "categories": "Language, Java", "tags": "Java 8, Lambda, Method Reference", "date": "2022-04-05 22:58:00 +0900", "snippet": "Java 8부터 도입된 Lambda Expression(이하 람다식)의 개념과 사용 방법을 포스팅합니다.지난 Stream API, Functional Interface 포스팅에서도 람다식을 언급했습니다. 이처럼 람다식은 다양하게 활용되고 있는데요. 본문에서는 람다식에만 포커스를 맞춰 자세히 알아보겠습니다.람다식이란?람다식(Lambda Expression)이란 함수를 하나의 식으로 표현한 것입니다. 함수를 람다식으로 표현하면 메서드의 이름이 필요하지 않습니다. 때문에 람다식은 익명 함수(Anonymous Function)의 한 종류라고 볼 수 있습니다. 또한 이런 익명 함수는 모두 일급 객체이기 때문에, 람다식은 변수처럼 사용할 수 있으며 매개변수로 전달이 가능합니다.다음은 람다식 문법 구조입니다.(매개변수 목록) -&amp;gt; { 함수 바디 }람다식의 시작 부분에는 파라미터들을 명시할 수 있습니다. 비교적 엄격한 타입 제한을 두고 있는 자바지만, 람다식에서 파라미터의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다(추론할 수 없는 경우에는 타입을 명시해 주어야 합니다).기존의 메서드를 람다식으로 표현하는 예제를 알아보겠습니다. 다음은 두 정수를 입력받아 합을 구하는 sum 메서드를 람다식으로 표현한 것입니다.// 기존 메서드public int sum(int a, int b) { return a + b;}// 람다식 표현(a, b) -&amp;gt; a + b;다음 예제는 인자를 하나 받아 단순히 출력하는 메서드입니다.// 기존 메서드public void print(String s) { System.out.println(s);}// 람다식 표현s -&amp;gt; System.out.println(s);예제를 통해 알 수 있듯이 람다식을 사용하면 불필요한 코드를 줄이고 가독성을 높일 수 있습니다. 이것이 람다식이 등장하게 된 배경입니다. 기본 개념을 알아봤으니 다음으로 람다식의 특징과 장단점 그리고 작성 시 유의해야할 사항을 알아보겠습니다.특징 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주됩니다. 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없습니다.장점 코드를 간결하게 만들 수 있습니다. 개발자의 의도가 명확히 드러나 가독성이 높아집니다. 함수를 만드는 과정 없이 한 번에 처리할 수 있어 생산성이 높아집니다. 병렬 프로그래밍이 용이합니다. 지연 연산을 수행함으로써 불필요한 연산을 최소화할 수 있습니다.단점 람다를 사용하면서 만든 익명 함수는 재사용이 불가능합니다. 디버깅이 어렵습니다. 람다식을 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있습니다. 재귀 함수를 만드는 경우에 부적합합니다. 모든 엘리먼트를 순회하는 경우 단순 for문 또는 while문 보다 성능이 떨어집니다.람다식 작성 시 유의해야 할 사항먼저 람다식 작성 시 유의해야 할 사항들을 나열하고 위에서 제시했던 두 개의 예제를 다시 보겠습니다. 매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다. 함수의 몸체가 하나의 return 문으로만 이루어진 경우에는 중괄호를 생략할 수 없습니다. return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결괏값이 됩니다.위의 세 개의 항목은 sum 메서드에 적용됩니다. 람다식으로 만들면 (a, b) -&amp;gt; a + b이 된다고 했지만 사실 여기에는 생략된 것들이 있습니다.// 기존 메서드public int sum(int a, int b) { return a + b;}// 초기 람다식 표현(int a, int b) -&amp;gt; { return a + b; }// 매개변수 타입 생략, 중괄호 생략 불가(a, b) -&amp;gt; { return a + b; }// return문 대신 표현식 사용 (최종 람다식 표현)(a, b) -&amp;gt; a + b; 매개변수가 하나인 경우에는 괄호를 생략할 수 있습니다. 함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호를 생략할 수 있습니다.위의 두 항목과 맨 처음의 항목(매개변수 타입 생략)은 print 메서드에 적용됩니다.// 기존 메서드public void print(String s) { System.out.println(s);}// 초기 람다식 표현(int s) -&amp;gt; { System.out.println(s); }// 매개변수 타입 생략(s) -&amp;gt; { System.out.println(s); }// 괄호 생략s -&amp;gt; { System.out.println(s); }// 중괄호 생략 (최종 람다식 표현)s -&amp;gt; System.out.println(s);지금까지 람다식의 개념과 사용법을 알아봤습니다. 람다식은 함수를 간소화한 것이죠. 그런데 이런 람다식을 더욱 간소화하는 방법이 있습니다. 메서드 참조라는 것인데요. 아래에서 자세히 알아보겠습니다.메서드 참조메서드 참조란 말 그대로 메서드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내고, 람다식에서 불필요한 매개 변수를 제거하는 것을 말합니다.정적 메서드 참조정적 메서드를 참조할 경우에는 클래스 이름 뒤에 더블 콜론 연산자(::)를 붙이고 정적 메서드 이름을 기술하면 됩니다. 즉, “클래스::메서드”와 같이 사용합니다.public class Calculator { public static int staticSum(int x, int y) { return x + y; }}// 람다식(x, y) -&amp;gt; Calculator.staticSum(x, y)// 메서드 참조Calculator::staticSum인스턴스 메서드 참조인스턴스 메서드를 참조할 경우에는 먼저 객체를 생성한 다음 참조 변수 뒤에 더블 콜론 연산자(::)를 붙이고 인스턴스 메서드 이름을 기술하면 됩니다. 즉, “참조 변수::메서드”와 같이 사용합니다.public class Calculator { public int instanceSum(int x, int y) { return x + y; }}// 객체 생성Calculator cal = new Calculator();// 람다식(x, y) -&amp;gt; cal.instanceSum(x, y)// 메서드 참조cal::instanceSum매개변수의 메서드 참조위에서는 메서드가 모두 외부 클래스의 멤버였습니다. 이번에는 람다식의 매개 변수의 메서드를 참조하는 경우입니다.// 람다식(a, b) -&amp;gt; a.compareTo(b) // 메서드 참조String::compareTo생성자 참조생성자를 참조한다는 것은 객체를 생성하는 것입니다. 단순히 객체를 생성하고 인스턴스를 리턴하도록 구성된 람다식은 생성자 참조로 변환할 수 있습니다.// 람다식() -&amp;gt; new Calculator()// 메서드 참조Calculator::new지금까지 람다식에 대해 알아봤습니다. 람다식을 더 깊게 이해하고 싶다면 함수형 인터페이스를 알아야 합니다. Java의 람다식은 함수형 인터페이스를 반환하고, 이를 통해 람다식을 다룰 수 있기 때문입니다. 이에 대해서는 이전의 포스팅 Functional Interface를 참고하길 바랍니다.Related Posts Optional Functional Interface Stream API - 기본 Stream API - 고급Reference https://mangkyu.tistory.com/113 https://steady-coding.tistory.com/307 http://www.tcpschool.com/java/java_lambda_concept" }, { "title": "Stream API - 고급", "url": "/posts/stream-api-%EA%B3%A0%EA%B8%89/", "categories": "Language, Java", "tags": "Java 8, Stream API, Functional Interface, Lambda, Method Reference", "date": "2022-03-13 16:50:00 +0900", "snippet": "지난번의 기본편에 이어 고급편을 준비했다. 본편에서는 조금 더 복잡한 Stream API 메서드들과 성능, 주의할 점에 대해 자세히 알아본다.1. Parallel StreamStream API는 많은 양의 데이터를 처리하는 경우 런타임 성능을 높이기 위해 병렬 스트림(Parallel Stream)을 제공한다. Parallel Stream는 내부적으로 Java 7에서 도입된 Fork &amp;amp; Join을 사용하고 있다.List&amp;lt;String&amp;gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);// 병렬 스트림 생성Stream&amp;lt;String&amp;gt; parallelStream = strings.parallelStream();// 병렬 여부 확인System.out.println(parallelStream.isParallel()); // trueParallel Stream을 생성하기 위해서는 Collection의 메서드 parallelStream()을 사용하고 isParallel()메서드를 통해 병렬 여부를 확인할 수 있다. 이외에도 일반적인 순차 Stream으로 진행하던 중 parallel() 메서드를 사용해 일부 연산만을 병렬로 처리하게 할 수 있다.예제를 통해 어떻게 동작하는지 알아보자.Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;) .parallelStream() .map(str -&amp;gt; { System.out.format(&quot;map: %s [%s]\\n&quot;, str, Thread.currentThread().getName()); return str.toUpperCase(); }) .forEach(str -&amp;gt; { System.out.format(&quot;forEach: %s [%s]\\n&quot;, str, Thread.currentThread().getName()); });/* 실행 결과map: f [main]map: a [ForkJoinPool.commonPool-worker-13]map: d [ForkJoinPool.commonPool-worker-15]map: c [ForkJoinPool.commonPool-worker-3]map: b [ForkJoinPool.commonPool-worker-9]map: g [ForkJoinPool.commonPool-worker-11]map: h [ForkJoinPool.commonPool-worker-5]forEach: H [ForkJoinPool.commonPool-worker-5]map: e [ForkJoinPool.commonPool-worker-7]forEach: G [ForkJoinPool.commonPool-worker-11]forEach: B [ForkJoinPool.commonPool-worker-9]forEach: C [ForkJoinPool.commonPool-worker-3]forEach: D [ForkJoinPool.commonPool-worker-15]forEach: A [ForkJoinPool.commonPool-worker-13]forEach: F [main]forEach: E [ForkJoinPool.commonPool-worker-7]*/실행 결과를 통해 각 Stream 연산을 어느 스레드가 수행했는지 확인할 수 있다. 물론 어떤 스레드가 어떤 작업을 수행할지 비결정적이기 때문에 실행에 따라 출력은 달라 질 수 있다.Parallel Stream은 내부적으로 공용 ForkJoinPool을 사용하고 ForkJoinPool.commonPool()을 통해 사용 가능한 공용의 ForkJoinPool의 갯수를 확인할 수 있다. 해당 값은 사용 가능한 물리적인 CPU 코어 수에 따라 다르게 설정된다.위 예제는 7개의 ForkJoinPool로 실행되었고 그에 따라 7개의 worker 스레드가 동작한 것을 확인할 수 있다.ForkJoinPool commonPool = ForkJoinPool.commonPool();System.out.println(commonPool.getParallelism());/* 실행 결과7*/또한 이 값은 다음과 같은 JVM 매개변수를 통해 별도로 설정해 줄 수 있다.-Djava.util.concurrent.ForkJoinPool.common.parallelism=5Parallel Stream의 정렬Parallel Stream에서 정렬이 어떻게 동작하는지 확인해보기 위해 위의 예제코드에 정렬 메서드 sorted()를 추가했다.Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;) .parallelStream() .map(str -&amp;gt; { System.out.format(&quot;map: %s [%s]\\n&quot;, str, Thread.currentThread().getName()); return str.toUpperCase(); }) .sorted((s1, s2) -&amp;gt; { System.out.format(&quot;sort: %s ? %s [%s]\\n&quot;, s1, s2, Thread.currentThread().getName()); return s1.compareTo(s2); }) .forEach(str -&amp;gt; { System.out.format(&quot;forEach: %s [%s]\\n&quot;, str, Thread.currentThread().getName()); });/* 실행 결과map: h [main]map: a [ForkJoinPool.commonPool-worker-13]map: e [ForkJoinPool.commonPool-worker-15]map: f [ForkJoinPool.commonPool-worker-5]map: c [ForkJoinPool.commonPool-worker-11]map: b [ForkJoinPool.commonPool-worker-9]map: d [ForkJoinPool.commonPool-worker-3]map: g [ForkJoinPool.commonPool-worker-7]sort: B ? A [main]sort: C ? B [main]sort: D ? C [main]sort: E ? D [main]sort: F ? E [main]sort: G ? F [main]sort: H ? G [main]forEach: F [main]forEach: A [ForkJoinPool.commonPool-worker-13]forEach: C [ForkJoinPool.commonPool-worker-7]forEach: D [ForkJoinPool.commonPool-worker-5]forEach: B [ForkJoinPool.commonPool-worker-15]forEach: E [ForkJoinPool.commonPool-worker-9]forEach: G [ForkJoinPool.commonPool-worker-11]forEach: H [ForkJoinPool.commonPool-worker-3]*/Parallel Stream은 비결정적이기 때문에 실행할 때마다 출력이 다르게 나온다. 하지만 위의 예제를 실행해 보면 map과 forEach는 출력이 바뀌는데 sort는 항상 main 스레드에서 순차적으로 처리되는 것을 확인할 수 있다.이러한 이유는 Parallel Stream sort의 내부 동작 방식에 있다. 정렬하고자 하는 배열의 길이가 임계값(프로세스에게 할당 가능한 배열의 길이)보다 작으면 순차적인 정렬 방식인 Arrays.sort()를 사용하고, 그보다 크면 parallelSort()를 사용하도록 되어있다. 따라서 위의 예제에서는 배열크기가 작아 순차적으로 처리된 것이다.Parallel Stream에서 고려해야 할 사항Parallel Stream을 이용하면 임의로 스레드 개수를 조정할 수 있어 작업 처리 속도 향상을 기대할 수 있다. 하지만 여기에도 고려해야 할 사항은 있다.1) ForkJoinPool의 특성상 나누어지는 job은 균등하게 처리되어야 한다.Parallel Stream은 작업을 분할하기 위해 Spliterator의 trySplit()을 사용하는데, 이 분할되는 작업의 단위가 균등하게 나누어져야 하며 나누어지는 작업에 대한 비용이 높지 않아야 순차적 방식보다 효율적으로 처리할 수 있다. Array, ArrayList와 같이 정확한 전체 사이즈를 알 수 있는 경우에는 분할 처리가 빠르고 비용이 적게 들지만, LinkedList의 경우에는 별다른 효과를 찾기 어렵다.2) 병렬로 처리되는 작업이 독립적이지 않다면 수행 성능에 영향이 있을 수 있다.예를 들어 Stream의 중간 연산 중 sorted() 또는 distinct()와 같은 작업을 수행하는 경우에는 내부적으로 상태에 대한 변수를 각 작업들이 공유(synchronized)하게 되어 있다. 이러한 경우에는 순차적으로 실행하는 경우가 더 효과적일 수 있다.그렇다면 Parallel Stream은 언제 사용해야 할까?Parallel Stream은 앞서 설명한 ForkJoinPool 방식을 이용하기 때문에 분할이 잘 이루어질 수 있는 데이터 구조이거나, 작업이 독립적이면서 CPU 사용이 높은 작업에 적합하다고 볼 수 있다.2. FlatMap처리해야 하는 데이터가 2차원 배열 또는 2차원 리스트일 경우, 이를 1차원으로 처리해야 한다면 어떻게 해야 할까? map을 이용한다고 해도 2중 Stream의 형태로 처리될 것이다. 이렇게 중첩 구조를 한 단계 제거하기 위해 사용되는 중간 연산이 flatMap이다.인자로 반환형이 Stream인 함수형 인터페이스 Function을 받는다. 즉, flatmap은 중첩된 Stream 구조에서 한 단계 제거하여 새로운 Stream을 생성하고 반환하는 것이다. 이런 작업을 ‘플래트닝(Flattening)’이라고 한다.&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper);// 2차원 배열String[][] strings = { {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;}};Stream&amp;lt;String&amp;gt; stringStream1 = Arrays.stream(strings) .flatMap(Arrays::stream);// 2중 리스트List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; listList = Arrays.asList( Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), Arrays.asList(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;));Stream&amp;lt;String&amp;gt; stringStream2 = listList.stream() .flatMap(Collection::stream);2차원 배열과 2중 리스트를 1차원 Stream으로 Flattening 했다. Stream의 요소는 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]가 된다.FlatMap 활용 예제이름과 책 리스트를 가지는 Developer 클래스가 있다.public class Developer { private String name; private Set&amp;lt;String&amp;gt; books; public void addBook(String book) { if (this.books == null) { this.books = new HashSet&amp;lt;&amp;gt;(); } this.books.add(book); } // Getter, Setter, ToString 생략}Developer 객체들에 저장된 모든 book 리스트에서 ‘python’을 포함하지 않는 책들을 반환하고자 한다.Developer o1 = new Developer();o1.setName(&quot;heung&quot;);o1.addBook(&quot;Java 8 in Action&quot;);o1.addBook(&quot;Spring Boot in Action&quot;);o1.addBook(&quot;Effective Java (3nd Edition)&quot;);Developer o2 = new Developer();o2.setName(&quot;tack&quot;);o2.addBook(&quot;Learning Python, 5th Edition&quot;);o2.addBook(&quot;Effective Java (3nd Edition)&quot;);List&amp;lt;Developer&amp;gt; list = Arrays.asList(o1, o2);Set&amp;lt;String&amp;gt; collect = list.stream() // Stream&amp;lt;Developer&amp;gt; .map(Developer::getBook) // Stream&amp;lt;Set&amp;lt;String&amp;gt;&amp;gt; .flatMap(Collection::stream) //Stream&amp;lt;String&amp;gt; .filter(x -&amp;gt; !x.toLowerCase().contains(&quot;python&quot;)) .collect(Collectors.toSet());collect.forEach(System.out::println);/* 실행 결과Spring Boot in ActionEffective Java (3nd Edition)Java 8 in Action*/먼저 Developer List Stream에서 map을 사용해 books(Set)를 꺼낸다. 다음 flatMap을 사용해 Set Stream에서 String Stream으로 변환하고 ‘python’을 포함하는 책을 필터링한 결과를 Set으로 반환한다. (같은 책 중복 제거)3. Reduce누산기(Accumulator)와 연산(Operation)으로 컬렉션에 있는 값을 처리하여 더 작은 컬렉션이나 단일 값을 만드는 작업이다.reduce는 여러 요소들을 통해 새로운 결과를 만들어내는데, 최대 3가지의 매개변수를 받을 수 있다. Accumulator : 각 요소를 계산한 중간 결과를 생성 Identity : 계산을 처리하기 위한 초기값 Combiner : Parlallel Stream에서 나누어 계산한 결과를 하나로 합치기 위한 로직3.1 reduce(accumulator)Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);BinaryOperator 타입의 accumulator를 매개변수로 받는다. BinaryOperator&amp;lt;T&amp;gt;는 같은 타입의 인자 2개를 받아 동일한 타입의 결과를 반환하는 함수형 인터페이스이다.accumulator를 수행하고 Optional 타입의 계산 결과를 반환한다. Stream이 비어있을 경우 값을 계산할 수 없기 때문에 Optional을 반환하는 것이다.IntStream intStream = IntStream.range(1, 5); // 1, 2, 3, 4OptionalInt optionalInt = intStream.reduce(Integer::sum);System.out.println(optionalInt.orElse(0));/* 실행 결과10*/3.2 reduce(identity, accumulator)T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);Generic 타입의 identity와 BinaryOperator를 매개변수로 받는다. identity는 계산을 처리하기 위한 초기값을 의미한다.매개변수 1개를 갖는 reduce와 달리 초기값이 세팅되기 때문에 Optional이 아닌 Generic 타입의 결과를 반환한다.IntStream intStream = IntStream.range(1, 5); // 1, 2, 3, 4int result = intStream.reduce(10, Integer::sum);System.out.println(result);/* 실행 결과20*/3.3 reduce(identity, accumulator, combiner)&amp;lt;U&amp;gt; U reduce(U identity, BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator, BinaryOperator&amp;lt;U&amp;gt; combiner);identity와 BiFunction 타입의 accumulator, BinaryOperator타입의 combiner를 매개변수로 받는다.BiFunction은 2개의 파라미터 타입과 1개의 반환형 모두 서로 다른 Generic 타입을 가질 수 있다.@FunctionalInterfacepublic interface BiFunction&amp;lt;T, U, R&amp;gt; { R apply(T t, U u); default &amp;lt;V&amp;gt; BiFunction&amp;lt;T, U, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after) { Objects.requireNonNull(after); return (T t, U u) -&amp;gt; after.apply(apply(t, u)); }}하지만 BinaryOperator는 BiFunction을 구현(implements)하여 2개의 파라미터 타입과 1개의 반환형 모두 같은 Generic 타입을 갖는다.@FunctionalInterfacepublic interface BinaryOperator&amp;lt;T&amp;gt; extends BiFunction&amp;lt;T,T,T&amp;gt; { public static &amp;lt;T&amp;gt; BinaryOperator&amp;lt;T&amp;gt; minBy(Comparator&amp;lt;? super T&amp;gt; comparator) { Objects.requireNonNull(comparator); return (a, b) -&amp;gt; comparator.compare(a, b) &amp;lt;= 0 ? a : b; } public static &amp;lt;T&amp;gt; BinaryOperator&amp;lt;T&amp;gt; maxBy(Comparator&amp;lt;? super T&amp;gt; comparator) { Objects.requireNonNull(comparator); return (a, b) -&amp;gt; comparator.compare(a, b) &amp;gt;= 0 ? a : b; }}새롭게 추가된 BinaryOperator타입의 combiner는 병렬 처리 시에 각 스레드에서 만들어진 결과를 합치는 작업을 수행한다. 때문에 combiner을 추가하여도 ParallelStream으로 실행하지 않으면 combiner은 호출되지 않는다.int result = Stream.of(1, 2, 3) .reduce(10, Integer::sum, (a, b) -&amp;gt; { System.out.println(&quot;combiner was called&quot;); return a + b; });System.out.println(result);/* 실행 결과16*/위의 예제는 Parallel Stream이 아니기 때문에 combiner was called가 출력되지 않는다. 다음 예제를 보자.int result = Stream.of(1, 2, 3) .parallel() .reduce(10, Integer::sum, (a, b) -&amp;gt; { System.out.println(&quot;combiner was called&quot;); return a + b; });System.out.println(result);/* 실행 결과combiner was calledcombiner was called36*/parallel 메서드를 사용해 스트림이 병렬로 처리되도록 하고 reduce를 실행했다. 결과를 보면 combiner가 두 번 실행된 것을 확인할 수 있다. 그 이유는 Stream의 각 요소(1, 2, 3)가 병렬로 처리되고, 처리된 결과를 하나의 결과값으로 만드는 연산이 두 번 발생하기 때문이다.즉, 병렬로 처리된 11(10+1), 12(10+2), 13(10+3)에서 역순으로 13 + 12를 먼저 더하고 25 + 11을 더해 combiner가 총 2번 호출되며 최종적으로 36이라는 결과를 만들어 낸다. 초기값(10) 또한 병렬로 발생하는 것을 주의하자.int result = 10 + Stream.of(1, 2, 3) .parallel() .reduce(0, Integer::sum, (a, b) -&amp;gt; { System.out.println(&quot;combiner was called&quot;); return a + b; });System.out.println(result);/* 실행 결과combiner was calledcombiner was called16*/초기값이 한 개만 필요할 경우, 위와같이 identity는 0을 넘기고 reduce의 계산된 결과값에 초기값을 더해야 한다.여기서 또 주목해야 할 것은 병렬 스트림의 경우 combiner라는 추가 연산이 발생한다는 것이다. 때문에 간단한 작업에 병렬 연산을 적용하면 오리혀 처리 속도가 느려질 수 있음을 고려해야 한다.4. Null-Safe StreamJava를 이용해 개발을 하다 보면 NPE(NullPointException)가 자주 발생한다. 물론 NPE를 방지하기 위해 null 여부를 검사하는 로직을 작성해 줄 수 있지만 이러한 코드는 가독성이 떨어진다.이 문제를 해결하기 위해 Java 8에서부터는 Optional이라는 Wrapper 클래스를 제공한다. Stream API 역시 이 Optional의 도움을 받아 Null-Safe한 Stream을 생성할 수 있다.(Optional에 대해 잘 알지 못한다면 이전의 Optional 포스팅을 참고하길 바란다.)public &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; collectionToStream(Collection&amp;lt;T&amp;gt; collection) { return Optional.ofNullable(collection) .map(Collection::stream) .orElseGet(Stream::empty);}위 코드는 컬렉션을 인자로 받아 Optional 객체로 만들고 Stream 생성 후 리턴하는 메서드이다. 만약 컬렉션이 null인 경우 Empty Stream을 반환한다.List&amp;lt;String&amp;gt; nullList = null;// NPE 발생nullList.stream() .map(String::length) .forEach((System.out::println)); // NPENPE가 발생하는 상황을 가정해보았다. null의 Stream을 생성하려고 하니 당연히 NPE가 발생한다.List&amp;lt;String&amp;gt; nullList = null;// Empty Stream으로 처리collectionToStream(nullList) .map(String::length) .forEach(System.out::println); // []우리가 만든collectionToStream() 메서드를 사용하면 NPE가 발생하는 대신 Empty Stream으로 작업을 마칠 수 있다.5. 실행 순서Stream API는 실행 순서를 고려하지 않고 잘 못 사용하면 처리 속도의 지연을 야기할 수 있다. 때문에 작성한 Stream API 코드가 정확히 어떻게 동작하는지 이해하는 것이 중요하다.Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) .filter(str -&amp;gt; { System.out.println(&quot;filter: &quot; + str); return true; }) .forEach(str -&amp;gt; { System.out.println(&quot;forEach: &quot; + str); });/* 실행 결과filter: aforEach: afilter: bforEach: bfilter: cforEach: cfilter: dforEach: d*/실행 결과를 보면 모든 요소에 대해 filter가 진행되고 forEach가 실행되는 수평적 구조로 처리하는 것이 아니라, 각각의 요소에 대해 filter와 forEach가 먼저 수행되는 수직적 구조로 처리하는 것을 알 수 있다.boolean result = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) .map(str -&amp;gt; { System.out.println(&quot;map: &quot; + str); return str.toUpperCase(); }) .anyMatch(str -&amp;gt; { System.out.println(&quot;anyMatch: &quot; + str); return str.startsWith(&quot;A&quot;); });/* 실행 결과map: aanyMatch: A*/위의 예제는 Stream의 각 요소를 대문자로 변환하고, 변환된 데이터 중 “A”로 시작하는 문자열이 있는지 검사하는 로직이다. 만약 Stream의 연산이 수평적 구조로 처리된다면 위의 결과는 map 4번(a, b, c, d) + anyMatch 1번(a) 실행될 것이다. 하지만 실제로 연산은 수직적 구조로 처리되기 때문에 map 1번 + anyMatch 1번 실행된 것을 확인할 수 있다.이러한 처리 방식은 연산의 실행 순서에 따라 전체 연산의 수가 달라지고, 이는 곧 성능에 영향을 미치게 된다. 다음 예제를 통해 자세히 알아보자.Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) .map(str -&amp;gt; { System.out.println(&quot;map: &quot; + str); return str.toUpperCase(); }) .filter(str -&amp;gt; { System.out.println(&quot;filter: &quot; + str); return str.startsWith(&quot;A&quot;); }) .forEach(str -&amp;gt; { System.out.println(&quot;forEach: &quot; + str); });/* 실행 결과map: afilter: AforEach: Amap: bfilter: Bmap: cfilter: Cmap: dfilter: D*/실행 결과를 보면, map과 filter는 Stream의 요소 수 만큼(4번) 호출되었고 forEach는 1번만 호출되었다. filter를 통과한 A라는 문자열에 대해서만 실행된 것이다. 그렇다면 filter를 맨 앞으로 당기면 어떻게 될까.Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) .filter(str -&amp;gt; { System.out.println(&quot;filter: &quot; + str); return str.startsWith(&quot;a&quot;); }) .map(str -&amp;gt; { System.out.println(&quot;map: &quot; + str); return str.toUpperCase(); }) .forEach(str -&amp;gt; { System.out.println(&quot;forEach: &quot; + str); });/* 실행 결과filter: amap: aforEach: Afilter: bfilter: cfilter: d*/위와 같이 수정된 코드는 filter가 5번, map과 forEach가 각각 1번씩 호출되었다. 동일한 입력과 결과에 대해 더 적은 연산으로 처리할 수 있게 된 것이다. 위의 예제는 간단한 예제이기 때문에 연산 횟수에 큰 차이가 없다. 하지만 처리해야 하는 데이터가 많아질수록 그만큼 큰 성능의 차이를 야기할 것이다. 때문에 Stream API를 사용할 때는 반드시 실행 순서를 고려하여 코드를 작성해야 한다.6. 지연 처리Stream의 연산은 최종 결과가 만들어 질 때 수행된다. 즉, 결과를 만드는 최종 작업이 수행되지 않는다면 중간 연산은 아무런 동작을 하지 않는다.다음은 호출 횟수를 카운트하는 예제이다.private long counter;private void wasCalled() { counter++;}counter = 0;Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) .stream() .map(str -&amp;gt; { wasCalled(); return str.toUpperCase(); });System.out.println(counter);/* 실행 결과0*/위의 예제는 Stream이 5개의 요소를 가지고 있기 때문에 wasCalled()가 5번 호출되어 5가 출력될 것으로 예상된다. 하지만 예상과 달리 0이 출력된다. 그 이유는 Stream의 최종 작업이 실행되지 않아 실제로 아무런 동작을 하지 않았기 때문이다.최종 작업으로 collect 메서드를 넣은 후 실행 결과를 확인해 보자.counter = 0;List&amp;lt;String&amp;gt; strings = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) .stream() .map(str -&amp;gt; { wasCalled(); return str.toUpperCase(); }) .collect(Collectors.toList());System.out.println(counter);/* 실행 결과5*/이제 처음 예상한 대로 5가 출력되는 것을 확인할 수 있다.Related Posts Stream API - 기본 Optional Functional InterfaceReference https://mangkyu.tistory.com/112 https://futurecreator.github.io/2018/08/26/java-8-streams/ https://m.blog.naver.com/tmondev/220945933678 https://hbase.tistory.com/171 https://12bme.tistory.com/461 https://velog.io/@foeverna/Java-513-%EC%8A%A4%ED%8A%B8%EB%A6%BC-API-Stream-API https://mkyong.com/java8/java-8-flatmap-example/" }, { "title": "Functional Interface", "url": "/posts/functional-interface/", "categories": "Language, Java", "tags": "Java 8, Functional Interface, Abstract Method, Lambda, Method Reference", "date": "2022-02-27 21:50:00 +0900", "snippet": "Java는 함수형 프로그래밍 언어가 아닌 객체지향 언어이기 때문에 함수는 일급 객체가 아니다. 그러나 Java 8에서 추가된 Functional Interface(이하 함수형 인터페이스)를 사용하면 일급 객체처럼 다룰 수 있다.본문에서 함수형 인터페이스에 대해 자세히 알아보자. 일급 객체(First-class citizen)란? 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체이다. 즉, 아래의 조건을 만족하는 객체를 말한다. 변수에 할당할 수 있다. 함수를 인자로 전달받을 수 있다. 함수의 결과로서 리턴될 수 있다. 함수형 인터페이스란?추상 메서드가 하나만 존재하는 인터페이스를 말한다. 예를 들면 아래와 같은 인터페이스가 있다.public interface FunctionalInterface { public abstract int plus(int n1, int n2);}함수형 인터페이스를 사용하는 이유는 자바의 람다식이 함수형 인터페이스로만 접근 가능하기 때문이다.public interface FunctionalInterface { int plus(int n1, int n2); // public abstract 생략}FunctionalInterface func = (n1, n2) -&amp;gt; n1 + n2;func.plus(1, 3)이렇게 람다식으로 생성된 순수 함수를 변수로 선언할 수 있게 되어 더욱 간결한 코드를 작성할 수 있다. 순수 함수란? 부수효과가 없는 함수이다. 즉, 아래의 조건을 만족하는 함수를 말한다. 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수 외부 상태에 의존하지 않는 함수 외부의 상태를 변경하지 않는 함수 생성@FunctionalInterface를 사용해 만들 수 있다. 이 어노테이션은 해당 인터페이스가 함수형 인터페이스 조건에 맞는지 검사해 준다.그런데 위의 예제에서는 @FunctionalInterface이 없었지만 제대로 동작했다. @FunctionalInterface 이 없어도 조건에 맞는다면 함수형 인터페이스로 동작하고 사용하는 데는 문제없다. 하지만 함수형 인터페이스 검증과 유지 보수를 위해 꼭 붙여주도록 하자.@FunctionalInterfacepublic interface CustomInterface&amp;lt;T&amp;gt; { T call(); default void printDefault() { System.out.println(&quot;It is default method&quot;); } static void printStatic() { System.out.println(&quot;It is static method&quot;); }}이 예제에서는 메서드가 여러 개 선언되었다. 함수형 인터페이스는 메서드가 한 개라고 하지 않았나?오해하지 말자.함수형 인터페이스는 ‘추상’ 메서드가 하나이다. default method 또는 static method 는 여러 개 존재해도 상관 없다. 위의 예제에서는 call() 이라는 abstract method가 하나 그리고 default method와 static method가 하나씩 선언 되었다.사용CustomInterface&amp;lt;String&amp;gt; func = () -&amp;gt; &quot;It is abstract method&quot;;System.out.println(func.call());func.printDefault();CustomInterface.printStatic();/* 실행 결과It is abstract methodIt is default methodIt is static method*/선언했던 call()이라는 추상 메서드가 람다식 () -&amp;gt; &quot;It is abstract method&quot;과 매핑된다.주의해야 할 점은 반환형과 매개변수이다. 서로가 매핑되어야 하기 때문에 추상 메서드와 람다식의 매개변수, 반환형이 같아야 한다.Java에서 제공하는 함수형 인터페이스매번 함수형 인터페이스를 만들어서 사용하는 것은 상당히 번거로운 일이다. Java에는 자주 사용될 것 같은 함수형 인터페이스가 이미 정의되어 있다. Supplier&amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; Function&amp;lt;T, R&amp;gt; Predicate&amp;lt;T&amp;gt;이외에도 다양한 함수형 인터페이스가 제공된다. 자세한 정보는 패키지 java.util.function에 정의되어 있다.이제 위의 함수형 인터페이스를 하나씩 살펴보자. 아래의 코드들은 실제 구현되어 있는 코드이다.1. Supplier&amp;lt;T&amp;gt;package java.util.function;@FunctionalInterfacepublic interface Supplier&amp;lt;T&amp;gt; { T get();}Supplier는 매개변수를 가지지 않고 반환값이 Generic 타입의 객체인 추상 메서드 get이 정의되어 있다.사용 예시Supplier&amp;lt;String&amp;gt; supplier = () -&amp;gt; &quot;Hello Supplier&quot;;System.out.println(supplier.get());/* 실행 결과Hello Supplier*/공급자라는 이름처럼 아무런 인자를 받지 않고 특정 객체를 리턴한다.2. Consumer&amp;lt;T&amp;gt;package java.util.function;import java.util.Objects;@FunctionalInterfacepublic interface Consumer&amp;lt;T&amp;gt; { void accept(T t); default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after) { Objects.requireNonNull(after); return (T t) -&amp;gt; { accept(t); after.accept(t); }; }}Consumer는 매개변수로 Generic 타입의 객체를 가지고 반환값은 없는 추상 메서드 accept가 정의되어 있다. 추가로 andThen이라는 default method를 제공하는데 이는 하나의 Consumer가 처리된 후 연쇄적으로 다음 Consumer가 동작하게 한다.사용 예시Consumer&amp;lt;String&amp;gt; consumer = str -&amp;gt; System.out.println(str.split(&quot; &quot;)[0]);Consumer&amp;lt;String&amp;gt; after = str -&amp;gt; System.out.println(str);consumer.andThen(after).accept(&quot;Hello Consumer&quot;);/* 실행 결과HelloHello Consumer*/먼저 accept를 통해 전달받은 인자로 consumer를 처리하고, 다음으로 두 번째 Consumer인 after를 처리한다.3. Function&amp;lt;T, R&amp;gt;package java.util.function;import java.util.Objects;@FunctionalInterfacepublic interface Function&amp;lt;T, R&amp;gt; { R apply(T t); default &amp;lt;V&amp;gt; Function&amp;lt;V, R&amp;gt; compose(Function&amp;lt;? super V, ? extends T&amp;gt; before) { Objects.requireNonNull(before); return (V v) -&amp;gt; apply(before.apply(v)); } default &amp;lt;V&amp;gt; Function&amp;lt;T, V&amp;gt; andThen(Function&amp;lt;? super R, ? extends V&amp;gt; after) { Objects.requireNonNull(after); return (T t) -&amp;gt; after.apply(apply(t)); } static &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; identity() { return t -&amp;gt; t; }}Function은 매개변수와 반환형으로 Generic 타입의 객체를 가지는 apply가 정의되어 있다. 또한 Consumer와 마찬가지로 andThen이 제공되고 추가적으로 compose와 identity가 제공된다. compose는 andThen과 반대로 첫 번째 Function이 실행되기 이전에 인자로 받은 Function을 먼저 처리한다. identity는 자기 자신을 반환하는 static method이다.사용 예시Function&amp;lt;String, Integer&amp;gt; function = str -&amp;gt; str.length();Function&amp;lt;String, String&amp;gt; before = str -&amp;gt; str.split(&quot; &quot;)[0];Function&amp;lt;Integer, Integer&amp;gt; after = num -&amp;gt; num * num;int result = function.compose(before).andThen(after).apply(&quot;Hello Function&quot;);System.out.println(result);/* 실행 결과25*/compose를 통해 첫 번째 function이 처리되기 전에 before가 먼저 처리된다. 다음으로 function이 실행되고, 마지막으로 andThen으로 받은 after가 처리된다. (Hello Function =&amp;gt; Hello =&amp;gt; 5 =&amp;gt; 25)4. Predicate&amp;lt;T&amp;gt;package java.util.function;import java.util.Objects;@FunctionalInterfacepublic interface Predicate&amp;lt;T&amp;gt; { boolean test(T t); default Predicate&amp;lt;T&amp;gt; and(Predicate&amp;lt;? super T&amp;gt; other) { Objects.requireNonNull(other); return (t) -&amp;gt; test(t) &amp;amp;&amp;amp; other.test(t); } default Predicate&amp;lt;T&amp;gt; negate() { return (t) -&amp;gt; !test(t); } default Predicate&amp;lt;T&amp;gt; or(Predicate&amp;lt;? super T&amp;gt; other) { Objects.requireNonNull(other); return (t) -&amp;gt; test(t) || other.test(t); } static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&amp;gt; targetRef.equals(object); } @SuppressWarnings(&quot;unchecked&quot;) static &amp;lt;T&amp;gt; Predicate&amp;lt;T&amp;gt; not(Predicate&amp;lt;? super T&amp;gt; target) { Objects.requireNonNull(target); return (Predicate&amp;lt;T&amp;gt;)target.negate(); }}Predicate는 매개변수로 Generic 타입의 객체를 가지고 반환값으로 boolean을 반환하는 test가 정의되어 있다. 또한 추가적으로 and, negate, or, isEqual, not을 제공한다. 각 메서드는 논리 연산과 비교 연산을 구현하고 있다.사용 예시Predicate&amp;lt;Integer&amp;gt; isBiggerThanFive = num -&amp;gt; num &amp;gt; 5;Predicate&amp;lt;Integer&amp;gt; isLowerThanFive = num -&amp;gt; num &amp;lt; 5;boolean result1 = isBiggerThanFive.and(isLowerThanFive).test(10);boolean result2 = isBiggerThanFive.or(isLowerThanFive).test(10);System.out.println(result1);System.out.println(result2);/* 실행 결과falsetrue*/test를 통해 10과 5를 비교하고 and 연산과 or 연산을 적용해 보았다.Reference https://mangkyu.tistory.com/113 https://zzang9ha.tistory.com/303 https://bcp0109.tistory.com/313 https://codechacha.com/ko/java8-functional-interface/ https://jeong-pro.tistory.com/23" }, { "title": "Cookie &amp; Session", "url": "/posts/cookie-session/", "categories": "Web", "tags": "HTTP, Cookie, Session", "date": "2022-02-25 23:01:00 +0900", "snippet": "웹 서버 개발에 기본적인 개념인 Cookie(쿠키)와 Session(세션)에 대해 정리한다.들어가기 전에 웹 통신에 사용되는 프로토콜인 HTTP의 특징을 알아보고 쿠키와 세션이 필요한 이유를 먼저 이해하자.HTTP의 특징- 비연결성(Connectionless)클라이언트에서 서버에 요청을 보내면 서버는 클라이언트에 응답을 하고 연결을 끊어 버린다.- 무상태(Stateless)요청에 응답하고 연결을 끊기 때문에 서버는 클라이언트의 상태를 저장하지 않는다.이러한 특징 때문에 서버는 같은 사용자(클라이언트)가 보내는 요청도 매번 새로운 사용자로 인식하게 되는 문제가 있다.그런데 우리가 사용하는 웹사이트를 생각해 보자. 로그인을 한 번 하고 나면 그 사이트에서는 다시 로그인할 필요가 없이 여러 페이지의 다양한 기능을 이용할 수 있다. 마치 서버가 사용자의 정보를 유지하고 있는 것처럼 보인다.이처럼 HTTP의 비연결성과 무상태를 보완하여 Statefule한 서비스를 제공하기 위해 사용하는 것이 쿠키와 세션이다.HTTP 통신을 사용하는 이유HTTP를 사용하여 Stateful한 서비스를 제공하기 위해 쿠키와 세션을 이용한다고 했다. 그렇다면 굳이 Stateless한 HTTP 통신을 사용하는 이유는 뭘까. 애초에 Stateful한 통신 방법을 사용하면 되지 않나?이 의문의 답은 서버의 확장성에 있다.사용자가 늘어나 증가한 트래픽을 분산하기 위해 scale out하는 경우를 생각해 보자.Stateful 서버는 메모리에 사용자의 정보를 저장한다. 추가되는 새로운 서버에는 사용자의 정보가 저장되어 있지 않기 때문에 정상적인 응답이 불가능하다. (방법이 없는 것은 아니지만 구현하기 까다롭다고 한다)Stateless 서버는 외부 저장소에 사용자의 정보를 저장한다. 새로운 서버가 추가된다고 하더라도 외부 저장소에서 사용자의 정보를 불러와 사용할 수 있기 때문에 정상적인 응답이 가능하다. 그러나 Stateless가 장점만 가지고 있는 것은 아니다. 서버로 요청을 보낼 때, 매 요청 시마다 상태 정보를 전달해야 하기 때문에 그만큼 네트워크 리소스를 소모하게 된다. Stateful와 Stateless에 대한 자세한 내용은 추후 다른 포스팅에서 정리한다.Cookie (쿠키)쿠키는 웹 브라우저에 저장되는 Key-Value 쌍의 작은 데이터 파일이다. 사용자의 정보를 저장하기 위한 임시 파일로, 서버로 요청을 보낼 때 함께 보내고 응답을 받을 때 함께 전달받아 사용자의 정보를 이어나간다.구성 요소 이름(name) : 각각의 쿠키를 구별하는 데 사용되는 이름 값(value) : 쿠키의 이름과 관련된 값 유효시간(expire) : 쿠키의 유지시간 도메인(domain) : 쿠키를 전송할 도메인 경로(path) : 쿠키를 전송할 요청 경로특징 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다. 클라이언트에 총 300개의 쿠키를 저장할 수 있다. 하나의 도메인 당 20개의 쿠키를 가질 수 있다. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.동작 과정 클라이언트가 페이지를 요청한다. (사용자가 웹 사이트 접근) 서버는 쿠키를 생성한다. 생성한 쿠키에 사용자 정보를 담아 클라이언트에게 전달한다. (HTTP 헤더에 포함됨) 전달받은 쿠키는 클라이언트 PC에 저장된다. 이후 다시 서버에 요청을 보낼 때 쿠키를 함께 전달한다. (브라우저에 의해 자동 처리) 서버는 전달받은 쿠키를 이용하여 해당 요청을 처리하고 응답한다.사용 예시 ID 저장, 로그인 상태 유지 팝업창 일주일간 다시 보지 않기 최근 검색한 상품들을 광고에서 추천 쇼핑몰 장바구니 기능한계 서버가 가지고 있는 것이 아니라 사용자 측에 저장되기 때문에, 정보를 임의로 고쳐 사용할 수 있어 악용이 가능하다. 요청 정보는 가로채기 쉽기 때문에 보안이 취약하다.이러한 단점을 보완해 주는 것이 세션이다.Session (세션)보안이 취약하다는 쿠키의 한계를 극복하기 위해 사용한다. 쿠키를 기반으로 동작하지만, 쿠키와 달리 사용자의 정보를 클라이언트 측이 아닌 서버 측에서 관리한다. 클라이언트는 서버로부터 세션 정보를 찾기 위한 세션 ID만 전달받는다. 세션 정보를 저장하는 장소는 서버의 메모리 일 수도 있지만 다중 서버 환경에서는 외부 저장소를 사용한다.특징 각 클라이언트에게 고유 ID를 부여한다. 서버는 세션 ID로 클라이언트를 구분하고 클라이언트의 요구에 맞는 서비스를 제공한다. 세션 ID는 웹 브라우저당 한 개씩 생성되어 웹 컨테이너에 저장되며 브라우저 종료 시 소멸된다. 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않도록 설정이 가능하다. 클라이언트는 고유 ID만 가지고 있고 사용자에 대한 정보를 서버에 두기 때문에 비교적 보안이 좋다.동작 과정 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근) 서버는 세션 ID를 만들고 해당 사용자의 정보를 세션 ID와 함께 저장한다. 생성한 세션 ID를 쿠키에 담아 클라이언트에게 전달한다. (HTTP 헤더에 포함됨) 전달받은 쿠키는 클라이언트 PC에 저장된다. 이후 다시 서버에 요청할 때 요청과 쿠키를 함께 전달한다. (브라우저에 의해 자동 처리) 서버는 전달받은 쿠키에 있는 세션 ID를 활용하여 사용자 정보를 불러온다. 불러온 사용자 정보를 통해 해당 요청을 처리하고 응답한다.한계 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다. 동접자 수가 많은 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다.Cookie vs Sessoin   쿠키 (Cookie) 세션 (Session) 저장 위치 클라이언트(=사용자 PC) 웹 서버 저장 형식 text Object 만료 시점 쿠키 저장시 설정 (브라우저가 종료되어도 만료시점이 지나지않으면 자동삭제되지 않음) 브라우저 종료시 삭제 (기간 지정 가능) 사용하는 자원(리소스) 클라이언트 리소스 웹 서버 리소스 용량 제한 총 300개 하나의 도메인 당 20개하나의 쿠키 당 4KB(=4096byte) 서버가 허용하는 한 용량제한 없음 속도 상대적으로 빠름 상대적으로 느림 보안 상대적으로 나쁨 상대적으로 좋음 쿠키/세션 방식은 서버에서 추가적인 저장 공간이 필요하고 부하도 높아진다. 또한 해커가 HTTP 요청을 가로챘을 경우, 그 안에 있는 쿠키를 이용해 HTTP 요청을 보낼 수 있다.(세션 하이재킹 공격이라고 한다)최근에는 이런 문제들을 보완한 토큰 기반의 인증 방식을 사용하는 추세이다. 그중 JWT(Json Web Token)에 대해 다음 포스팅에서 자세히 다뤄본다.Reference https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2# https://junhyunny.github.io/information/cookie-and-session/ https://junshock5.tistory.com/83 https://devuna.tistory.com/23 https://hahahoho5915.tistory.com/32" }, { "title": "Stream API - 기본", "url": "/posts/stream-api-%EA%B8%B0%EB%B3%B8/", "categories": "Language, Java", "tags": "Java 8, Stream API, Functional Interface, Lambda, Method Reference", "date": "2022-02-23 22:55:00 +0900", "snippet": "Stream API란?Stream API는 데이터를 추상화하고 처리하는데 자주 사용되는 함수들을 정의해둔 API이며 Java 8에서 추가되었다.여기서 데이터를 추상화하였다는 것은 데이터의 종류와 관계없이 같은 방식으로 데이터를 처리할 수 있다는 것을 의미한다.Java 8 이전에는 배열 또는 컬렉션 인스턴스를 다루기 위해 for 또는 while 문을 돌려 요소를 하나씩 꺼내 연산을 수행했다. 이러한 방법은 간단한 경우라면 문제가 되지 않지만 로직이 복잡해질수록 코드의 양도 많아지고 여러 로직이 섞여 가독성도 떨어진다.Stream API는 반복 문법을 메서드 내부에 숨긴 ‘내부 반복’을 사용해 이를 보완한다. 또한 배열 또는 컬렉션 인스턴스에 여러 개의 함수를 조합하고 필터링해 가공된 결과를 얻을 수 있다. 즉, 배열과 컬렉션을 함수형으로 처리할 수 있게 되는 것이다.정리하면 다음과 같은 장점을 가지고 있다. 유연하다. 데이터를 추상화하고 함수를 조합하는 방식으로 데이터를 처리하기 때문에 변하는 요구사항에 쉽게 대응할 수 있다. 가독성이 높다. 람다식 또는 메서드 참조를 이용해 간결하고 명확하게 표현할 수 있다. 병렬 처리가 쉽다. 멀티 스레드 코드를 직접 구현하지 않고 내부 반복을 통해 간단하게 처리할 수 있다. 특징1. 데이터 원본을 유지한다.Stream API는 원본 데이터를 조회하여 원본 데이터가 아닌 별도의 요소들로 Stream을 생성한다. 때문에 원본 데이터로부터 읽기만 할 뿐 정렬이나 필터링 등의 작업은 별도의 Stream 요소들에서 처리된다.List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5);List&amp;lt;Integer&amp;gt; sortedList = list.stream() .sorted(Comparator.reverseOrder()) .collect(Collectors.toList());System.out.println(sortedList);System.out.println(list);/* 실행 결과[5, 4, 3, 2, 1][1, 2, 3, 4, 5]*/Stream을 통해 원본 데이터 [1, 2, 3, 4, 5]를 정렬하고 sortedList에 저장했다. 실행 결과를 보면 정렬이 잘 수행되었고 원본 데이터는 변경되지 않는 것을 확인할 수 있다.2. 일회용이다.Stream API는 일회용이기 때문에 한번 사용이 끝나면 재사용이 불가능하다.List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5);Stream&amp;lt;Integer&amp;gt; integerStream = list.stream();int result = integerStream.reduce(0, Integer::max);System.out.println(result);System.out.println(integerStream.reduce(0, Integer::max));/* 실행 결과5Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed...*/list의 Stream인 integerStream를 통해 list의 최댓값을 추출했다. 그리고 다시 integerStream를 사용해 같은 연산을 수행했다. 실행 결과로 list의 최댓값 5가 출력된 후 IllegalStateException이 발생했다. 이는 integerStream이 이미 사용되고 닫힌 후 재사용하려고 했기 때문이다. 같은 Stream이 필요하다면 다시 생성해 주어야 한다.3. 내부 반복을 통해 작업을 처리한다.Stream API에서는 반복 문법을 메서드 내부에 숨겨 내부 반복을 통해 작업을 처리한다. 때문에 보다 간결한 코드의 작성이 가능하다.List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 2, 3, 4, 5);list.stream().forEach(System.out::println);/* 실행 결과12345*/list의 요소들을 내부 반복을 통해 하나씩 출력했다. 이 예제는 아주 단순하기 때문에 기존의 반복문과의 큰 차이를 느낄 수 없을지도 모른다. 하지만 복잡한 로직을 함수 조합과 내부 반복을 통해 간결하게 표현했을 때, 비로소 그 편리함에 희열을 느낄 수 있다. (나는 그렇다)사용간단한 예제를 통해 Stream API의 개념과 특징을 알아보았다. 이제 또 다른 예제를 통해 자세한 사용법을 알아보자.Stream API의 연산은 크게 세 단계로 나눌 수 있다. Stream을 생성하는 단계, 데이터를 가공하는 단계, 마지막으로 결과 데이터를 만드는 단계가 있다.1. 생성Stream 연산을 하기 위해서는 먼저 Stream 객체를 생성해 주어야 한다. 배열, 컬렉션, 임의의 수, 파일 등 거의 모든 것을 가지고 스트림을 생성할 수 있다.1.1. 배열 StreamStream.of() 또는 Arrays.stream() 메서드를 사용해 생성한다.String[] arr = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;};Stream&amp;lt;String&amp;gt; stringStream1 = Stream.of(arr);Stream&amp;lt;String&amp;gt; stringStream2 = Arrays.stream(arr);Stream&amp;lt;String&amp;gt; stringStream3 = Arrays.stream(arr, 1, 3); // [&quot;b&quot;, &quot;c&quot;]1.2. 컬렉션 StreamCollection 인터페이스에는 default method로 stream()이 정의되어 있기 때문에, Collection 인터페이스를 구현한 객체들(List, Set 등)은 모두 이 메서드를 이용해 Stream을 생성할 수 있다.List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);Stream&amp;lt;String&amp;gt; stringStream = list.stream();1.3. 원시 Stream위와 같이 객체를 위한 Stream 외에 원시 타입(int, long, double)을 다루기 위한 특수한 Stream도 있다. of() 또는 range() 메서드를 통해 생성한다. range() 메서드는 값의 범위를 지정한다.IntStream intStream = IntStream.range(1, 10);LongStream longStream = LongStream.range(1, 10);추가적으로 Java 8의 Random 클래스를 사용하면 난수를 가지는 원시 스트림을 만들 수 있다.LongStream longStream = new Random().longs(5); // 난수 5개 생성1.4. 파일 Stream자바 NIO의 Files 클래스의 lines()을 사용하면 해당 파일의 각 라인을 String 타입의 Stream으로 만들 수 있다.Stream&amp;lt;String&amp;gt; fileStream = Files.lines( Paths.get(&quot;test.txt&quot;), StandardCharsets.UTF_8);2. 가공원본의 데이터를 별도의 데이터로 가공하기 위한 중간 연산의 단계이다. 어떤 객체의 Stream을 원하는 형태로 처리할 수 있으며, 중간 연산의 반환값은 Stream이기 때문에 필요한 만큼 중간 연산을 연결하여 사용할 수 있다.2.1. filterStream에서 조건에 맞지 않는 데이터를 걸려내 데이터를 정제하는 메서드이다. 인자로 boolean을 리턴하는 함수형 인터페이스 Predicate를 받는다.Stream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;? super T&amp;gt; predicate);다음은 1부터 5까지의 숫자 리스트에서 3 이상의 숫자를 필터링한 예제이다.List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 2, 3, 4, 5);integers.stream() .filter(num -&amp;gt; num &amp;gt;= 3) .forEach(System.out::println);/* 실행 결과345*/2.2. mapStream의 각 요소들에 동일한 연산을 적용하는 메서드이다. 인자로 각 요소들에 적용할 연산인 함수형 인터페이스 Function을 받는다.Stream에 들어가 있는 값이 특정 로직을 거친 후 새로운 Stream에 담기게 되는데, 이러한 작업을 매핑(mapping)이라고 한다.&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper);다음은 1부터 5까지의 숫자 리스트에서 각 요소에 * 2를 적용한 예제이다.List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 2, 3, 4, 5);integers.stream() .map(num -&amp;gt; num * 2) .forEach(System.out::println);/* 실행 결과246810*/2.3. sortedStream의 요소들을 정렬하는 메서드이다. 인자로 정렬 방법을 지정하는 함수형 인터페이스 Comparator를 받는다. 인자를 받지 않을 수도 있는데 이때 정렬은 오름차순이 된다.Stream&amp;lt;T&amp;gt; sorted();Stream&amp;lt;T&amp;gt; sorted(Comparator&amp;lt;? super T&amp;gt; comparator);다음은 1부터 5까지의 숫자 리스트를 내림차순으로 정렬한 예제이다.List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 2, 3, 4, 5);integers.stream() .sorted(Comparator.reverseOrder()) .forEach(System.out::println);/* 실행 결과54321*/2.4. distinctStream의 요소들에 중복된 데이터가 존재하는 경우, 중복을 제거하는 메서드이다.Stream&amp;lt;T&amp;gt; distinct();다음은 중복된 값을 가지는 숫자 리스트의 중복을 제거한 예제이다.List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 1, 1, 5, 5);integers.stream() .distinct() .forEach(System.out::println);/* 실행 결과15*/여기서 주의해야 할 점이 하나 있다. distinct는 중복 데이터를 검사하기 위해 Object의 equals 메서드를 사용한다. 때문에 우리가 생성한 클래스를 Stream으로 사용한다고 하면, equals()와 hashCode()를 오버라이드 해야만 distinct를 제대로 적용할 수 있다.2.5. peekStream에 영향을 주지 않고 각 요소들에 특정 연산을 수행하는 메서드이다. 인자로 함수형 인터페이스 Consumer를 받는다.peek라는 단어가 ‘엿보다’라는 뜻을 가지고 있는 것처럼, peek 함수는 Stream의 각 요소에 특정 연산을 수행할 뿐 결과에 영향을 주지 않는다. 예를 들어 어떤 Stream의 요소들을 중간에 출력해서 확인하고 싶을 때 사용할 수 있다.Stream&amp;lt;T&amp;gt; peek(Consumer&amp;lt;? super T&amp;gt; action);다음은 1부터 4를 가지는 IntStream의 합계를 계산하는 예제이다.IntStream intStream = IntStream.range(1, 5); // 1 ~ 4int sum = intStream .peek(System.out::println) .sum();System.out.println(sum);/* 실행 결과123410*/peek 함수를 적용하여 중간값을 출력해 확인하였고, 마지막으로 sum을 적용해 합계를 계산했다.2.6. mapToObj작업을 하다 보면 일반적인 Stream 객체를 원시 Stream으로 바꾸거나 그 반대의 작업이 필요한 경우가 있다. 이를 위해 일반적인 Stream 객체는 mapToInt(), mapToLong(), mapToDouble()라는 특수한 Mapping 연산을 지원하고 있으며, 그 반대로 원시 객체는 mapToObj()를 통해 일반적인 Stream 객체로 바꿀 수 있다.List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 2, 3, 4, 5);IntStream intStream1 = integers.stream() .mapToInt(Integer::intValue); // List&amp;lt;Integer&amp;gt; =&amp;gt; IntStream3. 결과가공 단계를 거쳐 만들어진 데이터를 최종적으로 원하는 결과 데이터로 만드는 단계이다. Stream의 요소들을 소모하면서 연산이 수행되기 때문에 한 번만 처리 가능하며, 연산이 끝난 뒤 Stream이 닫히게 된다.3.1. calculateStream 요소들을 대상으로 최대(max), 최소(min), 평균(average), 합(sum), 개수(count)를 구하는 최종 연산들이 있다.IntStream intStream = IntStream.range(1, 5);OptionalInt optionalInt = intStream.max();위 예제는 max 함수를 사용하여 최댓값을 구했다. 보이는 것처럼 max()는 반환형이 int가 아닌 OptionalInt이다. Stream 안에 값이 없을 경우 최댓값을 계산할 수 없기 때문에 반환형이 Optional인 것이다.int max = intStream.max().orElse(0); // 4int min = intStream.min().orElse(0); // 1double average = intStream.average().orElse(0); // 2.5min()와 average()도 마찬가지로 반환형이 Optional이다. 따라서 원시 타입의 결과를 원한다면 orElse()와 같은 메서드를 사용해 내부에서 값을 꺼내야 한다.int sum = intStream.sum(); // 10long count = intStream.count(); // 4sum()과 count()는 위와 달리 반환형이 원시 타입이다. Stream에 값이 존재하지 않더라도 합과 개수는 0으로 계산할 수 있기 때문이다.3.2. collectStream의 요소들을 List, Set, Map 등 다른 종류의 결과로 수집하고 싶을 경우 collect를 사용한다.collect는 어떻게 Stream의 요소들을 수집할 것인가를 정의한 Collector 타입을 인자로 받아서 처리한다. 일반적으로 List로 Stream의 요소들을 수집하는 경우가 많은데, 이렇게 자주 사용하는 작업은 Collectors 객체에서 static method로 제공하고 있다. 원하는 것이 없는 경우에는 Collector 인터페이스를 직접 구현하여 사용할 수도 있다.List&amp;lt;User&amp;gt; userList = Arrays.asList( new User(&quot;heung&quot;, 28), new User(&quot;woneee&quot;, 24), new User(&quot;sun&quot;, 28), new User(&quot;bun&quot;, 31));collect에 대한 이해를 돕기 위해 간단한 User class를 만들고 그 List를 준비했다. User는 name(이름), age(나이)를 멤버 변수로 가지고 있다.3.2.1. Collectors.toListStream에서 작업한 결과를 List로 반환한다.List&amp;lt;String&amp;gt; nameList = userList.stream() .map(User::getName) .collect(Collectors.toList());System.out.println(nameList);/* 실행 결과[heung, woneee, sun, bun]*/Stream의 각 요소(User)에서 name을 꺼내 매핑하고, 그 결과를 List로 반환했다.만약 해당 결과를 Set 또는 Map으로 반환하고 싶다면 Collectors.toSet()과 Collectors.toMap()을 사용하면 된다.3.2.2. Collectors.joiningStream에서 작업한 결과를 1개의 String으로 이어붙인다.총 3개의 인자를 받는데, 이를 이용하면 원하는 결과를 간단하게 만들 수 있다. delimiter : 각 요소의 중간에 들어가는 구분자 prefix : 결과 맨 앞에 붙는 문자 suffix : 결과 맨 뒤에 붙는 문자String listToString = userList.stream() .map(User::getName) .collect(Collectors.joining(&quot;, &quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;));System.out.println(listToString);/* 실행 결과&amp;lt;heung, woneee, sun, bun&amp;gt;*/User 리스트에서 name을 꺼내고 각 요소들을 하나의 문자열로 이어붙였다.3.2.3. Collectors.averagingInt / Collectors.summingInt / Collectors.summarizingIntStream에서 작업한 결과의 평균과 합을 구한다.아래의 예제에서는 int 자료형만을 사용했는데 averaging(), summing(), summarizing() 메서드는 각 원시 타입(int, long, double) 별로 제공된다.Double average = userList.stream() .collect(Collectors.averagingInt(User::getAge));Integer sum = userList.stream() .collect(Collectors.summingInt(User::getAge));System.out.println(average);System.out.println(sum);/* 실행 결과27.75111*/User 리스트에서 age를 꺼내 평균과 합을 구했다.평균과 합은 calculate을 사용해서 구할 수 있었다. 이 둘은 사용되는 스트림의 타입이 다른데, calculate는 IntStream과 같은 원시 Stream에서 사용하고 collect는 컬렉션 Stream에서 사용한다.IntSummaryStatistics statistics = userList.stream() .collect(Collectors.summarizingInt(User::getAge));System.out.println(statistics);/* 실행 결과IntSummaryStatistics{count=4, sum=111, min=24, average=27.750000, max=31}*/Collectors.summarizingInt()의 경우에는 IntSummaryStatistics 타입의 객체를 반환한다. 이 안에는 최대, 최소, 합, 평균, 개수 등 계산 값의 모든 정보를 가지고 있다. 따라서 여러 개의 값이 필요하다면 이를 사용해 한꺼번에 계산하는 것이 좋다.3.2.4. Collectors.groupingByStream에서 작업한 결과를 특정 그룹으로 묶는다. 결과는 Map 타입으로 반환되며, 인자로 함수형 인터페이스 Function을 받는다.Map&amp;lt;Integer, List&amp;lt;User&amp;gt;&amp;gt; group = userList.stream() .collect(Collectors.groupingBy(User::getAge));System.out.println(group);/* 실행 결과{24=[User{name=&#39;woneee&#39;, age=24}], 28=[User{name=&#39;heung&#39;, age=28}, User{name=&#39;sun&#39;, age=28}], 31=[User{name=&#39;bun&#39;, age=31}]}*/User 리스트에서 age를 꺼내 나이를 기준으로 그룹을 나눴다. 준비된 데이터로는 28살이 두 명, 24살과 31살이 각 한 명씩 존재한다.3.2.5. Collectors.partitioningByStream에서 작업한 결과를 특정 기준으로 나눈다. 결과는 Map 타입으로 반환되며, 인자로 함수형 인터페이스 Predicate를 받는다.위의 Collectors.groupingBy()은 여러 그룹으로 나눌 수 있지만, Collectors.partitioningBy()는 true 또는 false로 나뉘게 된다.Map&amp;lt;Boolean, List&amp;lt;User&amp;gt;&amp;gt; partition = userList.stream() .collect(Collectors.partitioningBy(user -&amp;gt; user.getAge() &amp;gt; 25));/* 실행 결과{false=[User{name=&#39;woneee&#39;, age=24}], true=[User{name=&#39;heung&#39;, age=28}, User{name=&#39;sun&#39;, age=28}, User{name=&#39;bun&#39;, age=31}]}*/User 리스트에서 25살 이상인 사람과 그렇지 않은 사람을 나눴다. key 값을 보면 ture 또는 false 두 가지인 것을 확인할 수 있다.3.2.6. Collectors.collectingAndThenStream에서 작업한 결과를 특정 타입으로 collect한 이후에 추가 작업을 지정한다. 첫 번째 인자로 Collectors를 받아 결과를 만들고, 두 번째 인자로 함수형 인터페이스 Function을 받아 추가 작업을 처리한다.Set&amp;lt;User&amp;gt; unmodifiableSet = userList.stream() .collect(Collectors.collectingAndThen( Collectors.toSet(), Collections::unmodifiableSet ));/* 실행 결과[User{name=&#39;bun&#39;, age=31}, User{name=&#39;heung&#39;, age=28}, User{name=&#39;woneee&#39;, age=24}, User{name=&#39;sun&#39;, age=28}]*/User 리스트를 Set 타입으로 collect하고 추가 작업으로 일반적인 Set을 수정 불가능한 Set으로 변환했다.3.3. matchStream에서 작업한 결과가 특정 조건을 만족하는지 검사한다. 인자로 함수형 인터페이스 Predicate를 받아 검사 조건으로 사용한다.다음과 같은 세 가지 메서드가 있다. anyMatch : 하나라도 조건을 만족하는 요소가 있는지 allMatch : 모든 요소가 조건을 만족하는지 noneMatch : 모든 요소가 조건을 만족하지 않는지List&amp;lt;Integer&amp;gt; integers = Arrays.asList(2, 4, 6, 8);boolean anyMatch = integers.stream().anyMatch(num -&amp;gt; num == 2); // trueboolean allMatch = integers.stream().allMatch(num -&amp;gt; num % 2 == 0); // trueboolean noneMatch = integers.stream().noneMatch(num -&amp;gt; num % 2 == 1); // trueanyMatch()를 통해 Stream 요소에 2가 존재하는지, allMatch()를 통해 모든 요소가 2의 배수인지, noneMatch()를 통해 모든 요소가 홀수가 아닌지 검사했다. 결과는 모두 true를 반환한다.3.4. forEachStream에서 작업한 결과의 모든 요소에 특정 연산을 수행한다. 보통 System.out.println()을 넘겨 최종 결과를 출력하는 용도로 사용한다.앞의 가공 파트에서 살펴본 peek와는 중간 작업과 최종 작업이라는 차이가 있다.List&amp;lt;Integer&amp;gt; integers = Arrays.asList(1, 2, 3, 4, 5);list.stream().forEach(System.out::println);지금까지 Stream API의 개념과 기본적인 사용법을 알아보았다. 이외에도 제공되는 기능들이 있는데 이를 잘 활용하기 위해서는 더 깊은 이해가 필요하다. 다음 포스팅에서 자세히 다루어 본다.Related Posts Stream API - 고급 Optional Functional InterfaceReference https://mangkyu.tistory.com/112 https://futurecreator.github.io/2018/08/26/java-8-streams/ https://hbase.tistory.com/171 https://12bme.tistory.com/461 https://velog.io/@foeverna/Java-513-%EC%8A%A4%ED%8A%B8%EB%A6%BC-API-Stream-API" }, { "title": "Optional", "url": "/posts/optional/", "categories": "Language, Java", "tags": "Java 8, Optional", "date": "2022-02-19 13:32:00 +0900", "snippet": "개발할 때 흔히 NPE(NullPointException)를 접하게 된다. null 값을 가진 객체를 참조하려고 할 때 발생하는 에러인데, NPE를 해결하기 위해서는 해당 객체가 null인지 검사하는 로직이 필요하다.하지만 코드가 복잡해지고 검사해야 할 변수가 많아질수록 검사 로직 구현이 상당히 번거로워진다. 본문에서 이를 쉽게 처리할 수 있도록 도와주는 Optional 클래스를 소개한다.Optional 이란?Optional은 Integer나 Double처럼 T 타입의 객체를 포장해 주는 래퍼 클래스(Wrapper Class)이다. 따라서 Optional 인스턴스는 모든 타입의 참조 변수를 저장할 수 있다.이러한 Optional 객체를 사용하면 제공되는 메서드로 예상치 못한 NPE을 간단히 회피할 수 있다. 즉, 복잡한 조건문 없이도 null 값으로 인해 발생하는 예외를 처리할 수 있게 된다.참고로 Optional은 Java 8에서 추가되었다.사용법Optional의 주요 메소드를 정리했다. 메서드 설명 static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; empty() 아무런 값도 가지지 않은 비어있는 Optional 객체를 반환한다. T get() Optional 객체에 저장된 값을 반환한다. boolean isPresent() 저장된 값이 존재하면 true를 반환하고, 값이 존재하지 않으면 false를 반환한다. static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; of(T value) null이 아닌 명시된 값을 가지는 Optional 객체를 반환한다. static &amp;lt;T&amp;gt; Optional&amp;lt;T&amp;gt; ofNullable(T value) 명시된 값이 null이 아니면 그 값을 가지는 Optional 객체를 반환하고, 명시된 값이 null이면 비어있는 Optional 객체를 반환한다. T orElse(T other) 저장된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 값을 반환한다. T orElseGet(Supplier&amp;lt;? extends T&amp;gt; other) 저장된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 람다 표현식의 결괏값을 반환한다. &amp;lt;X extends Throwable&amp;gt; T orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier) 저장된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 예외를 발생시킨다. &amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper) 값이 있으면 제공된 매핑 함수를 적용하고, 결과가 null이 아니면 결과를 설명하는 Optional을 반환한다. 더 자세한 정보는 공식 문서를 참고하길 바란다.공식 문서 : https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html예제위에서 사용법을 알아봤으니 예제를 통해 자세한 활용 방법을 알아본다.1. 생성아무런 값도 가지지 않는 빈 객체는 아래와 같이 생성할 수 있다.Optional&amp;lt;String&amp;gt; userName = Optional.empty();System.out.println(userName); // Optional.emptySystem.out.println(userName.isEmpty()); // trueSystem.out.println(userName.isPresent()); // false값을 가지는 객체는 아래와 같이 생성할 수 있다.// getNmae()이 null이면 NPE 발생// null이 아니면 해당 문자열을 가지는 Optional 반환Optional&amp;lt;User&amp;gt; optionalUser = Optional.of(getUser());// getNmae()이 null이면 Optional.empty 반환// null이 아니면 해당 문자열을 가지는 Optional 반환Optional&amp;lt;User&amp;gt; optionalUser = Optional.ofNullable(getUser());메서드 of 또는 ofNullable을 사용한다. 메서드명에서도 알 수 있듯이 of는 값으로 null을 허용하지 않고, ofNullable은 null을 허용한다.2. 객체 사용Optional에 저장되어 있는 객체는 아래와 같이 꺼내 쓸 수 있다.// Optional에 저장된 값을 반환// 비어있으면 NoSuchElementException 발생User user = optionalUser.get();// Optional에 저장된 값이 있으면 해당 값 반환// 비어있으면 대체하는 새로운 객체 반환(unknown User)user = optionalUser.orElse(new User(&quot;unknown&quot;));// Optional에 저장된 값이 있으면 해당 값 반환// 비어있으면 람다식의 결과값(unknown User)을 반환user = optionalUser.orElseGet(() -&amp;gt; new User(&quot;unknown&quot;));// Optional에 저장된 값이 있으면 해당 값 반환// 비어있으면 예외를 throwuser = optionalUser.orElseThrow(() -&amp;gt; new RuntimeException());위의 예제에서 orElse()와 orElseGet()는 어떤 차이가 있는지 의문이 들 수 있다. 겉으로는 똑같이 동작하지만 중요한 차이가 있다.orElse()는 인자로 객체를 받는다. 위의 예제에서는 new User(&quot;unknown&quot;)을 전달했다. 해당 코드는 optionalUser가 가지고 있는 값의 유무와 관계없이 무조건 실행된다. 따라서 optionalUser가 비어있지 않은 경우 쓸모없는 새로운 객체가 생성이 돼 메모리가 낭비되는 것이다.반면에 orElseGet()는 인자로 람다식을 받는다. 예제에서는 () -&amp;gt; new User(&quot;unknown&quot;)을 전달했다. 해당 람다식는 optionalUser가 비어있을 때만 실행되도록 설계되어 있다. 따라서 optionalUser가 비어있지 않은 경우 새로운 객체가 생성되지도, 메모리가 낭비되지도 않는 것이다.정리하자면, 새 객체 생성이나 새로운 연산을 유발하지 않고 이미 생성된 값을 사용할 때는 orElse()를 사용해도 괜찮다. 하지만 이외의 경우에서는 orElseGet()를 사용하는 것이 유리하다.3. 활용간단한 활용 예제를 살펴 본다. 아래와 같이 어떤 사용자의 우편번호를 찾는 함수가 있다.public String findPostCode() { User user = getUser(); if (user != null) { Address address = user.getAddress(); if (address != null) { String postCode = address.getPostCode(); if (postCode != null) { return postCode; } } } return &quot;우편번호 없음&quot;;}우편번호는 User가 가지고 있는 Address의 내부에 저장되어 있기 때문에, 해당 객체들이 null인지 검사하는 번거로운 작업이 추가되었다. (이러한 조건문이 없다면 NPE를 만날 수 있다)이제 위 함수를 Optional을 이용해 개선해 보자.public String findPostCode() { Optional&amp;lt;User&amp;gt; optionalUser = Optional.ofNullable(getUser()); Optional&amp;lt;Address&amp;gt; address = optionalUser.map(User::getAddress); Optional&amp;lt;String&amp;gt; postCode = address.map(Address::getPostCode); return postCode.orElse(&quot;우편번호 없음&quot;);}이렇게 조금은 더 정돈된 코드를 작성할 수 있다. (map이 어떤 동작을 하는지 모르겠다면 위의 주요 메서드 표를 확인하길 바란다)메서드 체인을 사용하면 이 모든 과정을 한 줄로 작성할 수 있다.public String findPostCode() { Optional&amp;lt;User&amp;gt; optionalUser = Optional.ofNullable(getUser()); return optionalUser.map(User::getAddress) .map(Address::getPostCode) .orElse(&quot;우편번호 없음&quot;);}처음과 비교해 보면 상당히 깔끔해졌다. 이렇게 Optional은 null을 쉽게 처리할 수 있을 뿐만 아니라, 생산성과 가독성도 올릴 수 있다.주의할 점반환 값으로 null을 사용하는 것이 위험하기 때문에 등장한 것이 Optional이다. 때문에 반환형이 Optional인 메서드에서 Optional 객체 대신 null을 반환하는 것은 Optional의 도입 의도와 맞지 않다. null 대신 Optional.empty()를 반환하도록 해야한다.Optional은 값을 Wrapping하고 다시 풀고, null일 경우에는 대체하는 함수를 호출하는 등의 오버헤드가 있어 성능 저하의 우려가 있다. 때문에 메소드의 반환 값이 절대 null이 아니라면 Optional을 사용하지 않는 것이 좋다.즉, Optional은 메소드의 결과가 null이 될 수 있으며, 클라이언트가 이 상황을 처리해야 할 때 사용해야 한다.자세한 Optional의 올바른 사용법에 대해서는 좋은 자료가 있어 링크를 첨부한다.더 깊이 공부하고 싶다면 읽어보는 것을 추천한다.참고 링크 : Optional 제대로 활용하기 - IncrementReference Optional 클래스 - TCP School Java Optional 바르게 쓰기 - HomoEfficio Optional 개념 및 사용법 - 망나니개발자" }, { "title": "Bean Validation", "url": "/posts/Bean-Validation/", "categories": "Server, Spring", "tags": "Spring Boot, Java, Validation", "date": "2022-02-17 23:09:00 +0900", "snippet": "개발에서 가장 중요한 요소 중 하나가 Validation이다. 사용자로부터 어떤 값이 입력될지 모르기 때문에 검증하는 과정이 필수적이다.검증 로직은 클라이언트와 서버에서 수행하게 된다. 클라이언트에서만 검증하게 되면 postman과 같은 툴을 이용해 데이터를 조작할 수 있어 보안에 취약하며, 서버에서만 검증하게 되면 즉각적인 반응이 어려워 고객 사용성이 부족해진다.이 글에서는 Spring Boot에서 Bean Validation을 활용한 서버에서의 검증 방법을 살펴본다.Bean Validation 이란?Bean Validation은 특정한 구현체가 아니라 Bean Validation 2.0(JSR-380)이라는 기술 표준이다. 쉽게 이야기해서 검증 어노테이션과 여러 인터페이스의 모음이다. 마치 JPA가 표준 기술이고 그 구현체로 Hibernate 있는 것과 같다.Bean Validation을 구현한 기술 중에 일반적으로 사용하는 구현체는 Hibernate Validator이다.참고로 여기서의 Hibernate는 ORM과 관련이 없다.사용법Dependency 추가 implementation &#39;org.springframework.boot:spring-boot-starter-validation&#39;spring-boot-starter-validation 의존관계를 추가하면 관련 라이브러리가 모두 추가 된다.Validation Annotaion대표적인 어노테이션을 몇 가지 소개한다. @NotBlank : 빈 값, 공백을 허용하지 않는다. @NotNull : null을 허용하지 않는다. @Range(min = 1, max = 999) : 값의 범위를 지정한다. @Max(999) : 최댓값을 지정한다. @Min(1) : 최솟값을 지정한다.더 많은 정보는 아래 링크의 공식 문서에 잘 정리되어 있다. 정말 다양한 어노테이션이 있으니 개발을 하면서 필요할 때마다 찾아 쓰면 될 것 같다.validation annotation 모음 : https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec예제package hello.itemservice.domain.item;import lombok.Data;import org.hibernate.validator.constraints.Range;import javax.validation.constraints.Max;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotNull;@Data@ToStringpublic class Item { @NotBlank private String itemName; @NotNull @Range(min = 1000, max = 1000000) private Integer price; @NotNull @Max(value = 9999) private Integer quantity; public Item() { } public Item(String itemName, Integer price, Integer quantity) { this.itemName = itemName; this.price = price; this.quantity = quantity; }}Item 클래스의 멤버 변수에 validation annotaion을 적용했다.상품명은 빈칸과 공백을 허용하지 않고 가격은 1000이상 10000이하, 수량은 최대 9999로 제한된다.import 코드를 보면 Range 어노테이션과 나머지 어노테이션의 위치가 다르다.javax.validation으로 시작하면 특정 구현에 관계없이 제공되는 표준 인터페이스이고, org.hibernate.validator로 시작하면 hibernate validator 구현체를 사용할 때만 제공되는 검증 기능이다. 실무에서 대부분 hibernate validator를 사용하므로 자유롭게 사용해도 된다.package hello.itemservice.web.validation;import hello.itemservice.domain.item.Item;import hello.itemservice.web.validation.form.ItemSaveForm;import lombok.extern.slf4j.Slf4j;import org.springframework.validation.BindingResult;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.*;@Slf4j@RestController@RequestMapping(&quot;/validation/api/items&quot;)public class ValidationItemApiController { @PostMapping(&quot;/add&quot;) public Object addItem(@RequestBody @Validated Item item, BindingResult bindingResult) { log.info(&quot;API 컨트롤러 호출&quot;); if (bindingResult.hasErrors()) { log.info(&quot;검증 오류 발생 errors={}&quot;, bindingResult); return bindingResult.getAllErrors(); } log.info(item.toString()); log.info(&quot;성공 로직 실행&quot;); return item; }}Item 클래스를 테스트하기 위한 간단한 컨트롤러를 만들었다. 이제 API 요청이 오면 reqeust body에 담긴 itemName, price, quantity의 값을 검증하게 된다.addItem 메서드의 매개 변수를 보면, 검증할 클래스(Item)에 @Validated가 적용된 것을 볼 수 있다. 해당 어노테이션은 스프링 전용 검증 어노테이션으로, 검증을 하기 위해서 반드시 적용되어야 한다.같은 역할을 하는 @Valid도 존재한다. 자바 표준 검증 어노테이션으로, 사용하기 위해서는 build.gradle에 dependency 추가가 필요하다. 앞서 이미 추가한 ‘org.springframework.boot:spring-boot-starter-validation’ 이다.@Validated와 @Valid 둘 다 동작하지만 @Validated는 내부에 groups라는 기능을 포함하고 있다.groups는 하나의 클래스로 서로 다른 검증 조건을 제공하는 기능이다. 예를 들어 회원정보를 저장하고 수정하는 로직을 생각해 보자. 저장할 때는 회원번호를 입력받지 않지만(아직 회원이 아니므로 회원번호가 없다) 수정할 때는 회원번호가 필요하다. 따라서 한 클래스에서 서로 다른 검증 조건이 생긴 것이다.이런 경우 groups 기능을 활용해서 처리할 수 있다. 하지만 groups는 실무에서 잘 사용되지 않는다. 앞에서 간단한 회원번호로 예시로 들었지만 실무에서 저장과 수정에서 필요한 데이터는 크게 상이하다. 따라서 저장 폼, 수정 폼 두 개의 클래스로 분리하여 사용하는 것이 유지보수 측면에서 유리하다.주의할 점검증에 실패하면 스프링은 FieldError를 생성하면서 사용자가 입력한 값을 넣어둔다. 그리고 해당 오류를 BindingResult에 담아서 컨트롤러를 호출한다. 따라서 검증 실패 시에도 사용자의 오류 메시지를 정상 출력할 수 있다. 위의 예제에서는 “API 컨트롤러 호출”가 출력된 후, “검증 오류 발생 errors={발생된 에러}”가 출력된다.하지만 HttpMessageConverter 단계에서 JSON 데이터를 객체로 변경하지 못하면, 이후 단계 자체가 진행되지 않고 예외가 발생한다. 컨트롤러도 호출되지 않고, Validator도 적용할 수 없다. 위의 예제에서는 “API 컨트롤러 호출” 로그가 출력되지 않고 Exception이 발생한다.Reference 백엔드 웹 개발 활용 기술 - 인프런 Java Bean Validation 제대로 알고 쓰자 - Brady Spring Boot Bean Validation 제대로 알고 쓰자 - Brady" }, { "title": "삼성 청년 SW 아카데미 5기 수료 후기 (2)", "url": "/posts/%EC%82%BC%EC%84%B1-%EC%B2%AD%EB%85%84-sw-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8-5%EA%B8%B0-%EC%88%98%EB%A3%8C-%ED%9B%84%EA%B8%B0-(2)/", "categories": "회고록", "tags": "삼성 청년 SW 아카데미, SSAFY", "date": "2022-02-14 14:58:00 +0900", "snippet": "지난 글에 이어서 삼성 청년 SW 아카데미(이하 SSAFY) 후기를 작성한다. 입과하는 과정은 이야기 드렸고, 이제 SSAFY의 교육과정이 어떻게 흘러가는지 그리고 느꼈던 생각을 공유한다.전체적으로 아래와 같은 커리큘럼으로 진행된다.Job Fair는 간략하게 소개하고 넘어가겠다.위의 그림에서 보시다시피 기본/심화 과정이 끝나고 난 후 1개월간 진행되며 학교의 방학과 비슷한 개념이다. 그러나 이 기간에 놀고만 있을 수는 없다. 채용방람회 라는 것이 개최되는데, SSAFY와 연계되어 있는 기업에 면접 또는 상담을 지원할 수 있는 기회가 제공된다. SSAFY 교육생에게만 제공되는 채용 전형인 셈이다.연계되는 기업은 약 80개가량 있다. 수가 생각보다 많지만 사실 대기업은 잘 없다. 그래도 괜찮은 기업이 많이 있기 때문에 중견, 스타트업이 목표인 사람에게는 좋은 기회이다. 실제로 이 기간에 취업을 해서 나가는 친구들이 많다.기본과정먼저 5개월의 기본 과정이 시작된다. 기초부터 탄탄히 SW 지식을 쌓을 수 있는 기간이다.크게 프로그래밍 언어, 프론트엔드, 백엔드, 알고리즘, 데이터베이스에 대해 배울 수 있다. 구체적으로 무엇을 배우는지 하나하나 말씀드리기는 어렵지만, 정말 기초부터 차근차근 알려주시니 관련 경험이 없으신 분들도 걱정하지 않으셔도 될 것 같다.SSAFY는 두 개의 반으로 나누어져 있다. (최근에는 구미 캠퍼스에 모바일반도 생겼다) 대학교에서 컴퓨터공학 또는 관련 학문을 전공했다면 전공자반으로 가게 된다. 이외에 경험이 없는 사람은 비전공자반이 된다. 전공자반은 자바와 스프링을 배우고 비전공자반은 파이썬과 장고를 배우게 된다.기본과정의 마지막 일주일은 배웠던 내용을 활용하여 작은 프로젝트를 하나 진행한다. 단순히 강의와 과제로만 학습했던 내용을 직접 개발에 적용함으로써 더욱 잘 이해할 수 있는 계기가 된다.개인적으로 기본과정의 꽃은 스프링과 알고리즘이라고 생각한다.사실 나는 전공자이지만 백엔드 프레임워크 경험이 없었다. 때문에 SSAFY의 스프링 강의는 정말 유익했고 이후 백엔드 개발자로 성장하는데 큰 도움이 되었다.알고리즘은 강의보다는 동기들과 스터디를 하면서 크게 도움을 받았다. (물론 강의도 정말 좋았다) SSAFY는 배움에 열정이 가득한 사람이 많다. 함께 스터디를 진행하며 서로 자극제가 되었고 더욱 꾸준히 그리고 열심히 할 수 있었다.심화과정심화과정에서는 각 7주간 3개의 팀 프로젝트를 진행하게 된다.첫 번째로 공통 프로젝트에서는 주어진 기술 도메인 가운데 하나를 선택하여 프로젝트를 진행한다. 처음으로 제대로 팀 프로젝트를 하는 것이니 만큼 협업을 하는데 어려움이 많았지만, 정말 열정적으로 즐겁게 참여했다. 개인적으로 해당 프로젝트를 하면서 제대로 스프링을 공부할 수 있었고 WebRTC에 대해서도 알게 되었다. 추가적으로 Git과 Jira를 활용할 수 있게 되었다.두 번째로 심화 프로젝트에서는 주어진 4차 산업 혁명 기술 중 하나를 선택하여 팀 빌딩을 하고 프로젝트를 진행하게 된다. 이 프로젝트는 아무래도 조금 더 고도화된 기술이 요구되다 보니 교육생들이 많이 힘들어한다. 이전에 해당 기술을 경험해 봤던 사람을 주축으로 개발이 진행된다. 최신 기술을 가볍게 경험해 볼 수 있는 좋은 기회인 것 같다.그런데 나는 심화 프로젝트를 하지 않았다. 정확히 말하자면 다른 프로젝트로 대체되었다. 우수 교육생으로 선발되어 삼성의 무선사업부와 함께 SSDC 오픈 소스 프로젝트를 진행했다. 삼성의 Samsung Automation Studio라는 Node-RED 기반의 서비스가 있는데, 여기에 아이디어를 추가하여 Node 및 Flow를 개발하는 과제를 수행했다. 해당 프로젝트는 삼성의 현업자분들께 멘토링을 받으며 진행되었는데, 프로젝트의 방향을 못 잡고 헤맬 때마다 조언을 아끼지 않으셨고 프로젝트 이외에도 여러 좋은 말씀들을 많이 해주셨다. 결과적으로 오픈 소스에 contribute하고 Node-RED 라이브러리와 npm에 publish할 수 있었던 정말 소중하고 값진 경험이었다.마지막으로 자율 프로젝트이다. 자율이라는 단어에서 알 수 있듯이 제한 없이 교육생들이 하고 싶은 기술 스택과 주제로 프로젝트가 진행된다. 이전의 두 프로젝트에서도 큰 제약은 없었지만 명세서가 있었기 때문에 필수적인 구현 요소가 있었다. 하지만 자율 프로젝트에서는 정말 마음껏 개발하면 된다. 하지만 나는 이 자유도 때문에 오히려 기획에서 어려움을 겪었다. 너무 자유로워서 뭘 해야 될지 막막했고 좋은 아이디어가 떠오르지 않았다. 수 많은 회의 끝에 평소 공부하고 싶었던 부하 테스트와 관련된 프로젝트를 진행했고, 결과적으로 나름 만족할 만한 성과를 거두었다.수료1년간의 나는 운이 좋게도 받을 수 있는 모든 상을 수상했고 지역에서 1등으로 수료하게 되었다. 사실 1등을 하게 될 것이라고는 생각하지 못했는데, 열심히 고생했던 1년을 인정받는 것 같아 너무 행복했다.이 글을 보는 이수 중인 또는 예비 교육생에게 당부드리고 싶다. SSAFY는 정말 열심히 하면 그만큼의 혜택이 돌아온다. 그러니까 SSAFY의 친절한 교육을 낭비하지 말고 열정적으로 참여하자. 그러면 자연스럽게 더 큰 기회가 따라올 것이고 더욱 성장한 나를 발견할 수 있을 것이다.실습 코치수료 이후에 6기 실습 코치에 지원했고 성적이 좋았기 때문에 어려움 없이 합격했다. 심화 과정이 시작된 6기 교육생들의 프로젝트를 도와주고 SSAFY의 운영을 지원하는 업무를 수행했다. 예상보다 빨리 취업하게 되는 바람에 한 달 밖에 활동하지 못했지만, 6기 교육생들이 겪고 있는 문제를 도와주며 오히려 내가 더 많이 공부하게 되었고 교육생들의 열정에 큰 에너지를 받을 수 있었다. 기회가 된다면 실습 코치도 지원해 보는 것을 강력히 추천한다.1년 전 너무나 미숙했던 나는 나름 개발자라고 부를 수 있을 만큼 성장했고 좋은 동료들을 얻었다. 좋은 교육을 제공해 준 SSAFY에게 정말 감사드린다.이상으로 SSAFY 후기를 마친다." }, { "title": "삼성 청년 SW 아카데미 5기 수료 후기 (1)", "url": "/posts/%EC%82%BC%EC%84%B1-%EC%B2%AD%EB%85%84-sw-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8-5%EA%B8%B0-%EC%88%98%EB%A3%8C-%ED%9B%84%EA%B8%B0-(1)/", "categories": "회고록", "tags": "삼성 청년 SW 아카데미, SSAFY", "date": "2022-02-11 14:26:00 +0900", "snippet": "2021년 한 해 동안 삼성 청년 SW 아카데미(이하 SSAFY) 교육을 받았다. 개인적으로 가장 큰 터닝포인트라고 생각될 정도로, 정말 많은 것들을 배웠고 크게 성장할 수 있었다.입과부터 수료까지 겪었던 일을 정리하고자 한다. 먼저 합격하기 위해 어떤 과정을 거치고 어떤 준비를 했는지 소개한다. 크게 자기소개서, SW 적성진단, 면접 순서로 이루어진다.자기소개서자기소개서는 너무 잘 쓸 필요가 없는 것 같다. 대충 써도 된다는 말이 아니라, SSAFY는 교육기관이기 때문에 글의 완성도가 아닌 내용이 중요하다. 내가 얼마나 열정과 학습 의지가 있는지 그리고 개발자라는 직업에 얼마나 확신이 있는지를 보여주면 된다.그러면 어떻게 보여줘야 할까?답은 평소의 내 생활 패턴에 있다. 개발자가 되기 위해 공부하고 고민했던 경험을 제시하면 된다. 여기서 중요한 포인트는 단순히 경험에서 끝나는 것이 아닌, 당시 내가 가졌던 생각 그리고 결과를 같이 얘기해주는 것이다. 이렇게 하면 내가 얼마나 준비가 된 사람인지 어필할 수 있을 것이다.SW 적성진단수리/추리 시험과 컴퓨팅 사고 두 가지의 시험을 치르게 된다.수리/추리 시험은 간단하다. 어떤 사람들은 이 시험을 ‘‘준비할 수 없는 시험이다’’, ‘‘머리가 좋아야 한다’‘라고 말하는데 나는 전혀 동의하지 않는다. 그 이유는 문제의 유형이 GSAT과 똑같기 때문이다. GSAT 문제집을 구매하고 문제를 풀다 보면 유형이 전부 비슷하기 때문에 점점 빨리 풀게 되는 자신을 발견할 것이다. 한 권을 독파하고 나면 SW 적성진단은 쉽게 통과할 수 있을 것이다. 딱 한 권이면 된다.이제 문제가 되는 것은 컴퓨팅 사고 시험이다. 아주 간단한 알고리즘 문제를 순으로 푸는 시험인데, 알고리즘 문제를 아예 접하지 못했던 사람은 조금 어려울 수도 있다. 하지만 어려운 알고리즘 문제가 나오는 것이 아니라, 어떤 규칙을 찾고 단순한 계산을 통해 충분히 해결할 수 있기 때문에 너무 걱정은 하지 않아도 된다. 유튜브나 구글링을 하면 문제 예시를 찾을 수 있다. 그 문제를 풀어보면서 감을 익히는 것을 추천한다.면접먼저 PT 면접이 진행되고 바로 자소서와 관련된 질문들을 주신다.PT 면접의 주제는 언급할 수 없지만, 평소 최신 기술에 대해 관심을 가지고 있다면 수월하게 넘어갈 수 있을 것이다. 다음으로 자소서, 협업에 관련된 질문이 들어왔다. 내가 어떤 사람인지 확인하려는 느낌이었다. 면접 분위기는 편안하지만은 않았다. 하지만 다른 친구들의 이야기를 들어보니 편안했다는 말도 있어 면바면 인 것 같다.나는 친구들과 면접 스터디를 하며 준비했다. 서로 자소서를 보며 예상 질문을 던지고 답변을 하며 말하는 연습을 했다. 당시 나처럼 면접을 처음 경험하는 분들이 많을 것이라고 생각한다. 어떤 질문을 받았을 때 머리 속에 드는 많은 생각들을 정리해서 얘기하는 게 정말 쉽지 않다. 처음 면접을 경험한다면 스터디를 하며 말하는 연습을 하는 것을 추천한다.추가적으로 작은 팁을 주자면 SSAFY의 커리큘럼을 확인하고 내가 이 커리큘럼을 얼마나 원하고 잘 따라갈 수 있는지 얘기해 주면 좋은 인상을 줄 수 있을 것이다.쓰다 보니 너무 길어져서 SSAFY 교육 과정에 대한 이야기는 다음 글에서 이어가겠다.긴 글 읽어 주셔서 감사드리고 SSAFY를 준비하신다면 이 글이 도움이 되었기를 바란다." }, { "title": "Thymeleaf", "url": "/posts/Thymeleaf/", "categories": "Server, Spring", "tags": "Thymeleaf, Spring, Backend, Web", "date": "2022-02-10 14:41:00 +0900", "snippet": "타임리프는 템플릿 엔진의 한 종류이다. 타임리프에 대해 알아보기 전에 템플릿 엔진에 대한 개념을 잡고 가겠다.템플릿 엔진(Template Engine)이란?템플릿 엔진이란 템플릿 양식과 특정 데이터 모델에 따른 입력 자료를 합성하여 결과 문서를 출력하는 소프트웨어(또는 소프트웨어 컴포넌트)를 말한다. 다시 말해 HTML과 데이터를 합성하여 결과물을 만들어 주는 도구이다.그러면 템플릿 엔진의 종류에는 어떤 것들이 있을까?템플릿 엔진의 종류에는 크게 서버 사이드 템플릿 엔진과 클라이언트 사이드 템플릿 엔진 두 가지가 있다. 서버 사이드 템플릿 엔진 서버에서 DB 혹은 API로 가져온 데이터를 미리 정의된 Template에 넣어 HTML을 그리는 역할을 수행한다. 즉, HTML 코드에서 고정적으로 사용되는 부분은 템플릿으로 만들어두고 동적으로 생성되는 부분만 템플릿의 특정 장소에 끼워 넣는 방식으로 동작할 수 있도록 한다. Ex) Thymeleaf, Freemarker, Groovy, Mustache, JSP, Velocity, jade4j, Handlebars(Handlebars.java), EJS(Embedded JavaScript Templates) 등 클라이언트 사이드 템플릿 엔진 HTML 형태로 코드를 작성할 수 있으며, 데이터를 받아와 DOM을 동적으로 그릴 수 있도록 한다. Ex) Mustache, Squirrelly, Handlebars(Handlebars.js) 등 이런 템플릿 엔진을 사용하는 이유는 세 가지가 있다. 기존의 HTML에 비해 문법이 간단하여 많은 코드를 줄일 수 있다. 데이터만 바뀌는 경우가 많이 때문에 재사용성이 높다. 유지 보수가 용이하다.타임리프(Thymeleaf)란?타임리프는 템플릿 엔진의 한 종류이다. JSP, Freemarker와 같이 백엔드 쪽에서 클라이언트에게 응답할 브라우저 화면을 만들어 주는 역할을 한다.아래와 같은 세 가지의 특징을 가지고 있다. 서버 사이드 HTML 렌더링(SSR) 타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링 하는 용도로 사용된다. 네츄럴 템플릿 타임리프는 순수 HTML을 최대한 유지하는 특징이 있다. 타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다. JSP를 포함한 다른 뷰 템플릿들은 해당 파일을 열면, 예를 들어서 JSP 파일 자체를 그대로 웹 브라우저에서 열어보면 JSP 소스코드와 HTML이 뒤죽박죽 섞여서 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다. 오직 서버를 통해서 JSP가 렌더링 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다. 반면에 타임리프로 작성된 파일은 해당 파일을 그대로 웹 브라우저에서 열어도 정상적인 HTML 결과를 확인할 수 있다. 물론 이 경우 동적으로 결과가 렌더링 되지는 않는다. 하지만 HTML 마크업 결과가 어떻게 되는지 파일만 열어도 바로 확인할 수 있다. 이렇게 순수 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 네츄럴 템플릿(natural templates)이라 한다. 스프링 통합 지원 타임리프는 스프링과 자연스럽게 통합되고, 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원한다. 지금까지 템플릿 엔진과 타임리프의 기본 개념을 알아봤다. 사실 타임리프의 사용법까지 정리하려고 했지만 글이 너무 길어질 것 같아 공식 문서 링크로 대체한다. 정리가 정말 잘 되어있으니 필요할 때마다 접속해 보시는 것을 추천한다. 공식 사이트: https://www.thymeleaf.org/ 공식 메뉴얼 - 기본 기능: https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html 메뉴얼 - 스프링 통합: https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.htmlReference 백엔드 웹 개발 활용 기술 - 인프런 Thymeleaf란 - MAENCO" }, { "title": "카카오뱅크 채용연계형 인턴 합격 후기", "url": "/posts/%EC%B9%B4%EC%B9%B4%EC%98%A4%EB%B1%85%ED%81%AC-%EC%B1%84%EC%9A%A9%EC%97%B0%EA%B3%84%ED%98%95-%EC%9D%B8%ED%84%B4-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/", "categories": "회고록", "tags": "카카오뱅크, 카카오, 채용연계형, 인턴", "date": "2022-02-08 13:54:00 +0900", "snippet": "카카오뱅크 채용연계형 Tech 인턴십에 지원했던 후기를 남긴다.서류 전형카카오뱅크의 채용사이트를 통해 지원했고 기본적인 인적 사항과 자기소개서, 포트폴리오를 제출했다.자기소개서는 지원 동기, 차별화되 역량 두 가지 항목이 있었다. 다른 기업들에 비해 상대적으로 간단한 편이었어서 부담 없이 작성했던 것 같다.코딩 테스트4문제가 출제되었고 3시간이 주어졌다. 문제의 난이도는 보통 정도였던 것 같다. 대체로 어렵지 않았으나 2번 문제는 시간 복잡도를 생각해야 했고 3번 문제는 구현량이 조금 많았다.첫 번째 문제는 단순하게 구현하면 되는 문제였다. 사실 간단한 문제였어서 기억이 잘 나지 않는다.두 번째 문제는 문자열 문제였다. 처음에는 단순히 2중 포문 돌리면 끝나는 문제라고 생각하고 제출했지만 제한 시간이 초과되었다. 문제에서 제시한 조건의 범위가 크기 때문에 다른 방법이 필요했다. 문제를 다시 정독하다가 중복된 입력값이 들어올 수 있다는 것을 발견했고 Map을 활용해 문제를 해결했다.세 번째 문제는 백트래킹 문제였는데, 사실 난이도에 비해 너무 쉽게 풀었다. 이유는 며칠 전 이베이코리아 코딩 테스트를 봤는데, 거기 1번 문제와 완전히 동일한 문제였다. 그래서 보자마자 술술 풀었다.(개꿀)네 번째 문제는 첫 번째 문제와 동일하게 단순하게 구현하는 문제였다. 임팩트가 없어 잘 기억이 나지 않는다.코드 리뷰코딩 테스트에 대해 코드 리뷰하는 시간이 있었다. 30분 정도가 소요되었고 면접관 두 분과 1:2로 진행되었다. 전에 제출했던 코드를 보여주시면서 어떻게 풀었는지 설명하라고 하셨고 더 궁금한 부분은 추가 설명을 요청하셨다. 코딩 테스트를 직접 풀었다면 어렵지 않게 통과할 것이라고 생각한다.면접총 두 번의 면접이 있었다. 1차 면접은 약 50분 정도 소요되었고 면접관 세 분과 1:3로 진행되었다. 면접의 분위기는 매우 편안했다. 면접관분들이 정말 친절하셔서 자연스럽게 대화하는 느낌이었다. CS보다는 프로젝트 위주의 질문이었고 구체적으로 어떤 경험을 했는지 궁금해하셨다. 개인적으로 이제까지 본 면접 중 가장 긍정적인 면접이었다.2차 면접은 판교 카카오뱅크 사옥에서 진행되었다. 대면 면접은 처음이었고 판교에도 처음 가본지라 엄청 긴장을 했었다. 데스크 직원분의 친절한 안내를 통해 어떤 회의실에서 조금 대기하다 면접실로 입장했다. 면접은 1:2로 CTO님과 팀장님(확실하지 않음) 두 분이서 봐주셨다.사실 2차 면접은 1차 면접의 긍정적인 느낌과 반대되는 경험이었다. 일단 면접관분들께서 이력서와 포트폴리오를 보지 않은 느낌이었고, 질문도 최근의 경험에 대한 내용은 하나도 없이 직무와 관계없는 대학교 시절의 이야기만 하셨다. 지금 생각해 보면 “제가 이런 경험을 했고 관련된 질문 부탁드린다”라고 말씀드릴 걸 하는 후회가 남는다.그렇게 2차 면접은 ‘망했다’라고 생각했고 아픈 마음을 가지고 집으로 내려갔다. 그런데 며칠 뒤 의외로 최종 합격 메일을 받았다. 정말 기대도 안 했는데, 아마 1차 면접의 면접관분들의 입김이 있었지 않았을까…입사 포기아무튼 우여곡절 끝에 최종 합격을 했지만 입사는 포기했다. 이베이코리아의 정규직과 카카오뱅크의 인턴 사이에 정말 많은 고민을 했는데, 아무래도 정규직이 아닌 인턴이라는 것이 크게 작용했다. 개인적으로 카카오에서 일하는 것을 꿈꿨기에 너무 아쉬웠지만 기회는 다음에도 있을 것이라고 생각한다. 지금은 빠르게 많이 배우고 경력을 쌓아 신입티를 벗는 것이 목표이다." }, { "title": "이베이코리아 신입 공채 합격 후기", "url": "/posts/%EC%9D%B4%EB%B2%A0%EC%9D%B4%EC%BD%94%EB%A6%AC%EC%95%84-%EC%8B%A0%EC%9E%85-%EA%B3%B5%EC%B1%84-%ED%95%A9%EA%B2%A9-%ED%9B%84%EA%B8%B0/", "categories": "회고록", "tags": "이베이코리아, 지마켓글로벌, 개발자, 공채", "date": "2022-02-06 16:42:00 +0900", "snippet": "취직을 하고 기술블로그를 시작하게 되었다. 앞으로의 성장 과정을 기록하고 지금까지의 경험을 정리해보려 한다. 첫 게시글로 합격 후기를 작성한다.좋은 기회로 서버 개발자로서의 첫걸음을 이베이코리아에서 시작하게 되었다.지원이번 이베이코리아 신입 개발자 공채는 지원이 정말 쉬웠다. 자기소개서는 필요하지 않았고 간단한 인적 사항만을 입력해 지원을 완료했다. 블라인드로 모든 사람들에게 기회를 제공하겠다는 의지가 보였다.코딩 테스트코딩 테스트는 총 5문제가 출제되었고 2시간이 주어졌다. 문제의 난이도는 여타 코딩 테스트와 비교했을 때 상당히 어려운 편이었다.첫 번째 문제는 백트래킹 문제였고 25분 정도 소요됐다. 첫 번째 문제를 보고 난이도가 심상치 않다는 것을 느꼈다. 첫 번째 문제부터 코드의 구현량이 조금 많았다. 그래도 복잡한 문제는 아니었기 때문에 술술 풀렸다.두 번째 문제에서 난관에 부딪혔다. 30분 정도 소요해서 구현하고 제출했는데 여러 테스트 케이스 중에서 1개만 시간 초과가 났다. 이 한 개의 테스트케이스를 해결하려고 남은 시간을 다 썼고 결국 해결하지 못했다. 그 테스트케이스를 제외하고는 시간이 얼마 걸리지 않아서 집착을 했던 것 같다.그렇게 코딩 테스트가 종료되었고 빨리 다음 문제로 넘어가지 않았던 나를 자책했다. 그 당시 느낌으로는 적어도 2솔은 해야 합격할 줄 알았다. 그런데 결과는 합격이었고 주변 이야기를 들어보니 1.5솔 이상이면 합격했다는 것 같았다.면접코딩 테스트에 합격하고 자기소개서를 제출하라는 메일이 왔다. 지원을 할때 정말 간단한 인적 사항만을 제출했기 때문에, 면접에 앞서 지원자들이 어떤 경험과 생각을 가지고 있는지 확인하려는 것 같았다.면접은 총 한 번이었다. 보통 기술면접과 임원면접 두 번의 면접이 있어서 나는 그게 최종 면접인 줄 몰랐다. 면접이 2일 남기고 최종 면접이라는 것을 알게 되었고(바보인가..?) 급하게 면접 준비를 시작했다.급하게 준비한 만큼 스스로 부족하다고 생각했기 때문에 잔뜩 긴장한 상태로 면접이 시작되었다. 면접관은 4명이었고 지원자는 나 혼자였다. 긴장한 탓에 초반에는 답변을 잘 하지 못했다. 하지만 면접관분들이 긴장을 풀어주려고 노력하셨고 점점 긴장이 풀어지며 나름 잘 마무리했다.면접의 난이도는 조금 어려운 편이었다. 달달 외우는 CS지식보다는 제대로 이해하고 있는지를 확인하려고 하셨고, 프로젝트 경험에 대해서 많은 질문을 하셨다. 프로젝트에 대해서는 그래도 잘 준비했기 때문에 운 좋게 합격할 수 있었던 것 같다.입사현재는 신입사원으로 근무를 하고 있다. 첫 한 달간은 교육 기간으로, 회사의 체계나 문화를 배우고 토이 프로젝트를 진행하며 회사에 적응하려고 노력하고 있다. 앞으로 정말 열심히 일할 것이고 최대한 많은 것들을 배워 빠르게 성장하는 것이 목표다.부족한 첫 게시글을 읽어주셔서 감사드립니다.앞으로 유익한 내용을 많이 전달할 수 있도록 노력하겠습니다. 파이팅." } ]
