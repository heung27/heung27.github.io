---
layout: post
title: Item 7. 다 쓴 객체 참조를 해제하라 (미완성)
date: 2022-04-27 00:04 +0900
categories: [Book, Effective Java]
tags: [Java, Effective Java, Static Factory Method, Caching, Auto Boxing]
---



Effective Java의 일곱 번째 아이템 "다 쓴 객체 참조를 해제하라"를 읽고 정리한 내용을 포스팅합니다.

<br>

## 0. 들어가며

자바는 다 쓴 객체를 GC(Garbage Collector)가 알아서 회수해 갑니다. 그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 이는 절대 사실이 아닙니다. 본문에서 다 쓴 참조가 해제되지 않아 메모리 누수가 발생하는 예와 해결 방법을 알아보겠습니다.

<br>

## 1. 메모리 누수 예

### 1.1 메모리 직접 관리

메모리를 직접 관리하는 클래스를 사용할 때는 메모리 누수에 주의해야 합니다. 다음은 스택을 구현한 예제입니다. 

```java
public class Stack {
  
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
  
    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.
     * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
     */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

위 예제에서는 스택에 원소가 쌓였다가 pop될때 메모리 누수가 일어납니다. 더 이상 사용되지 않을 꺼내진 객체들을 GC는 회수하지 않습니다. 그 이유는 스택이 그 객체들의 다 쓴 참조를 여전히 가지고 있기 때문입니다. 여기서 다 쓴 참조란 문자 그대로 앞으로 다시 쓰지 않을 참조를 뜻합니다. 위의 예제에서는 elements 배열의 '활성 영역' 밖의 참조들이 모두 여기에 해당합니다. 활성 영역은 인덱스가 size보다 작은 원소들로 구성됩니다.

GC 언어에서는 메모리 누수를 찾기가 아주 까다롭습니다. 객체 참조 하나를 살려두면 GC는 그 객체뿐아니라 그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체)를 회수해가지 못합니다. 때문에 단 몇 개의 객체가 매우 많은 객체를 회수하지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있습니다. 

이를 해결하기 위한 방법은 간단합니다. 해당 참조를 다 썼을 때 null 처리(참조 해제)하면 됩니다. 다음은 pop 메서드를 개선한 코드입니다.

```java
public Object pop() {
  if (size == 0)
    throw new EmptyStackException();
  Object result = elements[--size];
  elements[size] = null; // 다 쓴 참조 해제
  return result;
}
```

다 쓴 참조를 null 처리하면 다른 이점도 따라옵니다. 만약 null 처리한 참조를 실수로 사용하려 하면 프로그램은 즉시 NullPointerException을 던지며 종료됩니다. 프로그램 오류는 가능한 한 조기에 발견하는게 좋습니다.

<br>

### 1.2 캐시

캐시 역시 메모리 누수를 읽으키는 주범입니다. 객체 참조를 캐시에 넣고 나서, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있습니다. 해법은 여러가지인데, 운 좋게 

<br>

### 1.3 리스너와 콜백





<br>

## 2. 핵심 정리

메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.

<br>

## 3. Related Posts

- 변수의 범위 (Item 57)

