---
layout: post
title: Item 7. 다 쓴 객체 참조를 해제하라 (미완성)
date: 2022-04-27 00:04 +0900
categories: [Book, Effective Java]
tags: [Java, Effective Java, Static Factory Method, Caching, Auto Boxing]
---



Effective Java의 일곱 번째 아이템 "다 쓴 객체 참조를 해제하라"를 읽고 정리한 내용을 포스팅합니다.

<br>

## 0. 들어가며

자바는 다 쓴 객체를 GC(Garbage Collector)가 알아서 회수해 갑니다. 그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 이는 절대 사실이 아닙니다. 가비지 컬렉션 언어에서는 의도치 않게 객체를 살려두는 '**메모리 누수**'를 찾기가 아주 까다롭습니다. 객체 참조 하나를 살려두면 GC는 그 객체뿐아니라 그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체)를 회수해가지 못합니다. 때문에 단 몇 개의 객체가 매우 많은 객체를 회수하지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있습니다. 

본문에서 다 쓴 참조(앞으로 다시 쓰지 않을 참조)가 해제되지 않아 메모리 누수가 발생하는 예와 해결 방법을 알아보겠습니다.

<br>

## 1. 메모리 누수 예

CG가 알아서 다 쓴 객체를 회수해가는데 왜 메모리 누수가 발생하는 걸까요? 원인은 프로그래머가 작성한 클래스에 있습니다. 어떤 **클래스가 자기 메모리를 직접 관리**한다면, GC는 해당 메모리가 더 이상 쓸일이 없는 참조라는 것을 인식하지 못 하게될 수 있습니다. 따라서 여전히 다 쓴 참조가 해제되지 않고 메모리 누수가 발생하는 것입니다. 세 가지 예제를 통해 자세히 알아보겠습니다.

### 1.1 스택

스택은 아시다시피 후입선출 방식의 자료구조 입니다. java.util 패키지에서 구현체를 제공해주지만, 메모리 누수가 발생하는 상황을 만들기 위해 구현한 예제 코드입니다.

```java
public class Stack {
  
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
  
    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.
     * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
     */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

위 예제에서는 스택에 원소가 쌓였다가(push) 꺼내질때(pop) 메모리 누수가 일어납니다. 더 이상 사용되지 않을 꺼내진 객체들을 GC는 회수하지 않습니다. 그 이유는 스택이 해당 객체들의 다 쓴 참조를 여전히 가지고 있기 때문입니다. 위의 예제에서는 elements 배열의 '활성 영역' 밖의 참조들이 모두 여기에 해당합니다. 여기서 활성 영역은 size보다 작은 인덱스를 말합니다.

이를 해결하기 위한 방법은 간단합니다. 해당 **참조를 다 썼을 때 null 처리(참조 해제)**해주면 됩니다. 다음은 pop 메서드를 개선한 코드입니다.

```java
public Object pop() {
  if (size == 0)
    throw new EmptyStackException();
  Object result = elements[--size];
  elements[size] = null; // 다 쓴 참조 해제
  return result;
}
```

이렇게 다 쓴 참조를 null 처리해줌으로 따라오는 추가적인 이점이 있습니다. 만약 null 처리한 참조를 실수로 사용하려고 하면 프로그램은 즉시 NullPointerException을 던지며 종료됩니다. 미리 null 처리하지 않았다면 아무 내색 없이 무언가 잘못된 일을 수행하고 있을지도 모릅니다. 프로그램 오류는 가능한 한 조기에 발견하는것이 좋습니다.

<br>

그런데, **모든 객체를 다 쓰자마자 일일이 null 처리하는 것은 바람직하지 않습니다.** 프로그램을 필요 이상으로 지저분하게 만들 뿐이죠. 객체 참조를 null 처리하는 일은 예외적인 경우여야 합니다. **다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(scope) 밖으로 밀어내는 것입니다.** 유효 범위 밖으로 밀려난 참조는 GC가 알아서 해제할 것입니다.

그렇다면 null 처리는 언제 해야 할까요? 예제의 Stack 클래스는 왜 null 처리가 필요한 걸까요? 이유는 elements 배열로 저장소 풀을 만들어 원소들을 관리(자기 메모리를 직접 관리)하기 때문입니다. 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않습니다. 문제는 GC가 이 사실을 알 길이 없다는 것입니다. GC의 관점에서는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체입니다. 비활성 영역의 객체가 더 이상 쓸모없다는 것은 프로그래머만 아는 사실입니다. 때문에 프로그래머는 비활성 영역이 되는 순간 null 처리해서 해당 객체는 더 이상 쓰지않을 것임을 GC에 알려야 합니다.

<br>

### 1.2 캐시

캐시 역시 메모리 누수를 일으키는 주범입니다. 객체 참조를 캐시에 넣고 나서, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있습니다. 

```java

```

해결 방법은 여러가지인데, 운 좋게 캐시 외부에서 key를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap을 사용해 캐시를 만드는 것을 권장합니다. 다 쓴 엔트리는 그 즉시 자동으로 제거될 것입니다. 단, WeakHashMap은 이러한 상황에서만 유용하다는 사실을 기억해야 합니다.

```java
```

WeakHashMap란..



캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용합니다. 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 합니다. (Scheduled ThreadPoolExecutor 같은) 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법이 있습니다. ...

```java
```



<br>

### 1.3 리스너와 콜백

클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 뭔가 조치해주지 않는 한 콜백은 계속 쌓여갈 것이다. 이럴 때 콜백을 약한 참조로 저장하면 GC가 즉시 수거해간다. 예를 들어 WeakHashMap에 키로 저장하면 된다.

```java
```





<br>

## 2. 핵심 정리

메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 이런 누수는 철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.

책에서 소개한 메모리 누수의 예는 스택, 캐시, 리스너와 콜백 이렇게 세가지이다. 그리고 해결방법으로는 직접 null 처리, 백그라운드 스레드 사용, 특정한 자료구조 사용

<br>

## 3. Related Posts

- 변수의 범위 (Item 57)

