---
layout: post
title: Item 13. clone 재정의는 주의해서 진행하라 (미완성)
date: 2022-05-24 23:26 +0900
categories: [Book, Effective Java]
tags: [Java, Effective Java, Override, clone]
---



Effective Java의 열세 번째 아이템 "clone 재정의는 주의해서 진행하라"를 읽고 정리한 내용을 포스팅합니다.

<br>

## 0. 들어가며



<br>

## 1. Cloneable 인터페이스



<br>

## 2. 일반 규약

이 객체의 복사본을 생성해 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다. 일반적인 의도는 다음과 같다. 어떤 객체 x에 대해 다음 식은 참이다.

`x.clone() != x`

또한 다음 식도 참이다.

`x.clone().getClass() == x.getClass()`

하지만 이상의 요구를 받드시 만족해야 하는 것은 아니다.

한편 다음 식도 일반적으로 참이지만, 역시 필수는 아니다.

`x.clone().equals(x)`

관례상, 이 메서드가 반환하는 객체는 super.clone을 호출해 얻어야 한다. 이 클래스와 (Object를 제외한) 모든 상위 클래스가 이 관례를 따른다면 다음 식은 참이다.

`x.clone().getClass() == x.getClass()`

관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.

<br>

## 3. 가변 상태를 참조하지 않는 클래스

- PhoneNumber

<br>

## 4. 가변 상태를 참조하는 클래스

- Stack

<br>

## 5. 복잡한 가변 상태를 참조하는 클래스

- HashTable
- 재귀
- 반복
- 고수준 메서드

<br>

## 6. 주의할 점

- clone에서는 재정의될 수 있는 메서드를 호출하지 않아야 한다.
- 상속해서 쓰기 위한 클래스 설계 방식 두 가지 중 어느 쪽에서든, 상속용 클래스는 Cloneable을 구현해서는 안 된다.
- Cloneable을 구현한 Thread-Safe한 클래스를 작성할 때는 clone 메서드 역시 적절히 동기화해줘야 한다.

<br>

## 7. 더 나은 객체 복사 방식

- 복사 생성자와 복사 팩터리

<br>

## 8. 핵심 정리

- 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안된다.
- 새로운 클래스도 Cloneable을 구현해서는 안된다.
- final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 그물게 허용해야 한다.
- 기본 원칙은 '복제 기능은 생성자와 팩터리를 이용하는 것이 최고'라는 것이다.
- 예외적으로 배열은 clone 메서드 방식이 가장 깔끔한 복제 방법이다.

<br>

## 9. Related Posts

- 믹스인 인터페이스 (Item 20)
- 리플렉션 (Item 65)
- Checked Exception (Item 71)
- 상속을 고려한 설계 (Item 19)
- 동기화 (Item 78)
