<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://github.com/heung27/</id><title>H's Tech Blog</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-07-09T15:33:40+09:00</updated> <author> <name>Jin Heung An</name> <uri>https://github.com/heung27/</uri> </author><link rel="self" type="application/atom+xml" href="https://github.com/heung27/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://github.com/heung27/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Jin Heung An </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라</title><link href="https://github.com/heung27/posts/item-22-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EC%9A%A9%EB%8F%84%EB%A1%9C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="Item 22. 인터페이스는 타입을 정의하는 용도로만 사용하라" /><published>2022-07-09T14:49:00+09:00</published> <updated>2022-07-09T14:49:00+09:00</updated> <id>https://github.com/heung27/posts/item-22-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EC%9A%A9%EB%8F%84%EB%A1%9C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id> <content src="https://github.com/heung27/posts/item-22-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EC%9A%A9%EB%8F%84%EB%A1%9C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" /> <author> <name>Jin Heung An</name> </author> <category term="Book" /> <category term="Effective Java" /> <summary> Effective Java의 스물두 번째 아이템 “인터페이스는 타입을 정의하는 용도로만 사용하라”를 읽고 정리한 내용을 포스팅합니다. 1. 인터페이스의 용도 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 달리 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있을지를 클라이언트에게 얘기해주는 것이다. 인터페이스는 오직 이 용도로만 사용해야 한다. 2. 상수 인터페이스 위의 지침에 맞지 않는 예로 상수 인터페이스라는 것이 있다. 상수 인터페이스란 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다. 그리고 이 상수들을 사용하려는 클래스에서는 정규화된 이름을 쓰는 걸 피하고자 그 인터페이... </summary> </entry> <entry><title>Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라</title><link href="https://github.com/heung27/posts/item-21-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라" /><published>2022-07-09T13:41:00+09:00</published> <updated>2022-07-09T15:33:17+09:00</updated> <id>https://github.com/heung27/posts/item-21-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/</id> <content src="https://github.com/heung27/posts/item-21-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/" /> <author> <name>Jin Heung An</name> </author> <category term="Book" /> <category term="Effective Java" /> <summary> Effective Java의 스물한 번째 아이템 “인터페이스는 구현하는 쪽을 생각해 설계하라”를 읽고 정리한 내용을 포스팅합니다. 1. 인터페이스 설계에서 주의할 점 Java 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다. Java 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만, 위험이 완전히 사라진 것은 아니다. 디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 이처럼 Java에도 기존 인터페이스에 메서드를 추가하는 길이 열렸지만, 모든 기존 구현체들과 매끄럽게 연동되리라는 보장은 없다. Java 8에서는 핵심 컬렉션 인터페이스들에 다... </summary> </entry> <entry><title>Item 20. 추상 클래스보다는 인터페이스를 우선하라</title><link href="https://github.com/heung27/posts/item-20-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="Item 20. 추상 클래스보다는 인터페이스를 우선하라" /><published>2022-07-03T18:24:00+09:00</published> <updated>2022-07-03T21:29:00+09:00</updated> <id>https://github.com/heung27/posts/item-20-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC/</id> <content src="https://github.com/heung27/posts/item-20-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC/" /> <author> <name>Jin Heung An</name> </author> <category term="Book" /> <category term="Effective Java" /> <summary> Effective Java의 스무 번째 아이템 “추상 클래스보다는 인터페이스를 우선하라”를 읽고 정리한 내용을 포스팅합니다. 1. 추상 클래스와 인터페이스 Java가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두 가지다. Java 8부터 인터페이스도 디폴트 메서드를 제공할 수 있게 되어, 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다. 한편, 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. Java는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 되는 셈이다. 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 ... </summary> </entry> <entry><title>Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라</title><link href="https://github.com/heung27/posts/item-19-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%84%9C%ED%99%94%ED%95%98%EB%9D%BC-%EA%B7%B8%EB%9F%AC%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%88%EC%A7%80%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라" /><published>2022-07-02T15:31:00+09:00</published> <updated>2022-07-03T18:27:31+09:00</updated> <id>https://github.com/heung27/posts/item-19-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%84%9C%ED%99%94%ED%95%98%EB%9D%BC-%EA%B7%B8%EB%9F%AC%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%88%EC%A7%80%ED%95%98%EB%9D%BC/</id> <content src="https://github.com/heung27/posts/item-19-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%84%9C%ED%99%94%ED%95%98%EB%9D%BC-%EA%B7%B8%EB%9F%AC%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%88%EC%A7%80%ED%95%98%EB%9D%BC/" /> <author> <name>Jin Heung An</name> </author> <category term="Book" /> <category term="Effective Java" /> <summary> Effective Java의 열아홉 번째 아이템 “상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라”를 읽고 정리한 내용을 포스팅합니다. 1. 상속을 고려한 설계와 문서화 1) 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다. API 문서의 메서드 설명 끝에서 종종 “Implementation Requirements”로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다. 다음은 java.util.AbstractCollection에서 발췌한 예다. public boolean remove(Object o) ... </summary> </entry> <entry><title>2장. 테스트</title><link href="https://github.com/heung27/posts/2%EC%9E%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/" rel="alternate" type="text/html" title="2장. 테스트" /><published>2022-06-26T18:21:00+09:00</published> <updated>2022-06-26T18:21:00+09:00</updated> <id>https://github.com/heung27/posts/2%EC%9E%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/</id> <content src="https://github.com/heung27/posts/2%EC%9E%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8/" /> <author> <name>Jin Heung An</name> </author> <category term="Book" /> <category term="토비의 스프링" /> <summary> 2.1 UserDaoTest 다시 보기 2.1.1 테스트의 유용성 코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 때와 다를 바 없이 기능을 잘 수행한다는 것을 보장하는 방법은 테스트를 통해 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다. 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다. 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다. 2.1.2 UserDaoTest의 특징 public class UserDaoTest... </summary> </entry> </feed>
