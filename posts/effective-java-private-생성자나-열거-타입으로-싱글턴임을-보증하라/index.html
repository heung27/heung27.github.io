<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라" /><meta property="og:locale" content="en" /><meta name="description" content="Effective Java의 세 번째 아이템 “private 생성자나 열거 타입으로 싱글턴임을 보증하라”를 읽고 정리한 내용을 포스팅합니다." /><meta property="og:description" content="Effective Java의 세 번째 아이템 “private 생성자나 열거 타입으로 싱글턴임을 보증하라”를 읽고 정리한 내용을 포스팅합니다." /><link rel="canonical" href="https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/" /><meta property="og:url" content="https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/" /><meta property="og:site_name" content="H’s Tech Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-12T23:45:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-23T00:29:57+09:00","datePublished":"2022-04-12T23:45:00+09:00","description":"Effective Java의 세 번째 아이템 “private 생성자나 열거 타입으로 싱글턴임을 보증하라”를 읽고 정리한 내용을 포스팅합니다.","headline":"Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/"},"url":"https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/"}</script><title>Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라 | H's Tech Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="H's Tech Blog"><meta name="application-name" content="H's Tech Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/me.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">H's Tech Blog</a></div><div class="site-subtitle font-italic">주니어 서버 개발자의 성장기</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/heung27" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wlsgmd1535','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/heung27">Jin Heung An</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1649774700" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-12 </em> </span> <span> Updated <em class="timeago" data-ts="1650641397" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-23 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3659 words"> <em>20 min</em> read</span></div></div></div><div class="post-content"><p>Effective Java의 세 번째 아이템 “private 생성자나 열거 타입으로 싱글턴임을 보증하라”를 읽고 정리한 내용을 포스팅합니다.</p><p><br /></p><h2 id="1-싱글턴singleton">1. 싱글턴(singleton) <a href="#1-싱글턴singleton" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>싱글턴이란 어떤 클래스가 최초 한 번만 메모리를 할당하고, 그 메모리의 인스턴스를 만들어 사용하는 디자인 패턴입니다. 즉, 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다.</p><p>싱글턴의 전형적인 예로는 함수와 같은 무상태(stateless) 객체나 설계상 유일해야 하는 시스템 컴포넌트를 들 수 있습니다.</p><p><br /></p><h2 id="2-사용하는-이유">2. 사용하는 이유 <a href="#2-사용하는-이유" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>인스턴스가 한 개만 생성되도록 하면 어떤 이점이 있을까요?</p><p>가장 먼저 떠올릴 수 있는 이점은 아무래도 <strong>메모리</strong>일 것입니다. 최초 한 번의 new 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때 메모리 낭비를 방지할 수 있습니다. 또한 객체의 두 번째 접근부터는 객체 로딩이 줄어 더 빠른 <strong>속도</strong>을 기대할 수 있습니다.</p><p>또 다른 이점은 <strong>데이터 공유</strong>가 쉽다는 것입니다. 인스턴스가 전역으로 사용되기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있습니다.</p><p>이외에도 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶은 경우 사용합니다.</p><p><br /></p><h2 id="3-싱글턴-구현-방식">3. 싱글턴 구현 방식 <a href="#3-싱글턴-구현-방식" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>인스턴스가 오직 한 개만 존재하도록 하는 이 싱글턴을 구현하는 세 가지 방식을 알아보겠습니다.</p><h4 id="31-public-필드">3.1 public 필드 <a href="#31-public-필드" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p><strong>생성자는 private으로 감춰두고, 유일한 인스턴스에 접근할 수 있는 수단으로 public 필드를 제공하는 방식</strong>입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">();</span>

    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>private 생성자는 public static final 필드인 <code class="language-plaintext highlighter-rouge">Elvis.INSTANCE</code>를 초기화할 때 딱 한 번만 호출됩니다. public이나 protected 생성자가 없기 때문에 Elvis 클래스가 초기화될 때 만들어진 인스턴스가 전체 시스템에서 하나뿐임이 보장됩니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
<span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span> <span class="o">==</span> <span class="n">elvis2</span><span class="o">);</span>
<span class="cm">/* 실행 결과
true
*/</span>
</pre></table></code></div></div><p>public 필드 방식의 장점은 해당 클래스가 <strong>싱글턴임이 API에 명백히 드러난다</strong>는 것입니다. public static 필드가 final이니 절대로 다른 객체를 참조할 수 없습니다. 두 번째 장점은 <strong>간결함</strong>입니다. 구현이 쉬워 코드가 깔끔하고 가독성도 좋습니다.</p><p><br /></p><p>그런데 예외 상황이 있습니다. 권한이 있는 클라이언트는 <strong>리플렉션 API인 <code class="language-plaintext highlighter-rouge">AccessibleObject.setAccessible</code>을 사용하면 private 생성자를 호출할 수 있습니다.</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">try</span> <span class="o">{</span>
  <span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Elvis</span><span class="o">&gt;</span> <span class="n">defaultConstructor</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">();</span>
  <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// private 생성자 호출 허용</span>
  
  <span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
  <span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
  
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span> <span class="o">==</span> <span class="n">elvis2</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchMethodException</span> <span class="o">|</span> <span class="nc">InvocationTargetException</span> <span class="o">|</span> <span class="nc">InstantiationException</span> <span class="o">|</span> <span class="nc">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/* 실행 결과
false
*/</span>
</pre></table></code></div></div><p>먼저 <code class="language-plaintext highlighter-rouge">Elvis.class.getDeclaredConstructor</code> 메서드를 통해 Constructor 객체를 얻습니다. 그리고 <code class="language-plaintext highlighter-rouge">setAccessible(true)</code>를 사용해 private 생성자 호출을 허용하면 <code class="language-plaintext highlighter-rouge">newInstance()</code>를 통해 새로운 인스턴스를 생성할 수 있습니다. 이제 elvis1과 elvis2 인스턴스를 비교해 보면 false가 출력되는 것을 확인할 수 있습니다.</p><p>이러한 공격을 방어하기 위해서는 생성자를 수정하여 두 번째 객체가 생성되려 할 때 예외를 던지도록 해야 합니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">();</span>
  
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">created</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 인스턴스가 이미 만들어졌을 경우 예외 throw</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">created</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">(</span><span class="s">"can't be created by constructor."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">created</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이제 다시 테스트를 해 보겠습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// 수정된 Elvis 테스트</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Elvis</span><span class="o">&gt;</span> <span class="n">defaultConstructor</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">();</span>
  <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
  
  <span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> <span class="c1">// 에러</span>
  <span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="n">defaultConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> <span class="c1">// 에러</span>
  
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span> <span class="o">==</span> <span class="n">elvis2</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchMethodException</span> <span class="o">|</span> <span class="nc">InvocationTargetException</span> <span class="o">|</span> <span class="nc">InstantiationException</span> <span class="o">|</span> <span class="nc">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/* 실행 결과
java.lang.reflect.InvocationTargetException
Caused by: java.lang.UnsupportedOperationException: can't be created by constructor.
...
*/</span>
</pre></table></code></div></div><p>Elvis 클래스의 <code class="language-plaintext highlighter-rouge">public static final Elvis INSTANCE = new Elvis();</code>에서 이미 인스턴스를 만들었기 때문에 보이는 것과 같이 UnsupportedOperationException가 발생했습니다. 이제는 리플렉션을 통해 새로운 인스턴스를 생성할 수 없어졌습니다.</p><p><br /></p><p>한 가지 더 문제점이 있습니다. <strong>역직렬화를 할때 새로운 인스턴스가 생길 수 있다</strong>는 것입니다. 먼저 Elvis 클래스의 직렬화를 위해 Serializable 인터페이스를 구현합니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">();</span>

    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>다음은 Elvis 클래스를 직렬화한 후 다시 역직렬화해 기존의 Elvis 인스턴스와 동일한지 비교하는 예제입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">try</span> <span class="o">(</span><span class="nc">ObjectOutput</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"elvis.obj"</span><span class="o">)))</span> <span class="o">{</span>
  <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">Elvis</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>

<span class="k">try</span> <span class="o">(</span><span class="nc">ObjectInput</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"elvis.obj"</span><span class="o">)))</span> <span class="o">{</span>
  <span class="nc">Elvis</span> <span class="n">elvis</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Elvis</span><span class="o">)</span> <span class="n">in</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis</span> <span class="o">==</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="o">|</span> <span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/* 실행 결과
false
*/</span>
</pre></table></code></div></div><p>실행 결과에서 알 수 있듯이 동일하지 않은 인스턴스가 생성되었습니다. 이를 해결하기 위해서는 Elvis 클래스에 readResolve 메서드를 추가해 주어야 합니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">();</span>

    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이제 다시 위의 테스트 코드를 실행시켜 보면 true를 출력하는 것을 확인할 수 있습니다. 역직렬화를 할 때 내부적으로 readResolve라는 메서드를 호출하도록 설계되어 있기 때문입니다.</p><p><br /></p><h4 id="32-정적-팩터리">3.2 정적 팩터리 <a href="#32-정적-팩터리" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p><strong>생성자와 필드는 private으로 감춰두고, 유일할 인스턴스를 접근할 수 있는 수단으로 정적 팩터리 메서드를 제공하는 방식</strong>입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">();</span>

    <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Elvis</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>다음은 정적 팩터리 메서드를 사용하여 두 객체를 만들고 인스턴스를 비교하는 예제입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
<span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span> <span class="o">==</span> <span class="n">elvis2</span><span class="o">);</span>
<span class="cm">/* 실행 결과
true
*/</span>
</pre></table></code></div></div><p>Elvis.getInstance 메서드는 항상 같은 객체의 참조를 반환하기 때문에 제2의 인스턴스는 결코 만들어지지 않습니다.</p><p><br /></p><p>정적 팩터리 방식의 첫 번째 장점은 <strong>API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다</strong>는 점입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
<span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis2</span><span class="o">);</span>
<span class="cm">/* 실행 결과
example.item3.Elvis@6aaa5eb0
example.item3.Elvis@6aaa5eb0
*/</span>
</pre></table></code></div></div><p>위와 같은 클라이언트 코드가 있습니다. Elvis가 싱글턴이니 elvis1과 elvis2는 같은 인스턴스를 참조하고 있을 것입니다. 하지만 어떤 이유로 인해 싱글턴이 아니게, 즉 서로 다른 인스턴스를 만들고 싶다면 어떻게 해야 할까요?</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Elvis</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Elvis</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>정적 팩터리 방식에서는 클라이언트 코드를 수정하지 않고 정적 팩터리 메서드를 수정하면 간단하게 변경할 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
<span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis2</span><span class="o">);</span>
<span class="cm">/* 실행 결과
example.item3.Elvis@6aaa5eb0
example.item3.Elvis@3498ed
*/</span>
</pre></table></code></div></div><p><br /></p><p>두 번째 장점은 <strong>정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다</strong>는 점입니다. 다음은 Elvis 클래스를 제네릭 싱글턴 팩터리 패턴으로 만든 예제입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Elvis</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
 
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Elvis</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Elvis</span><span class="o">&lt;&gt;();</span>
 
     <span class="kd">private</span> <span class="nf">Elvis</span><span class="o">()</span> <span class="o">{}</span>
 
     <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Elvis</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">return</span> <span class="o">(</span><span class="nc">Elvis</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span> <span class="no">INSTANCE</span><span class="o">;</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
 <span class="o">}</span>
</pre></table></code></div></div><p>제네릭 싱글턴 팩터리는 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리 입니다. 제네릭 싱글턴 팩터리를 사용하면 동일한 인스턴스를 참조하지만 서로 다른 타입의 객체를 만들 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nc">Elvis</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
<span class="nc">Elvis</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis2</span><span class="o">);</span>
<span class="o">/*</span> <span class="n">실행</span> <span class="n">결과</span>
<span class="n">example</span><span class="o">.</span><span class="na">item3</span><span class="o">.</span><span class="na">Elvis</span><span class="err">@</span><span class="mi">6</span><span class="n">aaa5eb0</span>
<span class="n">example</span><span class="o">.</span><span class="na">item3</span><span class="o">.</span><span class="na">Elvis</span><span class="err">@</span><span class="mi">6</span><span class="n">aaa5eb0</span>
<span class="o">*</span>
</pre></table></code></div></div><p>실행 결과를 보면 elvis1과 elvis2는 같은 인스턴스를 참조하고 있습니다. 하지만 둘은 서로 다른 타입을 가지고 있습니다.</p><p><br /></p><p>세 번째 장점은 <strong>정적 팩터리의 메서드 참조를 함수형 인터페이스 Supplier로 사용할 수 있다</strong>는 점입니다.</p><p>다음은 Java에서 제공하는 함수형 인터페이스 Supplier의 선언 부분입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="no">T</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Elvis의 getInstance 메서드는 인자는 받지 않고 인스턴스를 리턴합니다. 그 구조가 Supplier의 get 메서드와 동일합니다. 따라서 Elvis getInstance 메서드의 참조를 Supplier로 사용할 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Elvis</span><span class="o">&gt;</span> <span class="n">elvisSupplier</span> <span class="o">=</span> <span class="nl">Elvis:</span><span class="o">:</span><span class="n">getInstance</span><span class="o">;</span> <span class="c1">// 물론 람다식도 가능합니다. () -&gt; Elvis.getInstance();</span>

<span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="n">elvisSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="n">elvisSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis2</span><span class="o">);</span>
<span class="cm">/* 실행 결과
example.item3.Elvis@1a407d53
example.item3.Elvis@1a407d53
*/</span>
</pre></table></code></div></div><p>Supplier의 get 메서드와 Elvis의 getInstance가 매핑됩니다. 실행 결과를 보면 get 메서드가 동일한 Elvis 인스턴스를 리턴하는 것을 알 수 있습니다.</p><p><br /></p><p><strong>정적 팩터리 방식에도 public 필드 방식과 같이 리플렉션과 직렬화에서 예외 상황이 발생할 수 있습니다.</strong> 예제 코드는 public 필드 방식과 거의 동일하니 생략하겠습니다.</p><p><br /></p><h4 id="33-열거-타입">3.3 열거 타입 <a href="#33-열거-타입" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p><strong>원소가 하나인 열거 타입을 선언하는 방식</strong>입니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Elvis</span> <span class="o">{</span>

    <span class="no">INSTANCE</span><span class="o">;</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leaveTheBuilding</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>열거 타입은 상수 하나당 인스턴스를 하나씩 만들어 public static final 필드로 공개합니다. 열거 타입의 인스턴스는 클라이언트가 직접 생성할 수 없고 런타임에 한 번만 생성됩니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">Elvis</span> <span class="n">elvis1</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
<span class="nc">Elvis</span> <span class="n">elvis2</span> <span class="o">=</span> <span class="nc">Elvis</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elvis1</span> <span class="o">==</span> <span class="n">elvis2</span><span class="o">);</span>
<span class="cm">/* 실행 결과
true
*/</span>
</pre></table></code></div></div><p>public 필드 방식과 비슷하지만, 더 간결하고 추가 노력 없이 직렬화 할 수 있고 심지어 <strong>아주 복잡한 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아줍니다.</strong></p><p>조금 부자연스러워 보일 수는 있으나 <strong>대부분의 상황에서 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법입니다.</strong> 단, 만들려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없습니다. 다른 인터페이스를 구현하는 것은 가능합니다.</p><p><br /></p><h2 id="4-문제점">4. 문제점 <a href="#4-문제점" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>싱글턴은 여러 문제점을 가지고 있어 안티 패턴으로도 불리는데요, 그 이유를 알아보겠습니다.</p><p>첫 번째, <strong>멀티스레드 환경에서 동시성 문제가 발생할 수 있습니다.</strong> 하나의 인스턴스를 여러 스레드에서 공유하고 있기 때문에, 어떤 스레드에서 인스턴스의 상태를 변경한다면 이는 다른 스레드에도 영향이 미치게 됩니다. 결국 일관된 값을 보장할 수 없게 되는 것입니다.</p><p>두 번째, <strong>테스트를 수행하기 어렵습니다.</strong> 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜(mock) 구현으로 대체할 수 없습니다. 때문에 격리된 환경에서 독립적인 테스트를 수행하기 어렵습니다.</p><p>세 번째, <strong>의존 관계상 클라이언트가 구체 클래스에 의존하게 됩니다.</strong> new 키워드를 직접 사용하여 클래스 안에서 생성하고 있으므로 객체 지향 설계 SOLID 원칙 중 DIP(의존 역전 원칙)를 위반하게 되고, OCP(개방 폐쇄 원칙) 또한 위반하게 될 가능성이 높습니다.</p><p>네 번째, <strong>객체지향과 맞지 않습니다.</strong> 싱글턴의 사용은 전역 상태를 만들 수 있습니다. 아무 객체나 자유롭게 접근하고 수정할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 지양되어야 할 모델입니다. 또한 싱글턴은 private 생성자를 갖고 있기 때문에 상속이 불가능합니다. 때문에 다형성과 같은 객체지향의 특징이 적용되지 않습니다.</p><p><br /></p><p>싱글턴은 하나의 인스턴스를 생성하고 재사용할 수 있다는 장점이 있기 때문에 필요한 경우가 분명히 있습니다. 하지만 싱글턴을 직접 구현하면 다른 단점들이 너무 크게 부각되기 때문에 활용이 쉽지 않습니다. 때문에 스프링과 같은 프레임워크를 활용하여 프레임워크가 객체를 싱글턴으로 관리하도록 하면 단점을 많이 극복할 수 있습니다.</p><p><br /></p><h2 id="5-related-posts">5. Related Posts <a href="#5-related-posts" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>함수 (Item 24)<li>리플렉션 API (Item 65)<li>제네릭 싱글턴 팩터리 (Item 30)<li>메서드 참조 (Item 43)<li>함수형 인터페이스 (Item 44)<li>readResolve (Item 89)</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/book/'>Book</a>, <a href='/categories/effective-java/'>Effective Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a> <a href="/tags/effective-java/" class="post-tag no-text-decoration" >Effective Java</a> <a href="/tags/singleton/" class="post-tag no-text-decoration" >Singleton</a> <a href="/tags/design-pattern/" class="post-tag no-text-decoration" >Design Pattern</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-1 pt-1 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라 - H&#39;s Tech Blog&amp;url=https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라 - H&#39;s Tech Blog&amp;u=https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://github.com/heung27/posts/effective-java-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/&amp;text=Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라 - H&#39;s Tech Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/item-21-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/">Item 21. 인터페이스는 구현하는 쪽을 생각해 설계하라</a><li><a href="/posts/item-20-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC/">Item 20. 추상 클래스보다는 인터페이스를 우선하라</a><li><a href="/posts/item-19-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%84%9C%ED%99%94%ED%95%98%EB%9D%BC-%EA%B7%B8%EB%9F%AC%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%88%EC%A7%80%ED%95%98%EB%9D%BC/">Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라</a><li><a href="/posts/item-18-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/">Item 18. 상속보다는 컴포지션을 사용하라</a><li><a href="/posts/item-17-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%EC%84%B1%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/">Item 17. 변경 가능성을 최소화하라</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/java-8/">Java 8</a> <a class="post-tag" href="/tags/override/">Override</a> <a class="post-tag" href="/tags/lambda/">Lambda</a> <a class="post-tag" href="/tags/method-reference/">Method Reference</a> <a class="post-tag" href="/tags/constructor/">Constructor</a> <a class="post-tag" href="/tags/functional-interface/">Functional Interface</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/interface/">Interface</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/item-15-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%A4%EB%B2%84%EC%9D%98-%EC%A0%91%EA%B7%BC-%EA%B6%8C%ED%95%9C%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/"><div class="card-body"> <em class="timeago small" data-ts="1655044020" > 2022-06-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Item 15. 클래스와 멤버의 접근 권한을 최소화하라</h3><div class="text-muted small"><p> Effective Java의 열다섯 번째 아이템 “클래스와 멤버의 접근 권한을 최소화하라”를 읽고 정리한 내용을 포스팅합니다. 0. 들어가며 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 잘 설계되 컴포넌트는 모든 내부 구현을 완벽히 숨겨,...</p></div></div></a></div><div class="card"> <a href="/posts/item-16-public-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C%EB%8A%94-public-%ED%95%84%EB%93%9C%EA%B0%80-%EC%95%84%EB%8B%8C-%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/"><div class="card-body"> <em class="timeago small" data-ts="1655194320" > 2022-06-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라</h3><div class="text-muted small"><p> Effective Java의 열여섯 번째 아이템 “public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라”를 읽고 정리한 내용을 포스팅합니다. 0. 들어가며 이번 주제는 이전 포스팅과 상당히 밀접한 내용입니다. 이전에 public 클래스의 인스턴스는 되도록 public이 아니어야 한다고 했는데요. 여기에 초점을 맞춰 자세히 ...</p></div></div></a></div><div class="card"> <a href="/posts/item-17-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%EC%84%B1%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/"><div class="card-body"> <em class="timeago small" data-ts="1655302500" > 2022-06-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Item 17. 변경 가능성을 최소화하라</h3><div class="text-muted small"><p> Effective Java의 열일곱 번째 아이템 “변경 가능성을 최소화하라”를 읽고 정리한 내용을 포스팅합니다. 1. 불변 클래스 불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스를 말한다. 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. String, 기본 타입의 박싱된 클래스들, BigInte...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/effective-java-item-2-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EB%A7%8E%EB%8B%A4%EB%A9%B4-%EB%B9%8C%EB%8D%94%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" class="btn btn-outline-primary" prompt="Older"><p>Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라</p></a> <a href="/posts/item-4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94%EB%A5%BC-%EB%A7%89%EC%9C%BC%EB%A0%A4%EA%B1%B0%EB%93%A0-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" class="btn btn-outline-primary" prompt="Newer"><p>Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/heung27">Jin Heung An</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/effective-java/">Effective Java</a> <a class="post-tag" href="/tags/java-8/">Java 8</a> <a class="post-tag" href="/tags/override/">Override</a> <a class="post-tag" href="/tags/lambda/">Lambda</a> <a class="post-tag" href="/tags/method-reference/">Method Reference</a> <a class="post-tag" href="/tags/constructor/">Constructor</a> <a class="post-tag" href="/tags/functional-interface/">Functional Interface</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/interface/">Interface</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-J2QJ5KLVPE"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-J2QJ5KLVPE'); }); </script>
